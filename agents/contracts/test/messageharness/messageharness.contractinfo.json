{"solidity/MessageHarness.t.sol:BaseMessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204d87ec7435eeaef4ab1f16b6c81e2dab17bfb1053de56613f2cbec33e2cd0acd64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204d87ec7435eeaef4ab1f16b6c81e2dab17bfb1053de56613f2cbec33e2cd0acd64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"56175:6438:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;56175:6438:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"56175:6438:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SENDER":{"details":"Memory layout of BaseMessage fields [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SENDER\":{\"details\":\"Memory layout of BaseMessage fields [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"BaseMessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201a2de65c61e7c3e025820f9a119b8beb4d65513d75fbb8936cad67a3931bac4164736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201a2de65c61e7c3e025820f9a119b8beb4d65513d75fbb8936cad67a3931bac4164736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35474:9174:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35474:9174:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35474:9174:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:HeaderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200217ceec5ed8be16247f78fc9ae8469a7c270101a694cd36d4ad54ea192d28bd64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200217ceec5ed8be16247f78fc9ae8469a7c270101a694cd36d4ad54ea192d28bd64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"64124:4018:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;64124:4018:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"64124:4018:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the header part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"Header memory layout [000 .. 004): origin             uint32   4 bytes    Domain where message originated [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"Header memory layout [000 .. 004): origin             uint32   4 bytes    Domain where message originated [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the header part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"HeaderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b506113e0806100206000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c61608e81161005b578063c61608e8146100de578063c97c703a146100f1578063d7a7a72c14610104578063f9893ddd1461012557600080fd5b806337dcc27b14610082578063801fdbfc146100ab578063c311d359146100cb575b600080fd5b6100956100903660046110d4565b610148565b6040516100a29190611138565b60405180910390f35b6100be6100b93660046110d4565b610167565b6040516100a291906111e7565b6100be6100d93660046110d4565b61019a565b6100be6100ec3660046111fa565b6101bf565b6100be6100ff3660046110d4565b6101d4565b6101176101123660046110d4565b6101f0565b6040519081526020016100a2565b6101386101333660046110d4565b610209565b60405190151581526020016100a2565b600061016161015683610223565b62ffffff1916610236565b92915050565b606061016161018f61018661017b85610223565b62ffffff191661025c565b62ffffff191690565b62ffffff191661027c565b606060006101a783610223565b90506101b862ffffff19821661018f565b9392505050565b60606101cc8484846102cf565b949350505050565b606061016161018f6101e584610223565b62ffffff19166102fe565b60006101616101fe83610223565b62ffffff1916610310565b60006101616102188383610322565b62ffffff1916610346565b6000610161610231836103f5565b610401565b600062ffffff1982166102488161047b565b60ff1660018111156101b8576101b8611109565b600062ffffff1982166101b86102718261048f565b62ffffff19166104a5565b60606000806102998460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506102be8483602001610516565b508181016020016040529052919050565b60608383836040516020016102e693929190611274565b60405160208183030381529060405290509392505050565b600062ffffff1982166101b8816106fd565b600062ffffff1982166101b88161071d565b81516000906020840161033d64ffffffffff8516828461076b565b95945050505050565b6000601882901c6bffffffffffffffffffffffff1661036760106001611319565b8110156103775750600092915050565b60006103828461047b565b9050600160ff8216111561039a575060009392505050565b6103b16103a68561048f565b62ffffff19166107b2565b6103bf575060009392505050565b60ff81166103de576101cc6103d3856106fd565b62ffffff19166107df565b6101cc6103ea856106fd565b62ffffff1916610858565b60006101618282610322565b600061040c82610346565b610477576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f6164000000000000000000000060448201526064015b60405180910390fd5b5090565b600061016162ffffff1983168260016108cd565b600061016162ffffff19831660016010846108fd565b60006104b0826107b2565b610477576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f74206120686561646572207061796c6f6164000000000000000000000000604482015260640161046e565b600062ffffff1980841603610587576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e746572206465726566000000000000604482015260640161046e565b61059083610972565b6105f6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e746572206465726566000000604482015260640161046e565b60006106108460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061062b856109ae565b6bffffffffffffffffffffffff1690506000806040519150858211156106515760206060fd5b8386858560045afa9050806106c2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f6620676173000000000000000000000000604482015260640161046e565b6106f26106ce886109d5565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b600061016161070e60106001611319565b62ffffff1984169060006109f9565b600080610729836109ae565b6bffffffffffffffffffffffff16905060006107538460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b6000806107788385611319565b9050604051811115610788575060005b8060000361079d5762ffffff199150506101b8565b5050606092831b9190911790911b1760181b90565b600060106bffffffffffffffffffffffff601884901c165b6bffffffffffffffffffffffff161492915050565b60006002601883901c6bffffffffffffffffffffffff16101561080457506000919050565b600261080f8361047b565b60ff16111561082057506000919050565b600261082b83610a37565b60ff16111561083c57506000919050565b600061084783610a4b565b90506101b862ffffff198216610a5f565b6000600861086860306040611319565b6108729190611319565b601883901c6bffffffffffffffffffffffff16101561089357506000919050565b6108aa61089f83610a9b565b62ffffff1916610ab1565b6108b657506000919050565b6101616108c283610acd565b62ffffff1916610aef565b60006108da82602061132c565b6108e5906008611345565b60ff166108f3858585610b0b565b901c949350505050565b600080610909866109ae565b6bffffffffffffffffffffffff16905061092286610cb9565b8461092d8784611319565b6109379190611319565b111561094a5762ffffff199150506101cc565b6109548582611319565b90506109688364ffffffffff16828661076b565b9695505050505050565b600061097d826109d5565b64ffffffffff1664ffffffffff0361099757506000919050565b60006109a283610cb9565b60405110199392505050565b6000806109bd60606018611319565b9290921c6bffffffffffffffffffffffff1692915050565b60008060606109e5816018611319565b6109ef9190611319565b9290921c92915050565b60006101cc848485610a198860181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610a319190611368565b856108fd565b600061016162ffffff1983166001806108cd565b600061016162ffffff1983166002836109f9565b6000601882901c6bffffffffffffffffffffffff166004811015610a865750600092915050565b6101b8610a94600483611368565b601f161590565b600061016162ffffff19831660406030846108fd565b600060306bffffffffffffffffffffffff601884901c166107ca565b6000610161610ade60306040611319565b62ffffff19841690600860006108fd565b600060086bffffffffffffffffffffffff601884901c166107ca565b60008160ff16600003610b20575060006101b8565b610b388460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610b5360ff841685611319565b1115610bd657610ba3610b65856109ae565b6bffffffffffffffffffffffff16610b8b8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16610cf2565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161046e91906111e7565b60208260ff161115610c44576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e20333220627974657300000000000000604482015260640161046e565b600882026000610c53866109ae565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b6000610cd38260181c6bffffffffffffffffffffffff1690565b610cdc836109ae565b016bffffffffffffffffffffffff169050919050565b60606000610cff86610e82565b9150506000610d0d86610e82565b9150506000610d1b86610e82565b9150506000610d2986610e82565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600080601f5b600f8160ff161115610ef5576000610ea1826008611345565b60ff1685901c9050610eb281610f6c565b61ffff16841793508160ff16601014610ecd57601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610e88565b50600f5b60ff8160ff161015610f66576000610f12826008611345565b60ff1685901c9050610f2381610f6c565b61ffff16831792508160ff16600014610f3e57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610ef9565b50915091565b6000610f7e60048360ff16901c610f9e565b60ff1661ffff919091161760081b610f9582610f9e565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f84169182908110610feb57610feb61137b565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261103a57600080fd5b813567ffffffffffffffff8082111561105557611055610ffa565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561109b5761109b610ffa565b816040528381528660208588010111156110b457600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156110e657600080fd5b813567ffffffffffffffff8111156110fd57600080fd5b6101cc84828501611029565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6020810160028310611173577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b91905290565b60005b8381101561119457818101518382015260200161117c565b50506000910152565b600081518084526111b5816020860160208601611179565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006101b8602083018461119d565b60008060006060848603121561120f57600080fd5b83356002811061121e57600080fd5b9250602084013567ffffffffffffffff8082111561123b57600080fd5b61124787838801611029565b9350604086013591508082111561125d57600080fd5b5061126a86828701611029565b9150509250925092565b6000600285106112ad577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8460f81b825283516112c6816001850160208801611179565b8351908301906112dd816001840160208801611179565b0160010195945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610161576101616112ea565b60ff8281168282160390811115610161576101616112ea565b60ff8181168382160290811690818114611361576113616112ea565b5092915050565b81810381811115610161576101616112ea565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea26469706673582212208b6592ef307008e5954c5382e96da40e9fa5219f38b32782f98978fe2cd264a464736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c61608e81161005b578063c61608e8146100de578063c97c703a146100f1578063d7a7a72c14610104578063f9893ddd1461012557600080fd5b806337dcc27b14610082578063801fdbfc146100ab578063c311d359146100cb575b600080fd5b6100956100903660046110d4565b610148565b6040516100a29190611138565b60405180910390f35b6100be6100b93660046110d4565b610167565b6040516100a291906111e7565b6100be6100d93660046110d4565b61019a565b6100be6100ec3660046111fa565b6101bf565b6100be6100ff3660046110d4565b6101d4565b6101176101123660046110d4565b6101f0565b6040519081526020016100a2565b6101386101333660046110d4565b610209565b60405190151581526020016100a2565b600061016161015683610223565b62ffffff1916610236565b92915050565b606061016161018f61018661017b85610223565b62ffffff191661025c565b62ffffff191690565b62ffffff191661027c565b606060006101a783610223565b90506101b862ffffff19821661018f565b9392505050565b60606101cc8484846102cf565b949350505050565b606061016161018f6101e584610223565b62ffffff19166102fe565b60006101616101fe83610223565b62ffffff1916610310565b60006101616102188383610322565b62ffffff1916610346565b6000610161610231836103f5565b610401565b600062ffffff1982166102488161047b565b60ff1660018111156101b8576101b8611109565b600062ffffff1982166101b86102718261048f565b62ffffff19166104a5565b60606000806102998460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506102be8483602001610516565b508181016020016040529052919050565b60608383836040516020016102e693929190611274565b60405160208183030381529060405290509392505050565b600062ffffff1982166101b8816106fd565b600062ffffff1982166101b88161071d565b81516000906020840161033d64ffffffffff8516828461076b565b95945050505050565b6000601882901c6bffffffffffffffffffffffff1661036760106001611319565b8110156103775750600092915050565b60006103828461047b565b9050600160ff8216111561039a575060009392505050565b6103b16103a68561048f565b62ffffff19166107b2565b6103bf575060009392505050565b60ff81166103de576101cc6103d3856106fd565b62ffffff19166107df565b6101cc6103ea856106fd565b62ffffff1916610858565b60006101618282610322565b600061040c82610346565b610477576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f6164000000000000000000000060448201526064015b60405180910390fd5b5090565b600061016162ffffff1983168260016108cd565b600061016162ffffff19831660016010846108fd565b60006104b0826107b2565b610477576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f74206120686561646572207061796c6f6164000000000000000000000000604482015260640161046e565b600062ffffff1980841603610587576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e746572206465726566000000000000604482015260640161046e565b61059083610972565b6105f6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e746572206465726566000000604482015260640161046e565b60006106108460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061062b856109ae565b6bffffffffffffffffffffffff1690506000806040519150858211156106515760206060fd5b8386858560045afa9050806106c2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f6620676173000000000000000000000000604482015260640161046e565b6106f26106ce886109d5565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b600061016161070e60106001611319565b62ffffff1984169060006109f9565b600080610729836109ae565b6bffffffffffffffffffffffff16905060006107538460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b6000806107788385611319565b9050604051811115610788575060005b8060000361079d5762ffffff199150506101b8565b5050606092831b9190911790911b1760181b90565b600060106bffffffffffffffffffffffff601884901c165b6bffffffffffffffffffffffff161492915050565b60006002601883901c6bffffffffffffffffffffffff16101561080457506000919050565b600261080f8361047b565b60ff16111561082057506000919050565b600261082b83610a37565b60ff16111561083c57506000919050565b600061084783610a4b565b90506101b862ffffff198216610a5f565b6000600861086860306040611319565b6108729190611319565b601883901c6bffffffffffffffffffffffff16101561089357506000919050565b6108aa61089f83610a9b565b62ffffff1916610ab1565b6108b657506000919050565b6101616108c283610acd565b62ffffff1916610aef565b60006108da82602061132c565b6108e5906008611345565b60ff166108f3858585610b0b565b901c949350505050565b600080610909866109ae565b6bffffffffffffffffffffffff16905061092286610cb9565b8461092d8784611319565b6109379190611319565b111561094a5762ffffff199150506101cc565b6109548582611319565b90506109688364ffffffffff16828661076b565b9695505050505050565b600061097d826109d5565b64ffffffffff1664ffffffffff0361099757506000919050565b60006109a283610cb9565b60405110199392505050565b6000806109bd60606018611319565b9290921c6bffffffffffffffffffffffff1692915050565b60008060606109e5816018611319565b6109ef9190611319565b9290921c92915050565b60006101cc848485610a198860181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610a319190611368565b856108fd565b600061016162ffffff1983166001806108cd565b600061016162ffffff1983166002836109f9565b6000601882901c6bffffffffffffffffffffffff166004811015610a865750600092915050565b6101b8610a94600483611368565b601f161590565b600061016162ffffff19831660406030846108fd565b600060306bffffffffffffffffffffffff601884901c166107ca565b6000610161610ade60306040611319565b62ffffff19841690600860006108fd565b600060086bffffffffffffffffffffffff601884901c166107ca565b60008160ff16600003610b20575060006101b8565b610b388460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610b5360ff841685611319565b1115610bd657610ba3610b65856109ae565b6bffffffffffffffffffffffff16610b8b8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16610cf2565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161046e91906111e7565b60208260ff161115610c44576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e20333220627974657300000000000000604482015260640161046e565b600882026000610c53866109ae565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b6000610cd38260181c6bffffffffffffffffffffffff1690565b610cdc836109ae565b016bffffffffffffffffffffffff169050919050565b60606000610cff86610e82565b9150506000610d0d86610e82565b9150506000610d1b86610e82565b9150506000610d2986610e82565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600080601f5b600f8160ff161115610ef5576000610ea1826008611345565b60ff1685901c9050610eb281610f6c565b61ffff16841793508160ff16601014610ecd57601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610e88565b50600f5b60ff8160ff161015610f66576000610f12826008611345565b60ff1685901c9050610f2381610f6c565b61ffff16831792508160ff16600014610f3e57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610ef9565b50915091565b6000610f7e60048360ff16901c610f9e565b60ff1661ffff919091161760081b610f9582610f9e565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f84169182908110610feb57610feb61137b565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261103a57600080fd5b813567ffffffffffffffff8082111561105557611055610ffa565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561109b5761109b610ffa565b816040528381528660208588010111156110b457600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156110e657600080fd5b813567ffffffffffffffff8111156110fd57600080fd5b6101cc84828501611029565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6020810160028310611173577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b91905290565b60005b8381101561119457818101518382015260200161117c565b50506000910152565b600081518084526111b5816020860160208601611179565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006101b8602083018461119d565b60008060006060848603121561120f57600080fd5b83356002811061121e57600080fd5b9250602084013567ffffffffffffffff8082111561123b57600080fd5b61124787838801611029565b9350604086013591508082111561125d57600080fd5b5061126a86828701611029565b9150509250925092565b6000600285106112ad577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8460f81b825283516112c6816001850160208801611179565b8351908301906112dd816001840160208801611179565b0160010195945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610161576101616112ea565b60ff8281168282160390811115610161576101616112ea565b60ff8181168382160290811690818114611361576113616112ea565b5092915050565b81810381811115610161576101616112ea565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea26469706673582212208b6592ef307008e5954c5382e96da40e9fa5219f38b32782f98978fe2cd264a464736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"85039:2198:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"85039:2198:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;86022:124;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;86152:146;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;85670:346::-;;;;;;:::i;:::-;;:::i;87017:218::-;;;;;;:::i;:::-;;:::i;86304:133::-;;;;;;:::i;:::-;;:::i;86443:120::-;;;;;;:::i;:::-;;:::i;:::-;;;3566:25:1;;;3554:2;3539:18;86443:120:0;3420:177:1;86569:118:0;;;;;;:::i;:::-;;:::i;:::-;;;3767:14:1;;3760:22;3742:41;;3730:2;3715:18;86569:118:0;3602:187:1;86022:124:0;86079:11;86109:30;:23;:7;:21;:23::i;:::-;-1:-1:-1;;86109:28:0;;:30::i;:::-;86102:37;86022:124;-1:-1:-1;;86022:124:0:o;86152:146::-;86211:12;86242:49;:41;:32;:23;:7;:21;:23::i;:::-;-1:-1:-1;;86242:30:0;;:32::i;:::-;-1:-1:-1;;86242:39:0;66888:6;66794:108;86242:41;-1:-1:-1;;86242:47:0;;:49::i;85670:346::-;85736:12;85917:15;85935:33;85960:7;85935:24;:33::i;:::-;85917:51;-1:-1:-1;85985:24:0;-1:-1:-1;;85985:14:0;;:16;66794:108;85985:24;85978:31;85670:346;-1:-1:-1;;;85670:346:0:o;87017:218::-;87146:12;87181:47;87206:5;87213:7;87222:5;87181:24;:47::i;:::-;87174:54;87017:218;-1:-1:-1;;;;87017:218:0:o;86304:133::-;86361:12;86392:38;:30;:23;:7;:21;:23::i;:::-;-1:-1:-1;;86392:28:0;;:30::i;86443:120::-;86500:7;86526:30;:23;:7;:21;:23::i;:::-;-1:-1:-1;;86526:28:0;;:30::i;86569:118::-;86631:4;86654:26;:14;:7;86631:4;86654:11;:14::i;:::-;-1:-1:-1;;86654:24:0;;:26::i;80757:140::-;80825:7;80851:39;80865:24;:7;:22;:24::i;:::-;80851:13;:39::i;82938:275::-;82992:11;-1:-1:-1;;83031:14:0;;83193:12;83031:14;83193:5;:12::i;:::-;83181:25;;;;;;;;;;:::i;83284:286::-;83340:6;-1:-1:-1;;83374:14:0;;83534:29;:14;83374;83534:7;:14::i;:::-;-1:-1:-1;;83534:27:0;;:29::i;30992:626::-;31045:16;31073:11;31094:12;31109:10;31113:5;3310:2;18352:20;3703:16;18348:37;;17836:565;31109:10;31094:25;;;;31229:4;31223:11;31216:18;;31284:3;31277:10;;31330:31;31343:5;31350:3;31356:4;31350:10;31330:12;:31::i;:::-;-1:-1:-1;31485:14:0;;;31501:4;31481:25;31475:4;31468:39;31548:17;;30992:626;;-1:-1:-1;30992:626:0:o;80392:212::-;80523:12;80575:5;80582:7;80591:5;80558:39;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;80551:46;;80392:212;;;;;:::o;83648:141::-;83702:7;-1:-1:-1;;83737:14:0;;83770:12;83737:14;83770:5;:12::i;82435:143::-;82489:7;-1:-1:-1;;82524:14:0;;82557;82524;82557:12;:14::i;14469:595::-;14573:10;;14539:7;;14999:4;14990:14;;15031:26;;;;14990:14;14573:10;15031:5;:26::i;:::-;15024:33;14469:595;-1:-1:-1;;;;;14469:595:0:o;81303:866::-;81360:4;3310:2;18352:20;;;3703:16;18348:37;79699:29;46335:2;79653:1;79699:29;:::i;:::-;81475:6;:20;81471:38;;;-1:-1:-1;81504:5:0;;81303:866;-1:-1:-1;;81303:866:0:o;81471:38::-;81519:11;81533:12;81539:5;81533;:12::i;:::-;81519:26;-1:-1:-1;81627:21:0;81613:36;;;;81609:54;;;-1:-1:-1;81658:5:0;;81303:866;-1:-1:-1;;;81303:866:0:o;81609:54::-;81720:25;:14;81728:5;81720:7;:14::i;:::-;-1:-1:-1;;81720:23:0;;:25::i;:::-;81715:44;;-1:-1:-1;81754:5:0;;81303:866;-1:-1:-1;;;81303:866:0:o;81715:44::-;81883:34;;;81879:284;;81999:30;:12;82005:5;81999;:12::i;:::-;-1:-1:-1;;81999:28:0;;:30::i;81879:284::-;82124:28;:12;82130:5;82124;:12::i;:::-;-1:-1:-1;;82124:26:0;;:28::i;36639:127::-;36708:7;36734:25;:7;36708;36734:11;:25::i;81047:173::-;81108:7;81135:16;81145:5;81135:9;:16::i;:::-;81127:50;;;;;;;5117:2:1;81127:50:0;;;5099:21:1;5156:2;5136:18;;;5129:30;5195:23;5175:18;;;5168:51;5236:18;;81127:50:0;;;;;;;;;-1:-1:-1;81207:5:0;81047:173::o;84198:139::-;84250:5;84280:49;-1:-1:-1;;84280:15:0;;84250:5;84326:1;84280:15;:49::i;84493:156::-;84547:7;84573:69;-1:-1:-1;;84573:11:0;;79653:1;46335:2;84547:7;84573:11;:69::i;66364:168::-;66424:6;66450:15;66459:5;66450:8;:15::i;:::-;66442:48;;;;;;;5467:2:1;66442:48:0;;;5449:21:1;5506:2;5486:18;;;5479:30;5545:22;5525:18;;;5518:50;5585:18;;66442:48:0;5265:344:1;29775:846:0;29850:15;-1:-1:-1;;7985:13:0;;;;29877:53;;;;;;;5816:2:1;29877:53:0;;;5798:21:1;5855:2;5835:18;;;5828:30;5894:28;5874:18;;;5867:56;5940:18;;29877:53:0;5614:350:1;29877:53:0;29948:14;29956:5;29948:7;:14::i;:::-;29940:56;;;;;;;6171:2:1;29940:56:0;;;6153:21:1;6210:2;6190:18;;;6183:30;6249:31;6229:18;;;6222:59;6298:18;;29940:56:0;5969:353:1;29940:56:0;30006:12;30021:10;30025:5;3310:2;18352:20;3703:16;18348:37;;17836:565;30021:10;30006:25;;;;30041:14;30058:10;30062:5;30058:3;:10::i;:::-;30041:27;;;;30079:11;30100:8;30218:4;30212:11;30205:18;;30305:6;30300:3;30297:15;30294:41;;;30328:4;30322;30315:18;30294:41;30484:4;30476:6;30470:4;30462:6;30456:4;30449:5;30438:51;30431:58;;30516:3;30508:36;;;;;;;6529:2:1;30508:36:0;;;6511:21:1;6568:2;6548:18;;;6541:30;6607:22;6587:18;;;6580:50;6647:18;;30508:36:0;6327:344:1;30508:36:0;30565:49;30586:13;30593:5;30586:6;:13::i;:::-;12684:32;3222:2;12684:32;;;;12820:17;;12807:31;;12942:17;;3310:2;12927:33;;12076:900;30565:49;30555:59;29775:846;-1:-1:-1;;;;;;;29775:846:0:o;84801:135::-;84853:7;84879:50;79699:29;46335:2;79653:1;79699:29;:::i;:::-;-1:-1:-1;;84879:15:0;;;84926:1;84879:15;:50::i;24892:284::-;24946:14;24972:12;24987:10;24991:5;24987:3;:10::i;:::-;24972:25;;;;25007:12;25022:10;25026:5;3310:2;18352:20;3703:16;18348:37;;17836:565;25022:10;25007:25;;25139:21;;;;24892:284;-1:-1:-1;;;24892:284:0:o;13515:557::-;13596:15;;13638:11;13645:4;13638;:11;:::i;:::-;13623:26;;13917:4;13911:11;13905:4;13902:21;13899:38;;;-1:-1:-1;13934:1:0;13899:38;13960:4;13968:1;13960:9;13956:51;;-1:-1:-1;;13985:11:0;;;;;13956:51;-1:-1:-1;;3222:2:0;12684:32;;;12820:17;;;;12807:31;;;12942:17;3310:2;12927:33;;13515:557::o;66614:114::-;66670:4;46335:2;3703:16;3310:2;18352:20;;;18348:37;66693:11;:28;;;;66614:114;-1:-1:-1;;66614:114:0:o;74850:610::-;74913:4;73193:1;3310:2;18352:20;;;3703:16;18348:37;74995:29;74991:47;;;-1:-1:-1;75033:5:0;;74850:610;-1:-1:-1;74850:610:0:o;74991:47::-;75130:22;75107:14;75115:5;75107:7;:14::i;:::-;:46;;;75103:64;;;-1:-1:-1;75162:5:0;;74850:610;-1:-1:-1;74850:610:0:o;75103:64::-;75265:22;75239:17;75250:5;75239:10;:17::i;:::-;:49;;;75235:67;;;-1:-1:-1;75297:5:0;;74850:610;-1:-1:-1;74850:610:0:o;75235:67::-;75312:20;75335:16;75345:5;75335:9;:16::i;:::-;75312:39;-1:-1:-1;75428:25:0;-1:-1:-1;;75428:23:0;;;:25::i;59035:431::-;59096:4;46411:1;57148:25;46511:2;57098;57148:25;:::i;:::-;57221:31;;;;:::i;:::-;3310:2;18352:20;;;3703:16;18348:37;59173:28;59169:46;;;-1:-1:-1;59210:5:0;;59035:431;-1:-1:-1;59035:431:0:o;59169:46::-;59276:21;:12;59282:5;59276;:12::i;:::-;-1:-1:-1;;59276:19:0;;:21::i;:::-;59271:40;;-1:-1:-1;59306:5:0;;59035:431;-1:-1:-1;59035:431:0:o;59271:40::-;59374:27;:15;59383:5;59374:8;:15::i;:::-;-1:-1:-1;;59374:25:0;;:27::i;23411:340::-;23498:14;23727:11;23732:6;23727:2;:11;:::i;:::-;23726:17;;23742:1;23726:17;:::i;:::-;23684:60;;23692:28;23698:5;23705:6;23713;23692:5;:28::i;:::-;23684:60;;;23411:340;-1:-1:-1;;;;23411:340:0:o;18990:355::-;19089:7;19108:12;19123:10;19127:5;19123:3;:10::i;:::-;19108:25;;;;19217:10;19221:5;19217:3;:10::i;:::-;19210:4;19194:13;19201:6;19194:4;:13;:::i;:::-;:20;;;;:::i;:::-;:33;19190:75;;;-1:-1:-1;;19243:11:0;;;;;19190:75;19282:13;19289:6;19282:4;:13;:::i;:::-;19275:20;;19312:26;19318:7;19312:26;;19327:4;19333;19312:5;:26::i;:::-;19305:33;18990:355;-1:-1:-1;;;;;;18990:355:0:o;8652:459::-;8707:8;8731:13;8738:5;8731:6;:13::i;:::-;:29;;8748:12;8731:29;8727:72;;-1:-1:-1;8783:5:0;;8652:459;-1:-1:-1;8652:459:0:o;8727:72::-;8808:12;8823:10;8827:5;8823:3;:10::i;:::-;9088:4;9082:11;-1:-1:-1;9069:26:0;;8652:459;-1:-1:-1;;;8652:459:0:o;16417:565::-;16468:11;;3494:20;3265:2;3310;3494:20;:::i;:::-;16933;;;;3703:16;16929:37;;16417:565;-1:-1:-1;;16417:565:0:o;15256:498::-;15310:12;;3222:2;3494:20;3222:2;3310;3494:20;:::i;:::-;3574;;;;:::i;:::-;15717:21;;;;;15256:498;-1:-1:-1;;15256:498:0:o;19652:172::-;19741:7;19767:50;19773:5;19780:6;19801;19788:10;19792:5;3310:2;18352:20;3703:16;18348:37;;17836:565;19788:10;:19;;;;;;:::i;:::-;19809:7;19767:5;:50::i;77758:149::-;77815:5;77845:54;-1:-1:-1;;77845:15:0;;73143:1;;77845:15;:54::i;78067:143::-;78123:7;78149:54;-1:-1:-1;;78149:15:0;;73193:1;78123:7;78149:15;:54::i;41948:358::-;42006:4;3310:2;18352:20;;;3703:16;18348:37;36315:1;42125:24;;42121:42;;;-1:-1:-1;42158:5:0;;41948:358;-1:-1:-1;;41948:358:0:o;42121:42::-;42263:36;42274:24;36315:1;42274:6;:24;:::i;:::-;44632:2;44623:11;:16;;44495:151;62144:150;62196:7;62222:65;-1:-1:-1;;62222:11:0;;57098:2;46511;62196:7;62222:11;:65::i;54112:110::-;54166:4;46511:2;3703:16;3310:2;18352:20;;;18348:37;54189:11;17836:565;62452:159;62507:7;62533:71;57148:25;46511:2;57098;57148:25;:::i;:::-;-1:-1:-1;;62533:11:0;;;46411:1;62601;62533:11;:71::i;50392:116::-;50449:4;46411:1;3703:16;3310:2;18352:20;;;18348:37;50472:11;17836:565;22218:848;22301:14;22331:6;:11;;22341:1;22331:11;22327:59;;-1:-1:-1;22373:1:0;22358:17;;22327:59;22417:10;22421:5;3310:2;18352:20;3703:16;18348:37;;17836:565;22417:10;22399:28;;:15;;;;:6;:15;:::i;:::-;:28;22395:131;;;22450:64;22466:10;22470:5;22466:3;:10::i;:::-;22450:64;;22478:10;22482:5;3310:2;18352:20;3703:16;18348:37;;17836:565;22478:10;22450:64;;22490:6;22506;22498:15;;22450;:64::i;:::-;22443:72;;;;;;;;;;;:::i;22395:131::-;22553:2;22543:6;:12;;;;22535:50;;;;;;;7621:2:1;22535:50:0;;;7603:21:1;7660:2;7640:18;;;7633:30;7699:27;7679:18;;;7672:55;7744:18;;22535:50:0;7419:349:1;22535:50:0;22666:1;22657:10;;22596:15;22702:10;22706:5;22702:3;:10::i;:::-;22687:25;;;-1:-1:-1;22778:12:0;7474:66;7460:12;;;7456:85;23025:17;;;;23019:24;23015:35;;;-1:-1:-1;;;;;22218:848:0:o;18569:141::-;18620:7;18683:10;18687:5;3310:2;18352:20;3703:16;18348:37;;17836:565;18683:10;18670;18674:5;18670:3;:10::i;:::-;:23;18663:30;;;;18569:141;;;:::o;20985:731::-;21117:17;21153:9;21166:15;21176:4;21166:9;:15::i;:::-;21150:31;;;21194:9;21207:15;21217:4;21207:9;:15::i;:::-;21191:31;;;21235:9;21248:17;21258:6;21248:9;:17::i;:::-;21232:33;;;21278:9;21291:17;21301:6;21291:9;:17::i;:::-;21344:355;;;8614:34:1;21344:355:0;;;8602:47:1;8679:23;8665:12;;;8658:45;8722:66;8826:3;8822:16;;;8818:25;;8804:12;;;8797:47;8863:17;8896:12;;;8889:24;;;8947:16;;;8943:25;;8929:12;;;8922:47;8999:34;8985:12;;;8978:56;9065:3;9050:13;;;9043:26;9104:16;;;9100:25;;9085:13;;;9078:48;9142:13;;;9135:25;;;;9195:16;;9191:25;;;9176:13;;;9169:48;-1:-1:-1;;7850:3:1;9263:13;;;7838:16;21344:355:0;;;;;;;;;7870:11:1;;;;21344:355:0;;;;;-1:-1:-1;;;;;20985:731:0:o;4906:662::-;4959:13;;5015:2;5000:256;5023:2;5019:1;:6;;;5000:256;;;5042:11;5068:5;:1;5072;5068:5;:::i;:::-;5062:12;;:1;:12;;5042:33;;5098:14;5106:5;5098:7;:14::i;:::-;5089:23;;;;;;5130:1;:7;;5135:2;5130:7;5126:58;;5167:2;5157:12;;;;;5126:58;-1:-1:-1;5225:6:0;;5000:256;;;-1:-1:-1;5319:2:0;5304:258;5327:3;5323:1;:7;;;5304:258;;;5347:11;5373:5;:1;5377;5373:5;:::i;:::-;5367:12;;:1;:12;;5347:33;;5404:14;5412:5;5404:7;:14::i;:::-;5394:24;;;;;;5436:1;:6;;5441:1;5436:6;5432:58;;5473:2;5462:13;;;;;5432:58;-1:-1:-1;5531:6:0;;5304:258;;;;4906:662;;;:::o;4386:196::-;4435:14;4472:17;4487:1;4482;:6;;;;4472:9;:17::i;:::-;4461:28;;4513:13;;;;;;4525:1;4513:13;4547:12;4557:1;4547:9;:12::i;:::-;4536:23;;;;4386:196;-1:-1:-1;4386:196:0:o;4015:199::-;4185:13;;;;;;;;;;;;;;;;;;4070:10;;4115:4;4107:12;;;;;4185:21;;;;;;:::i;:::-;;;;;;;;4015:199;-1:-1:-1;;;4015:199:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1310:184::-;1362:77;1359:1;1352:88;1459:4;1456:1;1449:15;1483:4;1480:1;1473:15;1499:401;1647:2;1632:18;;1680:1;1669:13;;1659:201;;1716:77;1713:1;1706:88;1817:4;1814:1;1807:15;1845:4;1842:1;1835:15;1659:201;1869:25;;;1499:401;:::o;1905:250::-;1990:1;2000:113;2014:6;2011:1;2008:13;2000:113;;;2090:11;;;2084:18;2071:11;;;2064:39;2036:2;2029:10;2000:113;;;-1:-1:-1;;2147:1:1;2129:16;;2122:27;1905:250::o;2160:329::-;2201:3;2239:5;2233:12;2266:6;2261:3;2254:19;2282:76;2351:6;2344:4;2339:3;2335:14;2328:4;2321:5;2317:16;2282:76;:::i;:::-;2403:2;2391:15;2408:66;2387:88;2378:98;;;;2478:4;2374:109;;2160:329;-1:-1:-1;;2160:329:1:o;2494:217::-;2641:2;2630:9;2623:21;2604:4;2661:44;2701:2;2690:9;2686:18;2678:6;2661:44;:::i;2716:699::-;2827:6;2835;2843;2896:2;2884:9;2875:7;2871:23;2867:32;2864:52;;;2912:1;2909;2902:12;2864:52;2951:9;2938:23;2990:1;2983:5;2980:12;2970:40;;3006:1;3003;2996:12;2970:40;3029:5;-1:-1:-1;3085:2:1;3070:18;;3057:32;3108:18;3138:14;;;3135:34;;;3165:1;3162;3155:12;3135:34;3188:49;3229:7;3220:6;3209:9;3205:22;3188:49;:::i;:::-;3178:59;;3290:2;3279:9;3275:18;3262:32;3246:48;;3319:2;3309:8;3306:16;3303:36;;;3335:1;3332;3325:12;3303:36;;3358:51;3401:7;3390:8;3379:9;3375:24;3358:51;:::i;:::-;3348:61;;;2716:699;;;;;:::o;3794:797::-;4011:3;4050:1;4042:6;4039:13;4029:201;;4086:77;4083:1;4076:88;4187:4;4184:1;4177:15;4215:4;4212:1;4205:15;4029:201;4260:6;4255:3;4251:16;4246:3;4239:29;4297:6;4291:13;4313:74;4380:6;4376:1;4371:3;4367:11;4360:4;4352:6;4348:17;4313:74;:::i;:::-;4447:13;;4406:16;;;;4469:75;4447:13;4531:1;4523:10;;4516:4;4504:17;;4469:75;:::i;:::-;4564:17;4583:1;4560:25;;3794:797;-1:-1:-1;;;;;3794:797:1:o;4596:184::-;4648:77;4645:1;4638:88;4745:4;4742:1;4735:15;4769:4;4766:1;4759:15;4785:125;4850:9;;;4871:10;;;4868:36;;;4884:18;;:::i;6676:151::-;6766:4;6759:12;;;6745;;;6741:31;;6784:14;;6781:40;;;6801:18;;:::i;6832:225::-;6936:4;6915:12;;;6929;;;6911:31;6962:22;;;;7003:24;;;6993:58;;7031:18;;:::i;:::-;6993:58;6832:225;;;;:::o;7062:128::-;7129:9;;;7150:11;;;7147:37;;;7164:18;;:::i;9288:184::-;9340:77;9337:1;9330:88;9437:4;9434:1;9427:15;9461:4;9458:1;9451:15","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"flag","outputs":[{"internalType":"enum MessageFlag","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"enum MessageFlag","name":"flag_","type":"uint8"},{"internalType":"bytes","name":"header_","type":"bytes"},{"internalType":"bytes","name":"body_","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"header","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isMessage","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Message methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"flag_\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"header_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"body_\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"header\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Message methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","castToMessage(bytes)":"c311d359","flag(bytes)":"37dcc27b","formatMessage(uint8,bytes,bytes)":"c61608e8","header(bytes)":"801fdbfc","isMessage(bytes)":"f9893ddd","leaf(bytes)":"d7a7a72c"}},"solidity/MessageHarness.t.sol:MessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220601dd102071dd3042f36c35e3126d361992266d7c2a502d9dd4c6cb58e995cfa64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220601dd102071dd3042f36c35e3126d361992266d7c2a502d9dd4c6cb58e995cfa64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"78916:6022:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;78916:6022:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"78916:6022:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting the various messages supported by Origin and Destination.","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_FLAG":{"details":"Message memory layout [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_FLAG\":{\"details\":\"Message memory layout [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting the various messages supported by Origin and Destination.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209edf9e5b8d245f8587c9dadfc0118c051356acee58aed92ffca090f395f020d264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209edf9e5b8d245f8587c9dadfc0118c051356acee58aed92ffca090f395f020d264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"48653:2548:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;48653:2548:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"48653:2548:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_GAS_LIMIT":{"details":"Request structure represents a message sender requirements for the message execution on the destination chain.Memory layout of Request fields TODO: figure out the fields packing (uint64 is too much for gas limit) [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_GAS_LIMIT\":{\"details\":\"Request structure represents a message sender requirements for the message execution on the destination chain.Memory layout of Request fields TODO: figure out the fields packing (uint64 is too much for gas limit) [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:SystemMessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204680e255482859ced451ae61386fb21fc3d2ea5ba6f87d8d3d88f257eb4f18a264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204680e255482859ced451ae61386fb21fc3d2ea5ba6f87d8d3d88f257eb4f18a264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"72326:5886:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;72326:5886:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"72326:5886:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SENDER":{"details":"SystemMessage memory layout Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain. [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SENDER\":{\"details\":\"SystemMessage memory layout Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain. [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"SystemMessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201961cced3cf837385dda4a7a48614850e22b61b89d71c4bbfbd0efe1edb273d764736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201961cced3cf837385dda4a7a48614850e22b61b89d71c4bbfbd0efe1edb273d764736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"51628:4328:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;51628:4328:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"51628:4328:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_NOTARY":{"details":"Tips memory layout [000 .. 012): notaryTip          uint96\t12 bytes [012 .. 024): broadcasterTip     uint96\t12 bytes [024 .. 036): proverTip          uint96\t12 bytes [036 .. 048): executorTip        uint96\t12 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_NOTARY\":{\"details\":\"Tips memory layout [000 .. 012): notaryTip          uint96\\t12 bytes [012 .. 024): broadcasterTip     uint96\\t12 bytes [024 .. 036): proverTip          uint96\\t12 bytes [036 .. 048): executorTip        uint96\\t12 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d9ce50a5b983da3aaf5c069e9a863bf7723389cc7cfc33e5d7b57f7e66b9059764736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d9ce50a5b983da3aaf5c069e9a863bf7723389cc7cfc33e5d7b57f7e66b9059764736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"62615:1088:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;62615:1088:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"62615:1088:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220179572574071eb1497a458ac4db4b486ea456cd708ddea548dd284c26d8c8c1664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220179572574071eb1497a458ac4db4b486ea456cd708ddea548dd284c26d8c8c1664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,address,address,tips): 4+4+32+32+20+20+tips_length\nuint256 constant RECEIPT_LENGTH = 112 + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is bytes29;\n\n/// @dev Attach library functions to Snapshot\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(bytes29 view_) internal pure returns (Request) {\n        require(isRequest(view_), \"Not a request\");\n        return Request.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (bytes29) {\n        return Request.unwrap(request);\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        bytes29 view_ = unwrap(request);\n        return uint64(view_.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is bytes29;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using ByteString for bytes;\n    using RequestLib for bytes29;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(bytes29 view_) internal pure returns (BaseMessage) {\n        require(isBaseMessage(view_), \"Not a base message\");\n        return BaseMessage.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (view_.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(view_).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(view_).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (bytes29) {\n        return BaseMessage.unwrap(baseMessage);\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(view_).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        bytes29 view_ = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(view_).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (bytes29) {\n        bytes29 view_ = baseMessage.unwrap();\n        return view_.sliceFrom({index_: OFFSET_CONTENT, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH, newType: 0});\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory s) internal pure returns (bytes32 b) {\n        b = bytes(s).ref(0).index(0, uint8(bytes(s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 buf) internal pure returns (string memory newStr) {\n        uint8 sLen = 0;\n        while (sLen \u003c 32 \u0026\u0026 buf[sLen] != 0) {\n            sLen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            newStr := mload(0x40)\n            mstore(0x40, add(newStr, 0x40)) // may end up with extra\n            mstore(newStr, sLen)\n            mstore(add(newStr, 0x20), buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is bytes29;\n\n/// @dev Attach library functions to Header\nusing {\n    HeaderLib.unwrap,\n    HeaderLib.origin,\n    HeaderLib.nonce,\n    HeaderLib.destination,\n    HeaderLib.optimisticPeriod\n} for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(bytes29 view_) internal pure returns (Header) {\n        require(isHeader(view_), \"Not a header payload\");\n        return Header.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (bytes29) {\n        return Header.unwrap(header);\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        bytes29 view_ = unwrap(header);\n        return uint32(view_.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is bytes29;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using ByteString for bytes;\n    using ByteString for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes29 view_) internal pure returns (SystemMessage) {\n        require(isSystemMessage(view_), \"Not a system message\");\n        return SystemMessage.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(bytes29 view_) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (view_.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(view_) \u003e uint8(type(SystemEntity).max)) return false;\n        bytes29 callDataView = _callData(view_);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (bytes29) {\n        return SystemMessage.unwrap(systemMessage);\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(view_));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(view_));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        bytes29 view_ = systemMessage.unwrap();\n        return _callData(view_).castToCallData();\n    }\n\n    // ═════════════════════════════════════════════ PRIVATE FUNCTIONS ═════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_CALLDATA, newType: 0});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is bytes29;\n\n/// @dev Attach library functions to Message\nusing {MessageLib.unwrap, MessageLib.leaf, MessageLib.flag, MessageLib.header, MessageLib.body} for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing {MessageLib.formatMessage} for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for bytes29;\n    using ByteString for bytes;\n    using HeaderLib for bytes29;\n    using SystemMessageLib for bytes29;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(bytes29 view_) internal pure returns (Message) {\n        require(isMessage(view_), \"Not a message payload\");\n        return Message.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(view_);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(view_).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(view_).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(view_).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (bytes29) {\n        return Message.unwrap(message);\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        bytes29 view_ = message.unwrap();\n        return view_.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        bytes29 view_ = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(view_));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        bytes29 view_ = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(view_).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (bytes29) {\n        bytes29 view_ = message.unwrap();\n        return _body(view_);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(bytes29 view_) private pure returns (uint8) {\n        return uint8(view_.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(bytes29 view_) private pure returns (bytes29) {\n        return view_.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH, newType: 0});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(bytes29 view_) private pure returns (bytes29) {\n        return view_.sliceFrom({index_: OFFSET_BODY, newType: 0});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"58:34812:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;58:34812:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"58:34812:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3143:38;;3179:2;3143:38;;;;;168:25:1;;;156:2;141:18;3143:38:0;;;;;;;;3400:46;;3310:2;3400:46;;3537:57;;;:::i;3458:56::-;;;:::i;3660:59::-;;3703:16;3660:59;;3230:37;;3265:2;3230:37;;2572:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2572:94:0;204:258:1;3537:57:0;3222:2;3494:20;3222:2;3310;3494:20;:::i;:::-;3574;;;;:::i;:::-;3537:57;:::o;3458:56::-;3494:20;3265:2;3310;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 TODO (Chi): with the user defined types storing type is no longer necessary. Update the library, transforming bytes29 to bytes24 in the process. [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 TODO (Chi): with the user defined types storing type is no longer necessary. Update the library, transforming bytes29 to bytes24 in the process. [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x21deed1e20512322029860f403fe16a6e0e61424f54459764b61f077cd0d609d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://580ca3c68d8f27feee68e08a33689818d7f761d63cfb56ddf7f67b845e35ea64\",\"dweb:/ipfs/QmRwrSk3BCqgyRwH4MiSKchFUct11ArjGQZo8MgDq8Fhvn\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}