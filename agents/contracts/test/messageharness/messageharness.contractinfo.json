{"solidity/MessageHarness.t.sol:BaseMessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203f907a74365cd90f8e295a8e486d7ed3c00a53aa010a9df8ed069b34b48471c664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203f907a74365cd90f8e295a8e486d7ed3c00a53aa010a9df8ed069b34b48471c664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35200:6427:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35200:6427:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35200:6427:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SENDER":{"details":"Memory layout of BaseMessage fields [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SENDER\":{\"details\":\"Memory layout of BaseMessage fields [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"BaseMessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220be8cdfbccac187759bb1cb8cd811da61a6839be55790d3ed89035d88bbaa618564736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220be8cdfbccac187759bb1cb8cd811da61a6839be55790d3ed89035d88bbaa618564736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"46914:8843:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;46914:8843:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"46914:8843:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:HeaderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209ea6ba78ce49694fc6a30a2bfb614096f9cbc0f2d9a44104842320c0b1fdc91564736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209ea6ba78ce49694fc6a30a2bfb614096f9cbc0f2d9a44104842320c0b1fdc91564736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"42283:4027:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;42283:4027:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"42283:4027:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the header part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"Header memory layout [000 .. 004): origin             uint32   4 bytes    Domain where message originated [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"Header memory layout [000 .. 004): origin             uint32   4 bytes    Domain where message originated [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the header part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"HeaderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MemViewLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204b160624d68bcf1cab8aeb68960fdeb76a2703ea13ca66bcf285bb751210465664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204b160624d68bcf1cab8aeb68960fdeb76a2703ea13ca66bcf285bb751210465664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"5331:19307:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5331:19307:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5331:19307:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \\\"memory view\\\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \\\"type\\\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MemViewLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b50610d3d806100206000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c61608e81161005b578063c61608e8146100de578063c97c703a146100f1578063d7a7a72c14610104578063f9893ddd1461012557600080fd5b806337dcc27b14610082578063801fdbfc146100ab578063c311d359146100cb575b600080fd5b610095610090366004610aa8565b610148565b6040516100a29190610b0c565b60405180910390f35b6100be6100b9366004610aa8565b610161565b6040516100a29190610b71565b6100be6100d9366004610aa8565b610182565b6100be6100ec366004610bc2565b6101a1565b6100be6100ff366004610aa8565b6101b6565b610117610112366004610aa8565b6101cc565b6040519081526020016100a2565b610138610133366004610aa8565b6101df565b60405190151581526020016100a2565b600061015b610156836101f2565b610205565b92915050565b606061015b61017d61017a610175856101f2565b610225565b90565b610239565b6060600061018f836101f2565b905061019a81610239565b9392505050565b60606101ae848484610296565b949350505050565b606061015b61017d6101c7846101f2565b6102c5565b600061015b6101da836101f2565b6102d1565b600061015b6101ed836102dd565b6102f0565b600061015b610200836102dd565b61038d565b60008161021181610407565b60ff16600181111561019a5761019a610add565b60008161019a61023482610415565b610424565b6040518061024a8360208301610495565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60608383836040516020016102ad93929190610c3c565b60405160208183030381529060405290509392505050565b60008161019a81610544565b60008161019a8161055c565b8051600090602083016101ae8183610587565b60006fffffffffffffffffffffffffffffffff821661031160106001610ce1565b8110156103215750600092915050565b600061032c84610407565b9050600160ff82161115610344575060009392505050565b61035561035085610415565b6105ea565b610363575060009392505050565b60ff811661037c576101ae61037785610544565b610609565b6101ae61038885610544565b61067c565b6000610398826102f0565b610403576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f6164000000000000000000000060448201526064015b60405180910390fd5b5090565b600061015b828260016106e5565b600061015b8260016010610706565b600061042f826105ea565b610403576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f74206120686561646572207061796c6f616400000000000000000000000060448201526064016103fa565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c90808510156104ef576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610532576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061015b61055560106001610ce1565b8390610780565b6000806105698360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b6000806105948385610ce1565b90506040518111156105a4575060005b806000036105de576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b83176101ae565b600060106fffffffffffffffffffffffffffffffff83165b1492915050565b600060026fffffffffffffffffffffffffffffffff8316101561062e57506000919050565b600261063983610407565b60ff16111561064a57506000919050565b6002610655836107e6565b60ff16111561066657506000919050565b6000610671836107f4565b905061019a81610801565b6000600861068c60206040610ce1565b6106969190610ce1565b6fffffffffffffffffffffffffffffffff831610156106b757506000919050565b6106c86106c38361083d565b61084c565b6106d457506000919050565b61015b6106e083610868565b610882565b6000806106f385858561089e565b602084900360031b1c9150509392505050565b6000806107138560801c90565b905061071e856109a8565b836107298684610ce1565b6107339190610ce1565b111561076b576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61077784820184610587565b95945050505050565b60006fffffffffffffffffffffffffffffffff8316808311156107cf576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6101ae836107dd8660801c90565b01848303610587565b600061015b826001806106e5565b600061015b826002610780565b60006fffffffffffffffffffffffffffffffff821660048110156108285750600092915050565b61019a610836600483610cf4565b601f161590565b600061015b8260406020610706565b600060206fffffffffffffffffffffffffffffffff8316610602565b600061015b61087960206040610ce1565b83906008610706565b600060086fffffffffffffffffffffffffffffffff8316610602565b6000816000036108b05750600061019a565b60208211156108eb576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff84166109088385610ce1565b1115610940576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006109518660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b60006fffffffffffffffffffffffffffffffff82166109c78360801c90565b0192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610a0e57600080fd5b813567ffffffffffffffff80821115610a2957610a296109ce565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610a6f57610a6f6109ce565b81604052838152866020858801011115610a8857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215610aba57600080fd5b813567ffffffffffffffff811115610ad157600080fd5b6101ae848285016109fd565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6020810160028310610b47577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b91905290565b60005b83811015610b68578181015183820152602001610b50565b50506000910152565b6020815260008251806020840152610b90816040850160208701610b4d565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600080600060608486031215610bd757600080fd5b833560028110610be657600080fd5b9250602084013567ffffffffffffffff80821115610c0357600080fd5b610c0f878388016109fd565b93506040860135915080821115610c2557600080fd5b50610c32868287016109fd565b9150509250925092565b600060028510610c75577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8460f81b82528351610c8e816001850160208801610b4d565b835190830190610ca5816001840160208801610b4d565b0160010195945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561015b5761015b610cb2565b8181038181111561015b5761015b610cb256fea26469706673582212204a0985c0bb999223e2c45844dbbf601a4de2ede9b8cda2bfe1dd9678a92b937e64736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c61608e81161005b578063c61608e8146100de578063c97c703a146100f1578063d7a7a72c14610104578063f9893ddd1461012557600080fd5b806337dcc27b14610082578063801fdbfc146100ab578063c311d359146100cb575b600080fd5b610095610090366004610aa8565b610148565b6040516100a29190610b0c565b60405180910390f35b6100be6100b9366004610aa8565b610161565b6040516100a29190610b71565b6100be6100d9366004610aa8565b610182565b6100be6100ec366004610bc2565b6101a1565b6100be6100ff366004610aa8565b6101b6565b610117610112366004610aa8565b6101cc565b6040519081526020016100a2565b610138610133366004610aa8565b6101df565b60405190151581526020016100a2565b600061015b610156836101f2565b610205565b92915050565b606061015b61017d61017a610175856101f2565b610225565b90565b610239565b6060600061018f836101f2565b905061019a81610239565b9392505050565b60606101ae848484610296565b949350505050565b606061015b61017d6101c7846101f2565b6102c5565b600061015b6101da836101f2565b6102d1565b600061015b6101ed836102dd565b6102f0565b600061015b610200836102dd565b61038d565b60008161021181610407565b60ff16600181111561019a5761019a610add565b60008161019a61023482610415565b610424565b6040518061024a8360208301610495565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60608383836040516020016102ad93929190610c3c565b60405160208183030381529060405290509392505050565b60008161019a81610544565b60008161019a8161055c565b8051600090602083016101ae8183610587565b60006fffffffffffffffffffffffffffffffff821661031160106001610ce1565b8110156103215750600092915050565b600061032c84610407565b9050600160ff82161115610344575060009392505050565b61035561035085610415565b6105ea565b610363575060009392505050565b60ff811661037c576101ae61037785610544565b610609565b6101ae61038885610544565b61067c565b6000610398826102f0565b610403576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f6164000000000000000000000060448201526064015b60405180910390fd5b5090565b600061015b828260016106e5565b600061015b8260016010610706565b600061042f826105ea565b610403576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f74206120686561646572207061796c6f616400000000000000000000000060448201526064016103fa565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c90808510156104ef576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610532576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061015b61055560106001610ce1565b8390610780565b6000806105698360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b6000806105948385610ce1565b90506040518111156105a4575060005b806000036105de576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b83176101ae565b600060106fffffffffffffffffffffffffffffffff83165b1492915050565b600060026fffffffffffffffffffffffffffffffff8316101561062e57506000919050565b600261063983610407565b60ff16111561064a57506000919050565b6002610655836107e6565b60ff16111561066657506000919050565b6000610671836107f4565b905061019a81610801565b6000600861068c60206040610ce1565b6106969190610ce1565b6fffffffffffffffffffffffffffffffff831610156106b757506000919050565b6106c86106c38361083d565b61084c565b6106d457506000919050565b61015b6106e083610868565b610882565b6000806106f385858561089e565b602084900360031b1c9150509392505050565b6000806107138560801c90565b905061071e856109a8565b836107298684610ce1565b6107339190610ce1565b111561076b576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61077784820184610587565b95945050505050565b60006fffffffffffffffffffffffffffffffff8316808311156107cf576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6101ae836107dd8660801c90565b01848303610587565b600061015b826001806106e5565b600061015b826002610780565b60006fffffffffffffffffffffffffffffffff821660048110156108285750600092915050565b61019a610836600483610cf4565b601f161590565b600061015b8260406020610706565b600060206fffffffffffffffffffffffffffffffff8316610602565b600061015b61087960206040610ce1565b83906008610706565b600060086fffffffffffffffffffffffffffffffff8316610602565b6000816000036108b05750600061019a565b60208211156108eb576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff84166109088385610ce1565b1115610940576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006109518660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b60006fffffffffffffffffffffffffffffffff82166109c78360801c90565b0192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610a0e57600080fd5b813567ffffffffffffffff80821115610a2957610a296109ce565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610a6f57610a6f6109ce565b81604052838152866020858801011115610a8857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215610aba57600080fd5b813567ffffffffffffffff811115610ad157600080fd5b6101ae848285016109fd565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6020810160028310610b47577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b91905290565b60005b83811015610b68578181015183820152602001610b50565b50506000910152565b6020815260008251806020840152610b90816040850160208701610b4d565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600080600060608486031215610bd757600080fd5b833560028110610be657600080fd5b9250602084013567ffffffffffffffff80821115610c0357600080fd5b610c0f878388016109fd565b93506040860135915080821115610c2557600080fd5b50610c32868287016109fd565b9150509250925092565b600060028510610c75577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8460f81b82528351610c8e816001850160208801610b4d565b835190830190610ca5816001840160208801610b4d565b0160010195945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561015b5761015b610cb2565b8181038181111561015b5761015b610cb256fea26469706673582212204a0985c0bb999223e2c45844dbbf601a4de2ede9b8cda2bfe1dd9678a92b937e64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"72579:2159:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"72579:2159:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;73524:124;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;73654:146;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;73172:346::-;;;;;;:::i;:::-;;:::i;74518:218::-;;;;;;:::i;:::-;;:::i;73806:133::-;;;;;;:::i;:::-;;:::i;73945:120::-;;;;;;:::i;:::-;;:::i;:::-;;;3468:25:1;;;3456:2;3441:18;73945:120:0;3322:177:1;74071:117:0;;;;;;:::i;:::-;;:::i;:::-;;;3669:14:1;;3662:22;3644:41;;3632:2;3617:18;74071:117:0;3504:187:1;73524:124:0;73581:11;73611:30;:23;:7;:21;:23::i;:::-;:28;:30::i;:::-;73604:37;73524:124;-1:-1:-1;;73524:124:0:o;73654:146::-;73713:12;73744:49;:41;:32;:23;:7;:21;:23::i;:::-;:30;:32::i;:::-;45039:6;44932:122;73744:41;:47;:49::i;73172:346::-;73238:12;73419:15;73437:33;73462:7;73437:24;:33::i;:::-;73419:51;-1:-1:-1;73487:24:0;73419:51;73744:47;:49::i;73487:24::-;73480:31;73172:346;-1:-1:-1;;;73172:346:0:o;74518:218::-;74647:12;74682:47;74707:5;74714:7;74723:5;74682:24;:47::i;:::-;74675:54;74518:218;-1:-1:-1;;;;74518:218:0:o;73806:133::-;73863:12;73894:38;:30;:23;:7;:21;:23::i;:::-;:28;:30::i;73945:120::-;74002:7;74028:30;:23;:7;:21;:23::i;:::-;:28;:30::i;74071:117::-;74133:4;74156:25;:13;:7;:11;:13::i;:::-;:23;:25::i;68256:129::-;68324:7;68350:28;68364:13;:7;:11;:13::i;:::-;68350;:28::i;70478:279::-;70532:11;70573:7;70735:14;70573:7;70735:5;:14::i;:::-;70723:27;;;;;;;;;;:::i;70828:290::-;70884:6;70920:7;71080:31;:16;70920:7;71080;:16::i;:::-;:29;:31::i;8322:1041::-;8568:4;8562:11;;8698:34;8712:7;8727:4;8721:10;;8698:13;:34::i;:::-;-1:-1:-1;11508:17:0;11482:43;;8944:12;12340:2;12324:18;;12708:20;;9240;;9262:4;9236:31;9230:4;9223:45;-1:-1:-1;9330:17:0;;8322:1041;;-1:-1:-1;8322:1041:0:o;67891:212::-;68022:12;68074:5;68081:7;68090:5;68057:39;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;68050:46;;67891:212;;;;;:::o;71196:145::-;71250:7;71287;71320:14;71287:7;71320:5;:14::i;69971:147::-;70025:7;70062;70095:16;70062:7;70095:14;:16::i;7215:569::-;7303:10;;7269:7;;7729:4;7720:14;;7760:17;7720:14;7303:10;7760:5;:17::i;68813:878::-;68872:4;11508:17;11482:43;;67198:29;1848:2;67152:1;67198:29;:::i;:::-;68989:6;:20;68985:38;;;-1:-1:-1;69018:5:0;;68813:878;-1:-1:-1;;68813:878:0:o;68985:38::-;69033:11;69047:14;69053:7;69047:5;:14::i;:::-;69033:28;-1:-1:-1;69143:21:0;69129:36;;;;69125:54;;;-1:-1:-1;69174:5:0;;68813:878;-1:-1:-1;;;68813:878:0:o;69125:54::-;69236:27;:16;69244:7;69236;:16::i;:::-;:25;:27::i;:::-;69231:46;;-1:-1:-1;69272:5:0;;68813:878;-1:-1:-1;;;68813:878:0:o;69231:46::-;69401:34;;;69397:288;;69517:32;:14;69523:7;69517:5;:14::i;:::-;:30;:32::i;69397:288::-;69644:30;:14;69650:7;69644:5;:14::i;:::-;:28;:30::i;68535:195::-;68598:7;68625:18;68635:7;68625:9;:18::i;:::-;68617:52;;;;;;;5019:2:1;68617:52:0;;;5001:21:1;5058:2;5038:18;;;5031:30;5097:23;5077:18;;;5070:51;5138:18;;68617:52:0;;;;;;;;;-1:-1:-1;68714:7:0;68535:195::o;71750:143::-;71804:5;71834:51;:7;71804:5;71882:1;71834:17;:51::i;72049:148::-;72105:7;72131:59;:7;67152:1;1848:2;72131:13;:59::i;44476:190::-;44538:6;44564:17;44573:7;44564:8;:17::i;:::-;44556:50;;;;;;;5369:2:1;44556:50:0;;;5351:21:1;5408:2;5388:18;;;5381:30;5447:22;5427:18;;;5420:50;5487:18;;44556:50:0;5167:344:1;22256:842:0;22595:4;22589:11;22334:7;;11508:17;11482:43;;;11141:3;11114:30;;;;22677:12;;;22673:66;;;22712:16;;;;;;;;;;;;;;22673:66;22748:8;22964:4;22956:6;22950:4;22942:6;22936:4;22929:5;22918:51;22911:58;;22993:3;22988:37;;23005:20;;;;;;;;;;;;;;22988:37;21605:3;21597:11;;;21596:20;;23035:56;22256:842;-1:-1:-1;;;;;;;22256:842:0:o;72349:127::-;72403:7;72429:40;67198:29;1848:2;67152:1;67198:29;:::i;:::-;72429:7;;:17;:40::i;13246:292::-;13302:14;13328:12;13343:13;:7;11141:3;11114:30;;10955:196;13343:13;11508:17;11482:43;;;;13501:21;;;;;-1:-1:-1;;13246:292:0:o;6335:540::-;6401:7;;6435:11;6442:4;6435;:11;:::i;:::-;6420:26;;6714:4;6708:11;6702:4;6699:21;6696:38;;;-1:-1:-1;6731:1:0;6696:38;6757:4;6765:1;6757:9;6753:66;;6789:19;;;;;;;;;;;;;;6753:66;21605:3;21597:11;;;21596:20;;6835:33;21272:352;44748:118;44806:4;1848:2;11508:17;11482:43;;44829:13;:30;;44748:118;-1:-1:-1;;44748:118:0:o;62440:620::-;62505:4;60772:1;11508:17;11482:43;;62587:31;62583:49;;;-1:-1:-1;62627:5:0;;62440:620;-1:-1:-1;62440:620:0:o;62583:49::-;62726:22;62701:16;62709:7;62701;:16::i;:::-;:48;;;62697:66;;;-1:-1:-1;62758:5:0;;62440:620;-1:-1:-1;62440:620:0:o;62697:66::-;62863:22;62835:19;62846:7;62835:10;:19::i;:::-;:51;;;62831:69;;;-1:-1:-1;62895:5:0;;62440:620;-1:-1:-1;62440:620:0:o;62831:69::-;62910:20;62933:18;62943:7;62933:9;:18::i;:::-;62910:41;;63028:25;:12;:23;:25::i;38035:439::-;38098:4;1924:1;36137:25;2020:2;36087;36137:25;:::i;:::-;36210:31;;;;:::i;:::-;11508:17;11482:43;;38175:30;38171:48;;;-1:-1:-1;38214:5:0;;38035:439;-1:-1:-1;38035:439:0:o;38171:48::-;38280:23;:14;38286:7;38280:5;:14::i;:::-;:21;:23::i;:::-;38275:42;;-1:-1:-1;38312:5:0;;38035:439;-1:-1:-1;38035:439:0:o;38275:42::-;38380:29;:17;38389:7;38380:8;:17::i;:::-;:27;:29::i;19795:538::-;19886:7;;19928:29;:7;19942:6;19950;19928:13;:29::i;:::-;20298:2;:11;;;20314:1;20297:18;20271:45;;-1:-1:-1;;19795:538:0;;;;;:::o;14574:484::-;14659:7;14678:12;14693:13;:7;11141:3;11114:30;;10955:196;14693:13;14678:28;;14789:13;:7;:11;:13::i;:::-;14782:4;14766:13;14773:6;14766:4;:13;:::i;:::-;:20;;;;:::i;:::-;:36;14762:87;;;14825:13;;;;;;;;;;;;;;14762:87;15001:40;15021:6;15014:4;:13;15035:4;15001:5;:40::i;:::-;14994:47;14574:484;-1:-1:-1;;;;;14574:484:0:o;15369:529::-;15444:7;11508:17;11482:43;;15551:13;;;15547:64;;;15587:13;;;;;;;;;;;;;;15547:64;15823:58;15852:6;15836:13;:7;11141:3;11114:30;;10955:196;15836:13;:22;15873:6;15866:4;:13;15823:5;:58::i;65392:153::-;65451:5;65481:56;:7;60722:1;;65481:17;:56::i;65705:135::-;65763:7;65789:44;:7;60772:1;65789:17;:44::i;53051:362::-;53111:4;11508:17;11482:43;;47714:1;53232:24;;53228:42;;;-1:-1:-1;53265:5:0;;53051:362;-1:-1:-1;;53051:362:0:o;53228:42::-;53370:36;53381:24;47714:1;53381:6;:24;:::i;:::-;55741:2;55732:11;:16;;55604:151;41174:142;41228:7;41254:55;:7;36087:2;2020;41254:13;:55::i;31964:114::-;32020:4;2020:2;11508:17;11482:43;;32043:13;11324:208;41474:151;41531:7;41557:61;36137:25;2020:2;36087;36137:25;:::i;:::-;41557:7;;1924:1;41557:13;:61::i;26551:120::-;26610:4;1924:1;11508:17;11482:43;;26633:13;11324:208;18103:1334;18190:14;18220:6;18230:1;18220:11;18216:59;;-1:-1:-1;18262:1:0;18247:17;;18216:59;18361:2;18352:6;:11;18348:65;;;18386:16;;;;;;;;;;;;;;18348:65;11508:17;11482:43;;18492:15;18501:6;18492;:15;:::i;:::-;:31;18488:82;;;18546:13;;;;;;;;;;;;;;18488:82;18609:1;18599:11;;;18579:17;18649:13;:7;11141:3;11114:30;;10955:196;18649:13;19396:17;;;19390:24;19107:66;19088:17;;;;;19084:90;;;;19386:35;;18103:1334;-1:-1:-1;;;;18103:1334:0:o;11702:258::-;11755:12;11508:17;11482:43;;11914:13;:7;11141:3;11114:30;;10955:196;11914:13;:29;;11702:258;-1:-1:-1;;11702:258:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1310:184::-;1362:77;1359:1;1352:88;1459:4;1456:1;1449:15;1483:4;1480:1;1473:15;1499:401;1647:2;1632:18;;1680:1;1669:13;;1659:201;;1716:77;1713:1;1706:88;1817:4;1814:1;1807:15;1845:4;1842:1;1835:15;1659:201;1869:25;;;1499:401;:::o;1905:250::-;1990:1;2000:113;2014:6;2011:1;2008:13;2000:113;;;2090:11;;;2084:18;2071:11;;;2064:39;2036:2;2029:10;2000:113;;;-1:-1:-1;;2147:1:1;2129:16;;2122:27;1905:250::o;2160:453::-;2307:2;2296:9;2289:21;2270:4;2339:6;2333:13;2382:6;2377:2;2366:9;2362:18;2355:34;2398:79;2470:6;2465:2;2454:9;2450:18;2445:2;2437:6;2433:15;2398:79;:::i;:::-;2529:2;2517:15;2534:66;2513:88;2498:104;;;;2604:2;2494:113;;2160:453;-1:-1:-1;;2160:453:1:o;2618:699::-;2729:6;2737;2745;2798:2;2786:9;2777:7;2773:23;2769:32;2766:52;;;2814:1;2811;2804:12;2766:52;2853:9;2840:23;2892:1;2885:5;2882:12;2872:40;;2908:1;2905;2898:12;2872:40;2931:5;-1:-1:-1;2987:2:1;2972:18;;2959:32;3010:18;3040:14;;;3037:34;;;3067:1;3064;3057:12;3037:34;3090:49;3131:7;3122:6;3111:9;3107:22;3090:49;:::i;:::-;3080:59;;3192:2;3181:9;3177:18;3164:32;3148:48;;3221:2;3211:8;3208:16;3205:36;;;3237:1;3234;3227:12;3205:36;;3260:51;3303:7;3292:8;3281:9;3277:24;3260:51;:::i;:::-;3250:61;;;2618:699;;;;;:::o;3696:797::-;3913:3;3952:1;3944:6;3941:13;3931:201;;3988:77;3985:1;3978:88;4089:4;4086:1;4079:15;4117:4;4114:1;4107:15;3931:201;4162:6;4157:3;4153:16;4148:3;4141:29;4199:6;4193:13;4215:74;4282:6;4278:1;4273:3;4269:11;4262:4;4254:6;4250:17;4215:74;:::i;:::-;4349:13;;4308:16;;;;4371:75;4349:13;4433:1;4425:10;;4418:4;4406:17;;4371:75;:::i;:::-;4466:17;4485:1;4462:25;;3696:797;-1:-1:-1;;;;;3696:797:1:o;4498:184::-;4550:77;4547:1;4540:88;4647:4;4644:1;4637:15;4671:4;4668:1;4661:15;4687:125;4752:9;;;4773:10;;;4770:36;;;4786:18;;:::i;5516:128::-;5583:9;;;5604:11;;;5601:37;;;5618:18;;:::i","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"flag","outputs":[{"internalType":"enum MessageFlag","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"enum MessageFlag","name":"flag_","type":"uint8"},{"internalType":"bytes","name":"header_","type":"bytes"},{"internalType":"bytes","name":"body_","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"header","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isMessage","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Message methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"flag_\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"header_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"body_\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"header\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Message methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","castToMessage(bytes)":"c311d359","flag(bytes)":"37dcc27b","formatMessage(uint8,bytes,bytes)":"c61608e8","header(bytes)":"801fdbfc","isMessage(bytes)":"f9893ddd","leaf(bytes)":"d7a7a72c"}},"solidity/MessageHarness.t.sol:MessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122049c87d54b9167bd62b958a9c027866abd956a10d04ba4a488f9c9a925be13c0764736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122049c87d54b9167bd62b958a9c027866abd956a10d04ba4a488f9c9a925be13c0764736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"66451:6027:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;66451:6027:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"66451:6027:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting the various messages supported by Origin and Destination.","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_FLAG":{"details":"Message memory layout [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_FLAG\":{\"details\":\"Message memory layout [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting the various messages supported by Origin and Destination.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203f330ddf46bc3f2474eef2649ca28f54777c88c1b3e6b5ca86fa575d681d713e64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212203f330ddf46bc3f2474eef2649ca28f54777c88c1b3e6b5ca86fa575d681d713e64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"24837:2545:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;24837:2545:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"24837:2545:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_GAS_LIMIT":{"details":"Request structure represents a message sender requirements for the message execution on the destination chain.Memory layout of Request fields TODO: figure out the fields packing (uint64 is too much for gas limit) [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_GAS_LIMIT\":{\"details\":\"Request structure represents a message sender requirements for the message execution on the destination chain.Memory layout of Request fields TODO: figure out the fields packing (uint64 is too much for gas limit) [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:SystemMessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d365ad98ec3443067cd28cf504006fafee3b65e131185c71ab312ba58b56e6e864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d365ad98ec3443067cd28cf504006fafee3b65e131185c71ab312ba58b56e6e864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"59941:5901:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;59941:5901:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"59941:5901:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SENDER":{"details":"SystemMessage memory layout Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain. [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SENDER\":{\"details\":\"SystemMessage memory layout Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain. [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"SystemMessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205b797949d72abe7503939896d033bca9ba419bab236de0b7d814a70ce536319c64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205b797949d72abe7503939896d033bca9ba419bab236de0b7d814a70ce536319c64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"27672:7309:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;27672:7309:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"27672:7309:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SUMMIT_TIP":{"details":"Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible.  1. Summit tips. Split between:      a. Guard posting a snapshot with state ST_G for the origin chain.      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.      c. Notary posting a message receipt after it is executed on destination chain.  2. Attestation tips. Paid to:      a. Notary posting attestation A to destination chain.  3. Execution tips. Paid to:      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.  4. Delivery tips. Paid to:      a. Executor who successfully executed the message on destination chain.The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency.Tips memory layout [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SUMMIT_TIP\":{\"details\":\"Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible.  1. Summit tips. Split between:      a. Guard posting a snapshot with state ST_G for the origin chain.      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.      c. Notary posting a message receipt after it is executed on destination chain.  2. Attestation tips. Paid to:      a. Notary posting attestation A to destination chain.  3. Execution tips. Paid to:      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.  4. Delivery tips. Paid to:      a. Executor who successfully executed the message on destination chain.The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. The only downside is that the \\\"real tip values\\\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency.Tips memory layout [000 .. 008): summitTip          uint64\\t 8 bytes    Tip for agents interacting with Summit contract [008 .. 016): attestationTip     uint64\\t 8 bytes    Tip for Notary posting attestation to Destination contract [016 .. 024): executionTip       uint64\\t 8 bytes    Tip for valid execution attempt on destination chain [024 .. 032): deliveryTip        uint64\\t 8 bytes    Tip for successful message delivery on destination chain The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d205fb7681b97ced79a19c97583406fbe0f795898d1203a6575121f96a3fdc0b64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d205fb7681b97ced79a19c97583406fbe0f795898d1203a6575121f96a3fdc0b64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Request is a memory view over a formatted \"message execution request\" payload.\ntype Request is uint256;\n\n/// @dev Attach library functions to Request\nusing RequestLib for Request global;\n\nlibrary RequestLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Request structure represents a message sender requirements for\n     * the message execution on the destination chain.\n     *\n     * @dev Memory layout of Request fields\n     * TODO: figure out the fields packing (uint64 is too much for gas limit)\n     * [000 .. 008): gasLimit       uint64   8 bytes    Amount of gas units to supply on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_GAS_LIMIT = 0;\n\n    // ══════════════════════════════════════════════════ REQUEST ══════════════════════════════════════════════════════\n\n    function formatRequest(uint64 gasLimit_) internal pure returns (bytes memory) {\n        return abi.encodePacked(gasLimit_);\n    }\n\n    /**\n     * @notice Returns a Request view over the given payload.\n     * @dev Will revert if the payload is not a request.\n     */\n    function castToRequest(bytes memory payload) internal pure returns (Request) {\n        return castToRequest(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Request view.\n     * @dev Will revert if the memory view is not over a request.\n     */\n    function castToRequest(MemView memView) internal pure returns (Request) {\n        require(isRequest(memView), \"Not a request\");\n        return Request.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Request.\n    function isRequest(MemView memView) internal pure returns (bool) {\n        return memView.len() == REQUEST_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Request request) internal pure returns (MemView) {\n        return MemView.wrap(Request.unwrap(request));\n    }\n\n    // ══════════════════════════════════════════════ REQUEST SLICING ══════════════════════════════════════════════════\n\n    function gasLimit(Request request) internal pure returns (uint64) {\n        MemView memView = unwrap(request);\n        return uint64(memView.indexUint({index_: OFFSET_GAS_LIMIT, bytes_: 8}));\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/// @dev BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\n/// @dev Attach library functions to BaseMessage\nusing BaseMessageLib for BaseMessage global;\n\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n    using RequestLib for MemView;\n    using TipsLib for MemView;\n\n    /**\n     * @dev Memory layout of BaseMessage fields\n     * [000 .. 032): sender         bytes32 32 bytes    Sender address on origin chain\n     * [032 .. 064): recipient      bytes32 32 bytes    Recipient address on destination chain\n     * [064 .. 112): tips           bytes   48 bytes    Tips paid on origin chain\n     * [112 .. 120): request        bytes    8 bytes    Request for message execution on destination chain\n     * [120 .. AAA): content        bytes   ?? bytes    Content to be passed to recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tipsPayload   Formatted payload with tips information\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(\n        bytes32 sender_,\n        bytes32 recipient_,\n        bytes memory tipsPayload,\n        bytes memory requestPayload,\n        bytes memory content_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(sender_, recipient_, tipsPayload, requestPayload, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        if (memView.len() \u003c OFFSET_CONTENT) return false;\n        // Check if tips payload is formatted\n        if (!_tips(memView).isTips()) return false;\n        // Check if tips payload is formatted\n        return _request(memView).isRequest();\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // Get the underlying memory view\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        MemView memView = baseMessage.unwrap();\n        return memView.index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns a typed memory view over the payload with tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        MemView memView = baseMessage.unwrap();\n        // We check that tips payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _tips(memView).castToTips();\n    }\n\n    /// @notice Returns a typed memory view over the payload with request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        MemView memView = baseMessage.unwrap();\n        // We check that request payload is properly formatted, when the whole payload is wrapped\n        // into BaseMessage, so this never reverts.\n        return _request(memView).castToRequest();\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        MemView memView = baseMessage.unwrap();\n        return memView.sliceFrom({index_: OFFSET_CONTENT});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns an untyped memory view over the tips field without checking\n    /// if the whole payload or the tips are properly formatted.\n    function _tips(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_TIPS, len_: TIPS_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the request field without checking\n    /// if the whole payload or the request are properly formatted.\n    function _request(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_REQUEST, len_: REQUEST_LENGTH});\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n/// @dev Header is a memory over over a formatted message header payload.\ntype Header is uint256;\n\n/// @dev Attach library functions to Header\nusing HeaderLib for Header global;\n\n/**\n * @notice Library for versioned formatting [the header part]\n * of [the messages used by Origin and Destination].\n */\nlibrary HeaderLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 004): origin             uint32   4 bytes    Domain where message originated\n     * [004 .. 008): nonce              uint32   4 bytes    Message nonce on the origin domain\n     * [008 .. 012): destination        uint32   4 bytes    Domain where message will be executed\n     * [012 .. 016): optimisticPeriod   uint32   4 bytes    Optimistic period that will be enforced\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_NONCE = 4;\n    uint256 private constant OFFSET_DESTINATION = 8;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 12;\n\n    // ══════════════════════════════════════════════════ HEADER ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param origin_               Domain of origin chain\n     * @param nonce_                Message nonce on origin chain\n     * @param destination_          Domain of destination chain\n     * @param optimisticPeriod_     Optimistic period for message execution\n     * @return Formatted header\n     */\n    function formatHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(origin_, nonce_, destination_, optimisticPeriod_);\n    }\n\n    /**\n     * @notice Returns a Header view over for the given payload.\n     * @dev Will revert if the payload is not a header payload.\n     */\n    function castToHeader(bytes memory payload) internal pure returns (Header) {\n        return castToHeader(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Header view.\n     * @dev Will revert if the memory view is not over a header payload.\n     */\n    function castToHeader(MemView memView) internal pure returns (Header) {\n        require(isHeader(memView), \"Not a header payload\");\n        return Header.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(MemView memView) internal pure returns (bool) {\n        return memView.len() == HEADER_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Header header) internal pure returns (MemView) {\n        return MemView.wrap(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        MemView memView = unwrap(header);\n        return uint32(memView.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common enums and structures to enable their easier reusing later.\n\n// ══════════════════════════════ SYSTEM CONTRACT ══════════════════════════════\n\n/// @dev Potential senders/recipients of a system message\nenum SystemEntity {\n    Origin,\n    Destination,\n    AgentManager\n}\n\n// ═══════════════════════════════ AGENT STATUS ════════════════════════════════\n\n/// @dev Potential statuses for the off-chain bonded agent:\n/// - Unknown: never provided a bond =\u003e signature not valid\n/// - Active: has a bond in BondingManager =\u003e signature valid\n/// - Unstaking: has a bond in BondingManager, initiated the unstaking =\u003e signature not valid\n/// - Resting: used to have a bond in BondingManager, successfully unstaked =\u003e signature not valid\n/// - Fraudulent: proven to commit fraud, value in Merkle Tree not updated =\u003e signature not valid\n/// - Slashed: proven to commit fraud, value in Merkle Tree was updated =\u003e signature not valid\n/// Unstaked agent could later be added back to THE SAME domain by staking a bond again.\n/// Honest agent: Unknown -\u003e Active -\u003e unstaking -\u003e Resting -\u003e Active ...\n/// Malicious agent: Unknown -\u003e Active -\u003e Fraudulent -\u003e Slashed\n/// Malicious agent: Unknown -\u003e Active -\u003e Unstaking -\u003e Fraudulent -\u003e Slashed\nenum AgentFlag {\n    Unknown,\n    Active,\n    Unstaking,\n    Resting,\n    Fraudulent,\n    Slashed\n}\n\n/// @notice Struct for storing an agent in the BondingManager contract.\nstruct AgentStatus {\n    AgentFlag flag;\n    uint32 domain;\n    uint32 index;\n}\n// 184 bits available for tight packing\n\n/// @notice Potential statuses of an agent in terms of being in dispute\n/// - None: agent is not in dispute\n/// - Pending: agent is in unresolved dispute\n/// - Slashed: agent was in dispute that lead to agent being slashed\n/// Note: agent who won the dispute has their status reset to None\nenum DisputeFlag {\n    None,\n    Pending,\n    Slashed\n}\n\n/// @notice Struct representing information about an agent in dispute.\n/// Note: counterpart for Guard is Notary, counterpart for Notary is Guard.\n/// @param flag         Dispute status\n/// @param counterpart  Agent address who the agent is in dispute with\nstruct DisputeStatus {\n    DisputeFlag flag;\n    address counterpart;\n}\n// 88 bits available for tight packing\n\n/// @notice Struct representing information about a slashed agent.\nstruct SlashStatus {\n    bool isSlashed;\n    address prover;\n}\n// 88 bits available for tight packing\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\n/// @notice Struct representing the status of Destination contract.\n/// @param snapRootTime     Timestamp when latest snapshot root was accepted\n/// @param agentRootTime    Timestamp when latest agent root was accepted\n/// @param notary           Notary who signed the latest agent root\n// TODO: replace notary with its index\nstruct DestinationStatus {\n    uint48 snapRootTime;\n    uint48 agentRootTime;\n    address notary;\n}\n\n// ═══════════════════════════════ EXECUTION HUB ═══════════════════════════════\n\n/// @notice Potential statuses of the message in Execution Hub.\n/// - None: there hasn't been a valid attempt to execute the message yet\n/// - Failed: there was a valid attempt to execute the message, but recipient reverted\n/// - Success: there was a valid attempt to execute the message, and recipient did not revert\n/// Note: message can be executed until its status is Success\nenum MessageStatus {\n    None,\n    Failed,\n    Success\n}\n\n/// @dev SystemMessage is a memory view over the message with instructions for a system call.\ntype SystemMessage is uint256;\n\n/// @dev Attach library functions to SystemMessage\nusing SystemMessageLib for SystemMessage global;\n\nlibrary SystemMessageLib {\n    using MemViewLib for bytes;\n    using ByteString for MemView;\n\n    /**\n     * @dev SystemMessage memory layout\n     * Note: calldata does not include the security arguments, these are added by SystemRouter on destination chain.\n     * [000 .. 001): sender         uint8   1 byte      SystemEntity that sent the message on origin chain\n     * [001 .. 002): recipient      uint8   1 byte      SystemEntity to receive the message on destination chain\n     * [002 .. END]: calldata       bytes   ? bytes     Raw bytes of payload to call system recipient\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 1;\n    uint256 private constant OFFSET_CALLDATA = 2;\n\n    // ══════════════════════════════════════════════ SYSTEM MESSAGE ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted SystemMessage payload with provided fields.\n     * @param sender_           System Contract that sent receive message\n     * @param recipient_        System Contract to receive message\n     * @param callData_         Raw bytes with calldata payload\n     * @return Formatted SystemMessage payload.\n     */\n    function formatSystemMessage(SystemEntity sender_, SystemEntity recipient_, bytes memory callData_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, callData_);\n    }\n\n    /**\n     * @notice Returns a SystemMessage view over for the given payload.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(bytes memory payload) internal pure returns (SystemMessage) {\n        return castToSystemMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a SystemMessage view.\n     * @dev Will revert if the payload is not a system message.\n     */\n    function castToSystemMessage(MemView memView) internal pure returns (SystemMessage) {\n        require(isSystemMessage(memView), \"Not a system message\");\n        return SystemMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted System Message.\n     */\n    function isSystemMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender and recipient exist in the payload\n        if (memView.len() \u003c OFFSET_CALLDATA) return false;\n        // Check if sender fits into SystemEntity enum\n        if (_sender(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        // Check if recipient fits into SystemEntity enum\n        if (_recipient(memView) \u003e uint8(type(SystemEntity).max)) return false;\n        MemView callDataView = _callData(memView);\n        // Check that \"calldata\" field is a proper calldata\n        return callDataView.isCallData();\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(SystemMessage systemMessage) internal pure returns (MemView) {\n        return MemView.wrap(SystemMessage.unwrap(systemMessage));\n    }\n\n    // ══════════════════════════════════════════ SYSTEM MESSAGE SLICING ═══════════════════════════════════════════════\n\n    /// @notice Returns system message's recipient.\n    function sender(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that sender fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_sender(memView));\n    }\n\n    /// @notice Returns system message's recipient.\n    function recipient(SystemMessage systemMessage) internal pure returns (SystemEntity) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        // We check that recipient fits into enum, when payload is wrapped\n        // into SystemMessage, so this never reverts\n        return SystemEntity(_recipient(memView));\n    }\n\n    /// @notice Returns typed memory view over the calldata used in the system message.\n    function callData(SystemMessage systemMessage) internal pure returns (CallData) {\n        // Get the underlying memory view\n        MemView memView = systemMessage.unwrap();\n        return _callData(memView).castToCallData();\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's sender without checking that it fits into SystemEntity enum.\n    function _sender(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_SENDER, bytes_: 1}));\n    }\n\n    /// @dev Returns message's recipient without checking that it fits into SystemEntity enum.\n    function _recipient(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_RECIPIENT, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the calldata field without checking\n    /// if the whole payload or the calldata are properly formatted.\n    function _callData(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_CALLDATA});\n    }\n}\n\n/// @dev Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\n/// @dev Attach library functions to Message\nusing MessageLib for Message global;\n\n/// @dev Types of messages supported by Origin-Destination\n/// - System: message sent between system contracts located on different chains\n/// - Base: message sent by protocol user, contains tips\nenum MessageFlag {\n    System,\n    Base\n}\n\n/// @dev Attach library functions to MessageFlag\nusing MessageLib for MessageFlag global;\n\n/**\n * @notice Library for formatting the various messages supported by Origin and Destination.\n */\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n    using SystemMessageLib for MemView;\n\n    /**\n     * @dev Message memory layout\n     * [000 .. 001): flag       uint8    1 byte     Flag specifying the type of message\n     * [001 .. 017): header     bytes   16 bytes    Formatted payload with general routing information\n     * [017 .. AAA): body       bytes   ?? bytes    Formatted payload (according to flag) with message body\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Formatted payload with general routing information\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that Header is formatted\n        if (!_header(memView).isHeader()) return false;\n        // Check that body is formatted according to the flag\n        // Only System/Base message flags exist\n        if (flag_ == uint8(MessageFlag.System)) {\n            // Check if body is a formatted system message\n            return _body(memView).isSystemMessage();\n        } else {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's header field as a Header view.\n    function header(Message message) internal pure returns (Header) {\n        MemView memView = message.unwrap();\n        // We check that header is properly formatted, when payload is wrapped\n        // into Message, so this never reverts.\n        return _header(memView).castToHeader();\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the header field without checking\n    /// if the whole payload or the header are properly formatted.\n    function _header(MemView memView) private pure returns (MemView) {\n        return memView.slice({index_: OFFSET_HEADER, len_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().header().unwrap().clone();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, bytes memory header_, bytes memory body_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"41629:350:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;41629:350:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"41629:350:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0xa3319e79598e36c4eecc17fbcae0622d06863ac107471c34807708219135468c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b3cfc85970aaef7f8381ca645446de553b45b7a78b5f0eb69c8563f363ada66e\",\"dweb:/ipfs/QmbxCVnBKnfQbHFEw9DgnCHXkzSeW4pknvWxG2FNz2PzbD\"]}},\"version\":1}"},"hashes":{}}}