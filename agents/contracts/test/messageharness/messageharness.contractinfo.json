{"solidity/MessageHarness.t.sol:BaseMessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122023e4eb2f59309e530fb5dfd15e889f513c458fe60e5766fc5d6ba3cb994d716d64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122023e4eb2f59309e530fb5dfd15e889f513c458fe60e5766fc5d6ba3cb994d716d64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35882:4252:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35882:4252:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35882:4252:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"BaseMessage structure represents a base message sent via the Origin-Destination contracts. - It only contains data relevant to the base message, the rest of data is encoded in the message header. - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment. - `tips` and `request` parameters are specified by a message sender \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips lower than that. # Memory layout of BaseMessage fields | Position   | Field     | Type    | Bytes | Description                            | | ---------- | --------- | ------- | ----- | -------------------------------------- | | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         | | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain | | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      | | [096..116) | request   | uint160 | 20    | Encoded request for message execution  | | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SENDER":{"details":"The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SENDER\":{\"details\":\"The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"BaseMessage structure represents a base message sent via the Origin-Destination contracts. - It only contains data relevant to the base message, the rest of data is encoded in the message header. - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment. - `tips` and `request` parameters are specified by a message sender \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips lower than that. # Memory layout of BaseMessage fields | Position   | Field     | Type    | Bytes | Description                            | | ---------- | --------- | ------- | ----- | -------------------------------------- | | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         | | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain | | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      | | [096..116) | request   | uint160 | 20    | Encoded request for message execution  | | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"BaseMessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a6aac359e36a4b81ea72034e8de104c143d3b60adda6b1f01c23dbe7c9b514d064736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a6aac359e36a4b81ea72034e8de104c143d3b60adda6b1f01c23dbe7c9b514d064736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"40738:8876:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;40738:8876:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"40738:8876:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:HeaderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206281dad83140103ed61391b71886d9249ffcda95b3a98000084fe8d811e495aa64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206281dad83140103ed61391b71886d9249ffcda95b3a98000084fe8d811e495aa64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"50683:3062:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;50683:3062:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"50683:3062:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the header part_ of _the messages used by Origin and Destination_. - Header represents general information for routing a Message for Origin and Destination. - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory. # Header stack layout (from highest bits to lowest) | Position   | Field            | Type   | Bytes | Description                             | | ---------- | ---------------- | ------ | ----- | --------------------------------------- | | (016..012] | origin           | uint32 | 4     | Domain where message originated         | | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      | | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   | | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_DESTINATION":{"details":"Amount of bits to shift to destination field"},"SHIFT_NONCE":{"details":"Amount of bits to shift to nonce field"},"SHIFT_ORIGIN":{"details":"Amount of bits to shift to origin field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_DESTINATION\":{\"details\":\"Amount of bits to shift to destination field\"},\"SHIFT_NONCE\":{\"details\":\"Amount of bits to shift to nonce field\"},\"SHIFT_ORIGIN\":{\"details\":\"Amount of bits to shift to origin field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the header part_ of _the messages used by Origin and Destination_. - Header represents general information for routing a Message for Origin and Destination. - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory. # Header stack layout (from highest bits to lowest) | Position   | Field            | Type   | Bytes | Description                             | | ---------- | ---------------- | ------ | ----- | --------------------------------------- | | (016..012] | origin           | uint32 | 4     | Domain where message originated         | | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      | | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   | | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"HeaderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MemViewLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208226ccbdae61ea289cbcff0e24d64f17edb74d97f89703f366220d73b7ed307f64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208226ccbdae61ea289cbcff0e24d64f17edb74d97f89703f366220d73b7ed307f64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"15203:19307:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;15203:19307:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"15203:19307:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \\\"memory view\\\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \\\"type\\\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MemViewLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b50610aea806100206000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c311d3591161005b578063c311d359146100ff578063c97c703a14610112578063d7a7a72c14610125578063f9893ddd1461014657600080fd5b806337dcc27b14610082578063801fdbfc146100ab578063b71ae0de146100df575b600080fd5b61009561009036600461083e565b610169565b6040516100a291906108a2565b60405180910390f35b6100be6100b936600461083e565b610182565b6040516fffffffffffffffffffffffffffffffff90911681526020016100a2565b6100f26100ed3660046108e3565b610195565b6040516100a29190610982565b6100f261010d36600461083e565b6101ac565b6100f261012036600461083e565b6101c9565b61013861013336600461083e565b6101df565b6040519081526020016100a2565b61015961015436600461083e565b6101f2565b60405190151581526020016100a2565b600061017c61017783610205565b610218565b92915050565b600061017c61019083610205565b610238565b60606101a284848461024d565b90505b9392505050565b606060006101b983610205565b90506101a58161027c565b61027c565b606061017c6101c46101da84610205565b6102d9565b600061017c6101ed83610205565b6102e5565b600061017c610200836102f1565b61030c565b600061017c610213836102f1565b61038a565b60008161022481610403565b60ff1660018111156101a5576101a5610873565b600061017c61024a836001601061040d565b90565b6060838383604051602001610264939291906109d3565b60405160208183030381529060405290509392505050565b6040518061028d836020830161042e565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b6000816101a5816104dd565b6000816101a5816104f5565b8051600090602083016103048183610520565b949350505050565b60006fffffffffffffffffffffffffffffffff821661032d60106001610a8e565b81101561033d5750600092915050565b600061034884610403565b9050600160ff82161115610360575060009392505050565b60ff811661037957610304610374856104dd565b610583565b610304610385856104dd565b6105b8565b60006103958261030c565b6103ff576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f61640000000000000000000000604482015260640160405180910390fd5b5090565b600061017c828260015b60008061041b8585856105f4565b602084900360031b1c9150509392505050565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610488576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa9050806104cb576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061017c6104ee60106001610a8e565b83906106fe565b6000806105028360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b60008061052d8385610a8e565b905060405181111561053d575060005b80600003610577576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b8317610304565b6000601461059360206040610a8e565b61059d9190610a8e565b6fffffffffffffffffffffffffffffffff8316101592915050565b60006fffffffffffffffffffffffffffffffff821660048110156105df5750600092915050565b6101a56105ed600483610aa1565b601f161590565b600081600003610606575060006101a5565b6020821115610641576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661065e8385610a8e565b1115610696576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006106a78660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b60006fffffffffffffffffffffffffffffffff83168083111561074d576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6103048361075b8660801c90565b01848303610520565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126107a457600080fd5b813567ffffffffffffffff808211156107bf576107bf610764565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561080557610805610764565b8160405283815286602085880101111561081e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561085057600080fd5b813567ffffffffffffffff81111561086757600080fd5b61030484828501610793565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208101600283106108dd577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b91905290565b6000806000606084860312156108f857600080fd5b83356002811061090757600080fd5b925060208401356fffffffffffffffffffffffffffffffff8116811461092c57600080fd5b9150604084013567ffffffffffffffff81111561094857600080fd5b61095486828701610793565b9150509250925092565b60005b83811015610979578181015183820152602001610961565b50506000910152565b60208152600082518060208401526109a181604085016020870161095e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600060028510610a0c577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8460f81b82527fffffffffffffffffffffffffffffffff000000000000000000000000000000008460801b1660018301528251610a5081601185016020870161095e565b91909101601101949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561017c5761017c610a5f565b8181038181111561017c5761017c610a5f56fea26469706673582212203cf5aaf27d7b7efb3d1315cb98c8525db040069030e5013e419725437181f0d664736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c311d3591161005b578063c311d359146100ff578063c97c703a14610112578063d7a7a72c14610125578063f9893ddd1461014657600080fd5b806337dcc27b14610082578063801fdbfc146100ab578063b71ae0de146100df575b600080fd5b61009561009036600461083e565b610169565b6040516100a291906108a2565b60405180910390f35b6100be6100b936600461083e565b610182565b6040516fffffffffffffffffffffffffffffffff90911681526020016100a2565b6100f26100ed3660046108e3565b610195565b6040516100a29190610982565b6100f261010d36600461083e565b6101ac565b6100f261012036600461083e565b6101c9565b61013861013336600461083e565b6101df565b6040519081526020016100a2565b61015961015436600461083e565b6101f2565b60405190151581526020016100a2565b600061017c61017783610205565b610218565b92915050565b600061017c61019083610205565b610238565b60606101a284848461024d565b90505b9392505050565b606060006101b983610205565b90506101a58161027c565b61027c565b606061017c6101c46101da84610205565b6102d9565b600061017c6101ed83610205565b6102e5565b600061017c610200836102f1565b61030c565b600061017c610213836102f1565b61038a565b60008161022481610403565b60ff1660018111156101a5576101a5610873565b600061017c61024a836001601061040d565b90565b6060838383604051602001610264939291906109d3565b60405160208183030381529060405290509392505050565b6040518061028d836020830161042e565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b6000816101a5816104dd565b6000816101a5816104f5565b8051600090602083016103048183610520565b949350505050565b60006fffffffffffffffffffffffffffffffff821661032d60106001610a8e565b81101561033d5750600092915050565b600061034884610403565b9050600160ff82161115610360575060009392505050565b60ff811661037957610304610374856104dd565b610583565b610304610385856104dd565b6105b8565b60006103958261030c565b6103ff576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f742061206d657373616765207061796c6f61640000000000000000000000604482015260640160405180910390fd5b5090565b600061017c828260015b60008061041b8585856105f4565b602084900360031b1c9150509392505050565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610488576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa9050806104cb576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061017c6104ee60106001610a8e565b83906106fe565b6000806105028360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b60008061052d8385610a8e565b905060405181111561053d575060005b80600003610577576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b8317610304565b6000601461059360206040610a8e565b61059d9190610a8e565b6fffffffffffffffffffffffffffffffff8316101592915050565b60006fffffffffffffffffffffffffffffffff821660048110156105df5750600092915050565b6101a56105ed600483610aa1565b601f161590565b600081600003610606575060006101a5565b6020821115610641576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661065e8385610a8e565b1115610696576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006106a78660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b60006fffffffffffffffffffffffffffffffff83168083111561074d576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6103048361075b8660801c90565b01848303610520565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126107a457600080fd5b813567ffffffffffffffff808211156107bf576107bf610764565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561080557610805610764565b8160405283815286602085880101111561081e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561085057600080fd5b813567ffffffffffffffff81111561086757600080fd5b61030484828501610793565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208101600283106108dd577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b91905290565b6000806000606084860312156108f857600080fd5b83356002811061090757600080fd5b925060208401356fffffffffffffffffffffffffffffffff8116811461092c57600080fd5b9150604084013567ffffffffffffffff81111561094857600080fd5b61095486828701610793565b9150509250925092565b60005b83811015610979578181015183820152602001610961565b50506000910152565b60208152600082518060208401526109a181604085016020870161095e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600060028510610a0c577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8460f81b82527fffffffffffffffffffffffffffffffff000000000000000000000000000000008460801b1660018301528251610a5081601185016020870161095e565b91909101601101949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561017c5761017c610a5f565b8181038181111561017c5761017c610a5f56fea26469706673582212203cf5aaf27d7b7efb3d1315cb98c8525db040069030e5013e419725437181f0d664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"60069:2118:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"60069:2118:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;61014:124;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;61144:139;;;;;;:::i;:::-;;:::i;:::-;;;2081:34:1;2069:47;;;2051:66;;2039:2;2024:18;61144:139:0;1905:218:1;62001:184:0;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;60662:346::-;;;;;;:::i;:::-;;:::i;61289:133::-;;;;;;:::i;:::-;;:::i;61428:120::-;;;;;;:::i;:::-;;:::i;:::-;;;3696:25:1;;;3684:2;3669:18;61428:120:0;3550:177:1;61554:117:0;;;;;;:::i;:::-;;:::i;:::-;;;3897:14:1;;3890:22;3872:41;;3860:2;3845:18;61554:117:0;3732:187:1;61014:124:0;61071:11;61101:30;:23;:7;:21;:23::i;:::-;:28;:30::i;:::-;61094:37;61014:124;-1:-1:-1;;61014:124:0:o;61144:139::-;61203:7;61243:32;:23;:7;:21;:23::i;:::-;:30;:32::i;62001:184::-;62100:12;62131:47;62156:5;62163:7;62172:5;62131:24;:47::i;:::-;62124:54;;62001:184;;;;;;:::o;60662:346::-;60728:12;60909:15;60927:33;60952:7;60927:24;:33::i;:::-;60909:51;-1:-1:-1;60977:24:0;60909:51;60977:22;:24::i;:16::-;:22;:24::i;61289:133::-;61346:12;61377:38;:30;:23;:7;:21;:23::i;:::-;:28;:30::i;61428:120::-;61485:7;61511:30;:23;:7;:21;:23::i;:::-;:28;:30::i;61554:117::-;61616:4;61639:25;:13;:7;:11;:13::i;:::-;:23;:25::i;56251:129::-;56319:7;56345:28;56359:13;:7;:11;:13::i;:::-;56345;:28::i;58385:279::-;58439:11;58480:7;58642:14;58480:7;58642:5;:14::i;:::-;58630:27;;;;;;;;;;:::i;58726:186::-;58782:6;58807:98;58829:74;:7;55152:1;1976:2;58829:26;:74::i;:::-;57774:7;57664:126;55892:206;56017:12;56069:5;56076:7;56085:5;56052:39;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;56045:46;;55892:206;;;;;:::o;18194:1041::-;18440:4;18434:11;;18570:34;18584:7;18599:4;18593:10;;18570:13;:34::i;:::-;-1:-1:-1;21380:17:0;21354:43;;18816:12;22212:2;22196:18;;22580:20;;19112;;19134:4;19108:31;19102:4;19095:45;-1:-1:-1;19202:17:0;;18194:1041;;-1:-1:-1;18194:1041:0:o;58990:145::-;59044:7;59081;59114:14;59081:7;59114:5;:14::i;57878:147::-;57932:7;57969;58002:16;57969:7;58002:14;:16::i;17087:569::-;17175:10;;17141:7;;17601:4;17592:14;;17632:17;17592:14;17175:10;17632:5;:17::i;:::-;17625:24;17087:569;-1:-1:-1;;;;17087:569:0:o;56808:790::-;56867:4;21380:17;21354:43;;55198:29;1976:2;55152:1;55198:29;:::i;:::-;56984:6;:20;56980:38;;;-1:-1:-1;57013:5:0;;56808:790;-1:-1:-1;;56808:790:0:o;56980:38::-;57028:11;57042:14;57048:7;57042:5;:14::i;:::-;57028:28;-1:-1:-1;57138:21:0;57124:36;;;;57120:54;;;-1:-1:-1;57169:5:0;;56808:790;-1:-1:-1;;;56808:790:0:o;57120:54::-;57299:32;;;57295:297;;57411:30;:14;57417:7;57411:5;:14::i;:::-;:28;:30::i;57295:297::-;57554:27;:14;57560:7;57554:5;:14::i;:::-;:25;:27::i;56530:195::-;56593:7;56620:18;56630:7;56620:9;:18::i;:::-;56612:52;;;;;;;5219:2:1;56612:52:0;;;5201:21:1;5258:2;5238:18;;;5231:30;5297:23;5277:18;;;5270:51;5338:18;;56612:52:0;;;;;;;;-1:-1:-1;56709:7:0;56530:195::o;59544:143::-;59598:5;59628:51;:7;59598:5;59676:1;29667:538;29758:7;;29800:29;:7;29814:6;29822;29800:13;:29::i;:::-;30170:2;:11;;;30186:1;30169:18;30143:45;;-1:-1:-1;;29667:538:0;;;;;:::o;32128:842::-;32467:4;32461:11;32206:7;;21380:17;21354:43;;;21013:3;20986:30;;;;32549:12;;;32545:66;;;32584:16;;;;;;;;;;;;;;32545:66;32620:8;32836:4;32828:6;32822:4;32814:6;32808:4;32801:5;32790:51;32783:58;;32865:3;32860:37;;32877:20;;;;;;;;;;;;;;32860:37;31477:3;31469:11;;;31468:20;;32907:56;32128:842;-1:-1:-1;;;;;;;32128:842:0:o;59839:127::-;59893:7;59919:40;55198:29;1976:2;55152:1;55198:29;:::i;:::-;59919:7;;:17;:40::i;23118:292::-;23174:14;23200:12;23215:13;:7;21013:3;20986:30;;20827:196;23215:13;21380:17;21354:43;;;;23373:21;;;;;-1:-1:-1;;23118:292:0:o;16207:540::-;16273:7;;16307:11;16314:4;16307;:11;:::i;:::-;16292:26;;16586:4;16580:11;16574:4;16571:21;16568:38;;;-1:-1:-1;16603:1:0;16568:38;16629:4;16637:1;16629:9;16625:66;;16661:19;;;;;;;;;;;;;;16625:66;31477:3;31469:11;;;31468:20;;16707:33;31144:352;38121:241;38184:4;2097:2;36227:25;2194:2;36177;36227:25;:::i;:::-;36300:31;;;;:::i;:::-;21380:17;21354:43;;38265:31;;;38121:241;-1:-1:-1;;38121:241:0:o;46899:362::-;46959:4;21380:17;21354:43;;41538:1;47080:24;;47076:42;;;-1:-1:-1;47113:5:0;;46899:362;-1:-1:-1;;46899:362:0:o;47076:42::-;47218:36;47229:24;41538:1;47229:6;:24;:::i;:::-;49598:2;49589:11;:16;;49461:151;27975:1334;28062:14;28092:6;28102:1;28092:11;28088:59;;-1:-1:-1;28134:1:0;28119:17;;28088:59;28233:2;28224:6;:11;28220:65;;;28258:16;;;;;;;;;;;;;;28220:65;21380:17;21354:43;;28364:15;28373:6;28364;:15;:::i;:::-;:31;28360:82;;;28418:13;;;;;;;;;;;;;;28360:82;28481:1;28471:11;;;28451:17;28521:13;:7;21013:3;20986:30;;20827:196;28521:13;29268:17;;;29262:24;28979:66;28960:17;;;;;28956:90;;;;29258:35;;27975:1334;-1:-1:-1;;;;27975:1334:0:o;25241:529::-;25316:7;21380:17;21354:43;;25423:13;;;25419:64;;;25459:13;;;;;;;;;;;;;;25419:64;25695:58;25724:6;25708:13;:7;21013:3;20986:30;;20827:196;25708:13;:22;25745:6;25738:4;:13;25695:5;:58::i;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1310:184::-;1362:77;1359:1;1352:88;1459:4;1456:1;1449:15;1483:4;1480:1;1473:15;1499:401;1647:2;1632:18;;1680:1;1669:13;;1659:201;;1716:77;1713:1;1706:88;1817:4;1814:1;1807:15;1845:4;1842:1;1835:15;1659:201;1869:25;;;1499:401;:::o;2128:704::-;2257:6;2265;2273;2326:2;2314:9;2305:7;2301:23;2297:32;2294:52;;;2342:1;2339;2332:12;2294:52;2381:9;2368:23;2420:1;2413:5;2410:12;2400:40;;2436:1;2433;2426:12;2400:40;2459:5;-1:-1:-1;2516:2:1;2501:18;;2488:32;2564:34;2551:48;;2539:61;;2529:89;;2614:1;2611;2604:12;2529:89;2637:7;-1:-1:-1;2695:2:1;2680:18;;2667:32;2722:18;2711:30;;2708:50;;;2754:1;2751;2744:12;2708:50;2777:49;2818:7;2809:6;2798:9;2794:22;2777:49;:::i;:::-;2767:59;;;2128:704;;;;;:::o;2837:250::-;2922:1;2932:113;2946:6;2943:1;2940:13;2932:113;;;3022:11;;;3016:18;3003:11;;;2996:39;2968:2;2961:10;2932:113;;;-1:-1:-1;;3079:1:1;3061:16;;3054:27;2837:250::o;3092:453::-;3239:2;3228:9;3221:21;3202:4;3271:6;3265:13;3314:6;3309:2;3298:9;3294:18;3287:34;3330:79;3402:6;3397:2;3386:9;3382:18;3377:2;3369:6;3365:15;3330:79;:::i;:::-;3461:2;3449:15;3466:66;3445:88;3430:104;;;;3536:2;3426:113;;3092:453;-1:-1:-1;;3092:453:1:o;3924:769::-;4150:3;4189:1;4181:6;4178:13;4168:201;;4225:77;4222:1;4215:88;4326:4;4323:1;4316:15;4354:4;4351:1;4344:15;4168:201;4399:6;4394:3;4390:16;4385:3;4378:29;4458:66;4449:6;4444:3;4440:16;4436:89;4432:1;4427:3;4423:11;4416:110;4555:6;4549:13;4571:75;4639:6;4634:2;4629:3;4625:12;4618:4;4610:6;4606:17;4571:75;:::i;:::-;4666:16;;;;4684:2;4662:25;;3924:769;-1:-1:-1;;;;3924:769:1:o;4698:184::-;4750:77;4747:1;4740:88;4847:4;4844:1;4837:15;4871:4;4868:1;4861:15;4887:125;4952:9;;;4973:10;;;4970:36;;;4986:18;;:::i;5367:128::-;5434:9;;;5455:11;;;5452:37;;;5469:18;;:::i","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"flag","outputs":[{"internalType":"enum MessageFlag","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"enum MessageFlag","name":"flag_","type":"uint8"},{"internalType":"Header","name":"header_","type":"uint128"},{"internalType":"bytes","name":"body_","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"header","outputs":[{"internalType":"uint128","name":"","type":"uint128"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isMessage","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Message methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"flag_\",\"type\":\"uint8\"},{\"internalType\":\"Header\",\"name\":\"header_\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"body_\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"header\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Message methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","castToMessage(bytes)":"c311d359","flag(bytes)":"37dcc27b","formatMessage(uint8,uint128,bytes)":"b71ae0de","header(bytes)":"801fdbfc","isMessage(bytes)":"f9893ddd","leaf(bytes)":"d7a7a72c"}},"solidity/MessageHarness.t.sol:MessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208e1ce65db73aa15e23f0fbb998ecfb443f5a7df24395732e2066f3cc6132527b64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208e1ce65db73aa15e23f0fbb998ecfb443f5a7df24395732e2066f3cc6132527b64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"54808:5160:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;54808:5160:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"54808:5160:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting the various messages supported by Origin and Destination. # Message memory layout | Position   | Field  | Type    | Bytes | Description                                             | | ---------- | ------ | ------- | ----- | ------------------------------------------------------- | | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     | | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     | | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_FLAG":{"details":"The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_FLAG\":{\"details\":\"The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting the various messages supported by Origin and Destination. # Message memory layout | Position   | Field  | Type    | Bytes | Description                                             | | ---------- | ------ | ------- | ----- | ------------------------------------------------------- | | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     | | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     | | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c562f37852d323420ca7e4ec65fdd41958bd5803554b3249bb1d2cc818647cdd64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c562f37852d323420ca7e4ec65fdd41958bd5803554b3249bb1d2cc818647cdd64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"4736:1772:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4736:1772:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4736:1772:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_GAS_DROP":{"details":"Amount of bits to shift to gasDrop field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_GAS_DROP\":{\"details\":\"Amount of bits to shift to gasDrop field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c3952f5942eb7f284d5391bdb01d8ea78c76c1020aed55b8ba6825e5ffa7cbaf64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c3952f5942eb7f284d5391bdb01d8ea78c76c1020aed55b8ba6825e5ffa7cbaf64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Domain of the Synapse Chain\n// TODO: replace the placeholder with actual value (for MVP this is Optimism chainId)\nuint32 constant SYNAPSE_DOMAIN = 10;\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        require(newValue \u003e= oldValue, \"Tips value too low\");\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // delta fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows\n            require(delta + tips.deliveryTip() \u003c= type(uint64).max, \"Tips overflow\");\n            // Delivery tips is last 8 bytes, so we can just add delta to the tips value\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [032..064) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [064..096) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_SENDER = 0;\n    uint256 private constant OFFSET_RECIPIENT = 32;\n    uint256 private constant OFFSET_TIPS = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_TIPS + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param tips_         Encoded tips information\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(bytes32 sender_, bytes32 recipient_, Tips tips_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(sender_, recipient_, tips_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        require(isBaseMessage(memView), \"Not a base message\");\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        require(isSignature(memView), \"Not a signature\");\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        require(isCallData(memView), \"Not a calldata\");\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint128;\n\nusing HeaderLib for Header global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to origin field\n    uint128 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint128 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint128 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        internal\n        pure\n        returns (Header)\n    {\n        return Header.wrap(\n            uint128(origin_) \u003c\u003c SHIFT_ORIGIN | uint128(nonce_) \u003c\u003c SHIFT_NONCE\n                | uint128(destination_) \u003c\u003c SHIFT_DESTINATION | uint128(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        return Header.wrap(uint128(paddedHeader));\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing MessageLib for MessageFlag global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..001) | flag   | uint8   | 1     | Flag specifying the type of message                     |\n/// | [001..017) | header | uint128 | 16    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_FLAG = 0;\n    uint256 private constant OFFSET_HEADER = 1;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param flag_     Flag specifying the type of message\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(flag_, header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        require(isMessage(memView), \"Not a message payload\");\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if flag and header exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        uint8 flag_ = _flag(memView);\n        // Check that Flag fits into MessageFlag enum\n        if (flag_ \u003e uint8(type(MessageFlag).max)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (flag_ == uint8(MessageFlag.Base)) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        MemView memView = message.unwrap();\n        return memView.keccak();\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's flag.\n    function flag(Message message) internal pure returns (MessageFlag) {\n        MemView memView = message.unwrap();\n        // We check that flag fits into enum, when payload is wrapped\n        // into Message, so this never reverts\n        return MessageFlag(_flag(memView));\n    }\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's flag without checking that it fits into MessageFlag enum.\n    function _flag(MemView memView) private pure returns (uint8) {\n        return uint8(memView.indexUint({index_: OFFSET_FLAG, bytes_: 1}));\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function flag(bytes memory payload) public pure returns (MessageFlag) {\n        return payload.castToMessage().flag();\n    }\n\n    function header(bytes memory payload) public pure returns (uint128) {\n        return Header.unwrap(payload.castToMessage().header());\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(MessageFlag flag_, Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(flag_, header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"9015:5125:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9015:5125:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9015:5125:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"# Tips Library for formatting _the tips part_ of _the base messages_. ## How the tips are awarded Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible. ### Summit tips Split between:     - Guard posting a snapshot with state ST_G for the origin chain.     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.     - Notary posting a message receipt after it is executed on destination chain. ### Attestation tips Paid to:     - Notary posting attestation A to destination chain. ### Execution tips Paid to:     - First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not. ### Delivery tips. Paid to:     - Executor who successfully executed the message on destination chain. ## Tips encoding - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory. - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency. # Tips stack layout (from highest bits to lowest) | Position   | Field          | Type   | Bytes | Description                                                | | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- | | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            | | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract | | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       | | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_ATTESTATION_TIP":{"details":"Amount of bits to shift to attestationTip field"},"SHIFT_EXECUTION_TIP":{"details":"Amount of bits to shift to executionTip field"},"SHIFT_SUMMIT_TIP":{"details":"Amount of bits to shift to summitTip field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_ATTESTATION_TIP\":{\"details\":\"Amount of bits to shift to attestationTip field\"},\"SHIFT_EXECUTION_TIP\":{\"details\":\"Amount of bits to shift to executionTip field\"},\"SHIFT_SUMMIT_TIP\":{\"details\":\"Amount of bits to shift to summitTip field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"# Tips Library for formatting _the tips part_ of _the base messages_. ## How the tips are awarded Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible. ### Summit tips Split between:     - Guard posting a snapshot with state ST_G for the origin chain.     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.     - Notary posting a message receipt after it is executed on destination chain. ### Attestation tips Paid to:     - Notary posting attestation A to destination chain. ### Execution tips Paid to:     - First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not. ### Delivery tips. Paid to:     - Executor who successfully executed the message on destination chain. ## Tips encoding - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory. - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. \u003e The only downside is that the \\\"real tip values\\\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency. # Tips stack layout (from highest bits to lowest) | Position   | Field          | Type   | Bytes | Description                                                | | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- | | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            | | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract | | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       | | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x3b399886a0b5e240b304ceace10292fc1cb1ad6523b633b60db81a01400a3e09\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c49c5887534906bda6f81a9f505413a66cd4d04968f69e465455a3c766ed8238\",\"dweb:/ipfs/QmY2TTWkR1Lvh8sLCHoubEp7nBzY5S5KaQ5Qw1zNpJDDiN\"]}},\"version\":1}"},"hashes":{}}}