{"solidity/MessageHarness.t.sol:BaseMessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207eec7198e2b49bb987c05cb60b824d2440469dc9fb1f7ae03b2e7f3014d6b0e064736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207eec7198e2b49bb987c05cb60b824d2440469dc9fb1f7ae03b2e7f3014d6b0e064736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"52008:4880:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;52008:4880:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"52008:4880:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"BaseMessage structure represents a base message sent via the Origin-Destination contracts. - It only contains data relevant to the base message, the rest of data is encoded in the message header. - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment. - `tips` and `request` parameters are specified by a message sender \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips lower than that. # Memory layout of BaseMessage fields | Position   | Field     | Type    | Bytes | Description                            | | ---------- | --------- | ------- | ----- | -------------------------------------- | | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      | | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         | | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain | | [096..116) | request   | uint160 | 20    | Encoded request for message execution  | | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_TIPS":{"details":"The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_TIPS\":{\"details\":\"The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"BaseMessage structure represents a base message sent via the Origin-Destination contracts. - It only contains data relevant to the base message, the rest of data is encoded in the message header. - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment. - `tips` and `request` parameters are specified by a message sender \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips lower than that. # Memory layout of BaseMessage fields | Position   | Field     | Type    | Bytes | Description                            | | ---------- | --------- | ------- | ----- | -------------------------------------- | | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      | | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         | | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain | | [096..116) | request   | uint160 | 20    | Encoded request for message execution  | | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"BaseMessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ab4e0d7b718e7484fb3d98bfdd146563fe37091ba2b5aa7443d243f8968c06ab64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ab4e0d7b718e7484fb3d98bfdd146563fe37091ba2b5aa7443d243f8968c06ab64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"57492:9123:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;57492:9123:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"57492:9123:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:HeaderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122027fe9135fde1e689fb4f5a05b21c42a0bd65b4925eb73d70d2282b9dc59a5c1c64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122027fe9135fde1e689fb4f5a05b21c42a0bd65b4925eb73d70d2282b9dc59a5c1c64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"68073:4996:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;68073:4996:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"68073:4996:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the header part_ of _the messages used by Origin and Destination_. - Header represents general information for routing a Message for Origin and Destination. - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory. # Header stack layout (from highest bits to lowest) | Position   | Field            | Type   | Bytes | Description                             | | ---------- | ---------------- | ------ | ----- | --------------------------------------- | | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     | | (016..012] | origin           | uint32 | 4     | Domain where message originated         | | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      | | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   | | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_DESTINATION":{"details":"Amount of bits to shift to destination field"},"SHIFT_FLAG":{"details":"Amount of bits to shift to flag field"},"SHIFT_NONCE":{"details":"Amount of bits to shift to nonce field"},"SHIFT_ORIGIN":{"details":"Amount of bits to shift to origin field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_DESTINATION\":{\"details\":\"Amount of bits to shift to destination field\"},\"SHIFT_FLAG\":{\"details\":\"Amount of bits to shift to flag field\"},\"SHIFT_NONCE\":{\"details\":\"Amount of bits to shift to nonce field\"},\"SHIFT_ORIGIN\":{\"details\":\"Amount of bits to shift to origin field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the header part_ of _the messages used by Origin and Destination_. - Header represents general information for routing a Message for Origin and Destination. - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory. # Header stack layout (from highest bits to lowest) | Position   | Field            | Type   | Bytes | Description                             | | ---------- | ---------------- | ------ | ----- | --------------------------------------- | | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     | | (016..012] | origin           | uint32 | 4     | Domain where message originated         | | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      | | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   | | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"HeaderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MemViewLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220929497adc1268b041338157e7249e60fb08e9107f26c135979b20872d2f4389664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220929497adc1268b041338157e7249e60fb08e9107f26c135979b20872d2f4389664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"5721:19162:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5721:19162:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5721:19162:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \\\"memory view\\\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \\\"type\\\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MemViewLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MerkleMath":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f4f12cc9aeb20a20117afae2d60fb27ee449a155db693ee6df436749f44a086864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f4f12cc9aeb20a20117afae2d60fb27ee449a155db693ee6df436749f44a086864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"28534:9845:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;28534:9845:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"28534:9845:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MerkleMath\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b50610c53806100206000396000f3fe608060405234801561001057600080fd5b50600436106100715760003560e01c8063c97c703a11610050578063c97c703a146100e7578063d7a7a72c146100fa578063f9893ddd1461011b57600080fd5b8062b26cfe14610076578063801fdbfc1461009f578063c311d359146100d4575b600080fd5b610089610084366004610a3e565b61013e565b6040516100969190610ac8565b60405180910390f35b6100b26100ad366004610b19565b610153565b60405170ffffffffffffffffffffffffffffffffff9091168152602001610096565b6100896100e2366004610b19565b610166565b6100896100f5366004610b19565b61018a565b61010d610108366004610b19565b6101a0565b604051908152602001610096565b61012e610129366004610b19565b6101b3565b6040519015158152602001610096565b606061014a83836101c6565b90505b92915050565b600061014d610161836101f2565b610205565b60606000610173836101f2565b90506101838161021e565b61021e565b9392505050565b606061014d61017e61019b846101f2565b61027b565b600061014d6101ae836101f2565b610287565b600061014d6101c18361034c565b610367565b606082826040516020016101db929190610b4e565b604051602081830303815290604052905092915050565b600061014d6102008361034c565b61041c565b600061014d610219826011855b9190610461565b610482565b6040518061022f83602083016104c6565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60008161018381610575565b60008061029383610205565b905060006102b38270ffffffffffffffffffffffffffffffffff1661058c565b60018111156102c4576102c4610b99565b0361030d576101836102ef8270ffffffffffffffffffffffffffffffffff1660009081526020902090565b6103086103036102fe8761027b565b6105bf565b610600565b610626565b6101836103338270ffffffffffffffffffffffffffffffffff1660009081526020902090565b6103086103476103428761027b565b610672565b6106b3565b80516000906020830161035f81836106c3565b949350505050565b60006fffffffffffffffffffffffffffffffff8216610387601183610bf7565b8110156103975750600092915050565b60006103a284610726565b9050600160ff608083901c1611156103be575060009392505050565b60006103e46103cc83610482565b70ffffffffffffffffffffffffffffffffff1661058c565b60018111156103f5576103f5610b99565b0361040b5761035f61040685610575565b610734565b61035f61041785610575565b610769565b600061042782610367565b61045d576040517fd082b2a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b60008061046f8585856107a5565b602084900360031b1c9150509392505050565b6000600160ff608084901c16111561045d576040517f58ebbfbe00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610520576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610563576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061014d610585601183610bf7565b83906108af565b60006105ab8270ffffffffffffffffffffffffffffffffff1660801c90565b60ff16600181111561014d5761014d610b99565b60006105ca82610734565b61045d576040517f35c196ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061014d61061d61061184610915565b60009081526020902090565b61030884610929565b600082158015610634575081155b156106415750600061014d565b604080516020810185905290810183905260600160405160208183030381529060405280519060200120905061014d565b600061067d82610769565b61045d576040517f9d46362800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061014d82610939565b610939565b6000806106d08385610bf7565b90506040518111156106e0575060005b8060000361071a576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b831761035f565b600061014d82826011610461565b6000601861074460206040610bf7565b61074e9190610bf7565b6fffffffffffffffffffffffffffffffff8316101592915050565b60006fffffffffffffffffffffffffffffffff821660048110156107905750600092915050565b61018361079e600483610c0a565b601f161590565b6000816000036107b757506000610183565b60208211156107f2576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661080f8385610bf7565b1115610847576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006108588660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b60006fffffffffffffffffffffffffffffffff8316808311156108fe576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61035f8361090c8660801c90565b018483036106c3565b600061014d61092682602085610212565b90565b600061014d6106be8360206108af565b6000806109468360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126109a457600080fd5b813567ffffffffffffffff808211156109bf576109bf610964565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610a0557610a05610964565b81604052838152866020858801011115610a1e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215610a5157600080fd5b823570ffffffffffffffffffffffffffffffffff81168114610a7257600080fd5b9150602083013567ffffffffffffffff811115610a8e57600080fd5b610a9a85828601610993565b9150509250929050565b60005b83811015610abf578181015183820152602001610aa7565b50506000910152565b6020815260008251806020840152610ae7816040850160208701610aa4565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600060208284031215610b2b57600080fd5b813567ffffffffffffffff811115610b4257600080fd5b61035f84828501610993565b7fffffffffffffffffffffffffffffffffff0000000000000000000000000000008360781b16815260008251610b8b816011850160208701610aa4565b919091016011019392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561014d5761014d610bc8565b8181038181111561014d5761014d610bc856fea264697066735822122049451ed2ad1b4967f993e60af2644c742e9190bbc381dc9af6747fca7a88a3bf64736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100715760003560e01c8063c97c703a11610050578063c97c703a146100e7578063d7a7a72c146100fa578063f9893ddd1461011b57600080fd5b8062b26cfe14610076578063801fdbfc1461009f578063c311d359146100d4575b600080fd5b610089610084366004610a3e565b61013e565b6040516100969190610ac8565b60405180910390f35b6100b26100ad366004610b19565b610153565b60405170ffffffffffffffffffffffffffffffffff9091168152602001610096565b6100896100e2366004610b19565b610166565b6100896100f5366004610b19565b61018a565b61010d610108366004610b19565b6101a0565b604051908152602001610096565b61012e610129366004610b19565b6101b3565b6040519015158152602001610096565b606061014a83836101c6565b90505b92915050565b600061014d610161836101f2565b610205565b60606000610173836101f2565b90506101838161021e565b61021e565b9392505050565b606061014d61017e61019b846101f2565b61027b565b600061014d6101ae836101f2565b610287565b600061014d6101c18361034c565b610367565b606082826040516020016101db929190610b4e565b604051602081830303815290604052905092915050565b600061014d6102008361034c565b61041c565b600061014d610219826011855b9190610461565b610482565b6040518061022f83602083016104c6565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60008161018381610575565b60008061029383610205565b905060006102b38270ffffffffffffffffffffffffffffffffff1661058c565b60018111156102c4576102c4610b99565b0361030d576101836102ef8270ffffffffffffffffffffffffffffffffff1660009081526020902090565b6103086103036102fe8761027b565b6105bf565b610600565b610626565b6101836103338270ffffffffffffffffffffffffffffffffff1660009081526020902090565b6103086103476103428761027b565b610672565b6106b3565b80516000906020830161035f81836106c3565b949350505050565b60006fffffffffffffffffffffffffffffffff8216610387601183610bf7565b8110156103975750600092915050565b60006103a284610726565b9050600160ff608083901c1611156103be575060009392505050565b60006103e46103cc83610482565b70ffffffffffffffffffffffffffffffffff1661058c565b60018111156103f5576103f5610b99565b0361040b5761035f61040685610575565b610734565b61035f61041785610575565b610769565b600061042782610367565b61045d576040517fd082b2a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b60008061046f8585856107a5565b602084900360031b1c9150509392505050565b6000600160ff608084901c16111561045d576040517f58ebbfbe00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610520576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610563576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061014d610585601183610bf7565b83906108af565b60006105ab8270ffffffffffffffffffffffffffffffffff1660801c90565b60ff16600181111561014d5761014d610b99565b60006105ca82610734565b61045d576040517f35c196ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061014d61061d61061184610915565b60009081526020902090565b61030884610929565b600082158015610634575081155b156106415750600061014d565b604080516020810185905290810183905260600160405160208183030381529060405280519060200120905061014d565b600061067d82610769565b61045d576040517f9d46362800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061014d82610939565b610939565b6000806106d08385610bf7565b90506040518111156106e0575060005b8060000361071a576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b831761035f565b600061014d82826011610461565b6000601861074460206040610bf7565b61074e9190610bf7565b6fffffffffffffffffffffffffffffffff8316101592915050565b60006fffffffffffffffffffffffffffffffff821660048110156107905750600092915050565b61018361079e600483610c0a565b601f161590565b6000816000036107b757506000610183565b60208211156107f2576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661080f8385610bf7565b1115610847576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006108588660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b60006fffffffffffffffffffffffffffffffff8316808311156108fe576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61035f8361090c8660801c90565b018483036106c3565b600061014d61092682602085610212565b90565b600061014d6106be8360206108af565b6000806109468360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126109a457600080fd5b813567ffffffffffffffff808211156109bf576109bf610964565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610a0557610a05610964565b81604052838152866020858801011115610a1e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215610a5157600080fd5b823570ffffffffffffffffffffffffffffffffff81168114610a7257600080fd5b9150602083013567ffffffffffffffff811115610a8e57600080fd5b610a9a85828601610993565b9150509250929050565b60005b83811015610abf578181015183820152602001610aa7565b50506000910152565b6020815260008251806020840152610ae7816040850160208701610aa4565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b600060208284031215610b2b57600080fd5b813567ffffffffffffffff811115610b4257600080fd5b61035f84828501610993565b7fffffffffffffffffffffffffffffffffff0000000000000000000000000000008360781b16815260008251610b8b816011850160208701610aa4565b919091016011019392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561014d5761014d610bc8565b8181038181111561014d5761014d610bc856fea264697066735822122049451ed2ad1b4967f993e60af2644c742e9190bbc381dc9af6747fca7a88a3bf64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"78910:1946:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"78910:1946:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;80696:158;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;79855:123;;;;;;:::i;:::-;;:::i;:::-;;;2769:36:1;2757:49;;;2739:68;;2727:2;2712:18;79855:123:0;2566:247:1;79503:346:0;;;;;;:::i;:::-;;:::i;79984:133::-;;;;;;:::i;:::-;;:::i;80123:120::-;;;;;;:::i;:::-;;:::i;:::-;;;2964:25:1;;;2952:2;2937:18;80123:120:0;2818:177:1;80249:117:0;;;;;;:::i;:::-;;:::i;:::-;;;3165:14:1;;3158:22;3140:41;;3128:2;3113:18;80249:117:0;3000:187:1;80696:158:0;80776:12;80807:40;80832:7;80841:5;80807:24;:40::i;:::-;80800:47;;80696:158;;;;;:::o;79855:123::-;79914:6;79939:32;:23;:7;:21;:23::i;:::-;:30;:32::i;79503:346::-;79569:12;79750:15;79768:33;79793:7;79768:24;:33::i;:::-;79750:51;-1:-1:-1;79818:24:0;79750:51;79818:22;:24::i;:16::-;:22;:24::i;:::-;79811:31;79503:346;-1:-1:-1;;;79503:346:0:o;79984:133::-;80041:12;80072:38;:30;:23;:7;:21;:23::i;:::-;:28;:30::i;80123:120::-;80180:7;80206:30;:23;:7;:21;:23::i;:::-;:28;:30::i;80249:117::-;80311:4;80334:25;:13;:7;:11;:13::i;:::-;:23;:25::i;74713:152::-;74795:12;74843:7;74852:5;74826:32;;;;;;;;;:::i;:::-;;;;;;;;;;;;;74819:39;;74713:152;;;;:::o;75018:129::-;75086:7;75112:28;75126:13;:7;:11;:13::i;:::-;75112;:28::i;77556:186::-;77612:6;77637:98;77659:74;77612:6;26729:2;77659:7;:16;:26;:74;:26;:74::i;:::-;77637:20;:98::i;8567:1041::-;8813:4;8807:11;;8943:34;8957:7;8972:4;8966:10;;8943:13;:34::i;:::-;-1:-1:-1;11753:17:0;11727:43;;9189:12;12585:2;12569:18;;12953:20;;9485;;9507:4;9481:31;9475:4;9468:45;-1:-1:-1;9575:17:0;;8567:1041;;-1:-1:-1;8567:1041:0:o;77820:145::-;77874:7;77911;77944:14;77911:7;77944:5;:14::i;76658:522::-;76712:7;76817:14;76834:16;:7;:14;:16::i;:::-;76817:33;-1:-1:-1;76931:16:0;76913:14;:7;:12;;;:14::i;:::-;:34;;;;;;;;:::i;:::-;;76909:265;;76970:79;76991:14;:7;:12;;70468:20;70624:17;;;70740:2;70727:16;;;70416:343;76991:14;77007:41;:34;:14;:7;:12;:14::i;:::-;:32;:34::i;:::-;:39;:41::i;:::-;76970:20;:79::i;76909:265::-;77087:76;77108:14;:7;:12;;70468:20;70624:17;;;70740:2;70727:16;;;70416:343;77108:14;77124:38;:31;:14;:7;:12;:14::i;:::-;:29;:31::i;:::-;:36;:38::i;7460:569::-;7548:10;;7514:7;;7974:4;7965:14;;8005:17;7965:14;7548:10;8005:5;:17::i;:::-;7998:24;7460:569;-1:-1:-1;;;;7460:569:0:o;75575:803::-;75634:4;11753:17;11727:43;;74079:29;26729:2;75634:4;74079:29;:::i;:::-;75743:6;:20;75739:38;;;-1:-1:-1;75772:5:0;;75575:803;-1:-1:-1;;75575:803:0:o;75739:38::-;75825:20;75848:16;75856:7;75848;:16::i;:::-;75825:39;-1:-1:-1;69597:21:0;69568:51;68186:6;73033:26;;;69568:51;;;75874;;-1:-1:-1;75920:5:0;;75575:803;-1:-1:-1;;;75575:803:0:o;75874:51::-;76095:16;76050:41;:34;76071:12;76050:20;:34::i;:::-;:39;;;:41::i;:::-;:61;;;;;;;;:::i;:::-;;76046:326;;76191:30;:14;76197:7;76191:5;:14::i;:::-;:28;:30::i;76046:326::-;76334:27;:14;76340:7;76334:5;:14::i;:::-;:25;:27::i;75297:195::-;75360:7;75384:18;75394:7;75384:9;:18::i;:::-;75379:52;;75411:20;;;;;;;;;;;;;;75379:52;-1:-1:-1;75476:7:0;75297:195::o;20040:538::-;20131:7;;20173:29;:7;20187:6;20195;20173:13;:29::i;:::-;20543:2;:11;;;20559:1;20542:18;20516:45;;-1:-1:-1;;20040:538:0;;;;;:::o;70078:236::-;70143:6;69597:21;69568:51;68186:6;73033:26;;;69568:51;;;70204:52;;70240:16;;;;;;;;;;;;;;22501:842;22840:4;22834:11;22579:7;;11753:17;11727:43;;;11386:3;11359:30;;;;22922:12;;;22918:66;;;22957:16;;;;;;;;;;;;;;22918:66;22993:8;23209:4;23201:6;23195:4;23187:6;23181:4;23174:5;23163:51;23156:58;;23238:3;23233:37;;23250:20;;;;;;;;;;;;;;23233:37;21850:3;21842:11;;;21841:20;;23280:56;22501:842;-1:-1:-1;;;;;;;22501:842:0:o;78680:127::-;78734:7;78760:40;74079:29;26729:2;78734:7;74079:29;:::i;:::-;78760:7;;:17;:40::i;71125:223::-;71177:11;71312:28;71332:6;71312:28;;68186:6;73033:26;;72854:213;71312:28;71300:41;;;;;;;;;;:::i;53972:215::-;54039:11;54067:22;54081:7;54067:13;:22::i;:::-;54062:60;;54098:24;;;;;;;;;;;;;;54815:255;54877:7;54992:71;55013:25;:18;:11;:16;:18::i;:::-;70468:20;70624:17;;;70740:2;70727:16;;;70416:343;55013:25;55040:22;:11;:20;:22::i;31543:287::-;31624:14;31654:23;;:51;;;;-1:-1:-1;31681:24:0;;31654:51;31650:174;;;-1:-1:-1;31728:1:0;31721:8;;31650:174;31777:35;;;;;;4333:19:1;;;4368:12;;;4361:28;;;4405:12;;31777:35:0;;;;;;;;;;;;31767:46;;;;;;31760:53;;;;63321:200;63385:8;63410:19;63421:7;63410:10;:19::i;:::-;63405:54;;63438:21;;;;;;;;;;;;;;64343:115;64399:7;64425:26;:8;:24;:26::i;:17::-;:24;:26::i;6580:540::-;6646:7;;6680:11;6687:4;6680;:11;:::i;:::-;6665:26;;6959:4;6953:11;6947:4;6944:21;6941:38;;;-1:-1:-1;6976:1:0;6941:38;7002:4;7010:1;7002:9;6998:66;;7034:19;;;;;;;;;;;;;;6998:66;21850:3;21842:11;;;21841:20;;7080:33;21517:352;78374:154;78430:7;78456:65;:7;78430;26729:2;78456:17;:65::i;54259:241::-;54322:4;26824:2;52353:30;26921:2;52303;52353:30;:::i;:::-;52431:31;;;;:::i;:::-;11753:17;11727:43;;54403:31;;;54259:241;-1:-1:-1;;54259:241:0:o;63681:362::-;63741:4;11753:17;11727:43;;58292:1;63862:24;;63858:42;;;-1:-1:-1;63895:5:0;;63681:362;-1:-1:-1;;63681:362:0:o;63858:42::-;64000:36;64011:24;58292:1;64011:6;:24;:::i;:::-;66599:2;66590:11;:16;;66462:151;18348:1334;18435:14;18465:6;18475:1;18465:11;18461:59;;-1:-1:-1;18507:1:0;18492:17;;18461:59;18606:2;18597:6;:11;18593:65;;;18631:16;;;;;;;;;;;;;;18593:65;11753:17;11727:43;;18737:15;18746:6;18737;:15;:::i;:::-;:31;18733:82;;;18791:13;;;;;;;;;;;;;;18733:82;18854:1;18844:11;;;18824:17;18894:13;:7;11386:3;11359:30;;11200:196;18894:13;19641:17;;;19635:24;19352:66;19333:17;;;;;19329:90;;;;19631:35;;18348:1334;-1:-1:-1;;;;18348:1334:0:o;15614:529::-;15689:7;11753:17;11727:43;;15796:13;;;15792:64;;;15832:13;;;;;;;;;;;;;;15792:64;16068:58;16097:6;16081:13;:7;11386:3;11359:30;;11200:196;16081:13;:22;16118:6;16111:4;:13;16068:5;:58::i;55693:188::-;55755:4;55778:96;55798:74;55755:4;26921:2;55798:11;:20;76444:126;55798:74;76554:7;76444:126;55161:163;55227:7;55253:64;:55;:11;52251:2;55253:30;:55::i;13491:292::-;13547:14;13573:12;13588:13;:7;11386:3;11359:30;;11200:196;13588:13;11753:17;11727:43;;;;13746:21;;;;;-1:-1:-1;;13491:292:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:538::-;1089:6;1097;1150:2;1138:9;1129:7;1125:23;1121:32;1118:52;;;1166:1;1163;1156:12;1118:52;1205:9;1192:23;1255:36;1248:5;1244:48;1237:5;1234:59;1224:87;;1307:1;1304;1297:12;1224:87;1330:5;-1:-1:-1;1386:2:1;1371:18;;1358:32;1413:18;1402:30;;1399:50;;;1445:1;1442;1435:12;1399:50;1468:49;1509:7;1500:6;1489:9;1485:22;1468:49;:::i;:::-;1458:59;;;985:538;;;;;:::o;1528:250::-;1613:1;1623:113;1637:6;1634:1;1631:13;1623:113;;;1713:11;;;1707:18;1694:11;;;1687:39;1659:2;1652:10;1623:113;;;-1:-1:-1;;1770:1:1;1752:16;;1745:27;1528:250::o;1783:453::-;1930:2;1919:9;1912:21;1893:4;1962:6;1956:13;2005:6;2000:2;1989:9;1985:18;1978:34;2021:79;2093:6;2088:2;2077:9;2073:18;2068:2;2060:6;2056:15;2021:79;:::i;:::-;2152:2;2140:15;2157:66;2136:88;2121:104;;;;2227:2;2117:113;;1783:453;-1:-1:-1;;1783:453:1:o;2241:320::-;2309:6;2362:2;2350:9;2341:7;2337:23;2333:32;2330:52;;;2378:1;2375;2368:12;2330:52;2418:9;2405:23;2451:18;2443:6;2440:30;2437:50;;;2483:1;2480;2473:12;2437:50;2506:49;2547:7;2538:6;2527:9;2523:22;2506:49;:::i;3192:471::-;3428:66;3419:6;3414:3;3410:16;3406:89;3401:3;3394:102;3376:3;3525:6;3519:13;3541:75;3609:6;3604:2;3599:3;3595:12;3588:4;3580:6;3576:17;3541:75;:::i;:::-;3636:16;;;;3654:2;3632:25;;3192:471;-1:-1:-1;;;3192:471:1:o;3668:184::-;3720:77;3717:1;3710:88;3817:4;3814:1;3807:15;3841:4;3838:1;3831:15;3857:184;3909:77;3906:1;3899:88;4006:4;4003:1;3996:15;4030:4;4027:1;4020:15;4046:125;4111:9;;;4132:10;;;4129:36;;;4145:18;;:::i;4428:128::-;4495:9;;;4516:11;;;4513:37;;;4530:18;;:::i","abiDefinition":[{"inputs":[],"name":"FlagOutOfRange","type":"error"},{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"UnformattedBaseMessage","type":"error"},{"inputs":[],"name":"UnformattedCallData","type":"error"},{"inputs":[],"name":"UnformattedMessage","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"Header","name":"header_","type":"uint136"},{"internalType":"bytes","name":"body_","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"header","outputs":[{"internalType":"Header","name":"","type":"uint136"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isMessage","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Message methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"FlagOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnformattedBaseMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnformattedCallData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnformattedMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Header\",\"name\":\"header_\",\"type\":\"uint136\"},{\"internalType\":\"bytes\",\"name\":\"body_\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"header\",\"outputs\":[{\"internalType\":\"Header\",\"name\":\"\",\"type\":\"uint136\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Message methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","castToMessage(bytes)":"c311d359","formatMessage(uint136,bytes)":"00b26cfe","header(bytes)":"801fdbfc","isMessage(bytes)":"f9893ddd","leaf(bytes)":"d7a7a72c"}},"solidity/MessageHarness.t.sol:MessageLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220406cdf831bc03dd2904ef8c71b26dadcc1cc65d38daea34f3e8044a6d7bdabd764736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220406cdf831bc03dd2904ef8c71b26dadcc1cc65d38daea34f3e8044a6d7bdabd764736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"73735:5074:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;73735:5074:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"73735:5074:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting the various messages supported by Origin and Destination. # Message memory layout | Position   | Field  | Type    | Bytes | Description                                             | | ---------- | ------ | ------- | ----- | ------------------------------------------------------- | | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     | | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_HEADER":{"details":"The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_HEADER\":{\"details\":\"The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting the various messages supported by Origin and Destination. # Message memory layout | Position   | Field  | Type    | Bytes | Description                                             | | ---------- | ------ | ------- | ----- | ------------------------------------------------------- | | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     | | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"MessageLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220771d2e35e7579bfd4d8f938cbf4dbc701a263eda7a981972596ecea5317be6c964736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220771d2e35e7579bfd4d8f938cbf4dbc701a263eda7a981972596ecea5317be6c964736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"39456:2333:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;39456:2333:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"39456:2333:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  | | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_GAS_DROP":{"details":"Amount of bits to shift to gasDrop field"},"SHIFT_GAS_LIMIT":{"details":"Amount of bits to shift to gasLimit field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_GAS_DROP\":{\"details\":\"Amount of bits to shift to gasDrop field\"},\"SHIFT_GAS_LIMIT\":{\"details\":\"Amount of bits to shift to gasLimit field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  | | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220704ecc6518ccd425b333e7d6cbea321a5f46721726349eafa930442cf6b8a83564736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220704ecc6518ccd425b333e7d6cbea321a5f46721726349eafa930442cf6b8a83564736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\nlibrary MerkleMath {\n    // ═════════════════════════════════════════ BASIC MERKLE CALCULATIONS ═════════════════════════════════════════════\n\n    /**\n     * @notice Calculates the merkle root for the given leaf and merkle proof.\n     * @dev Will revert if proof length exceeds the tree height.\n     * @param index     Index of `leaf` in tree\n     * @param leaf      Leaf of the merkle tree\n     * @param proof     Proof of inclusion of `leaf` in the tree\n     * @param height    Height of the merkle tree\n     * @return root_    Calculated Merkle Root\n     */\n    function proofRoot(uint256 index, bytes32 leaf, bytes32[] memory proof, uint256 height)\n        internal\n        pure\n        returns (bytes32 root_)\n    {\n        // Proof length could not exceed the tree height\n        uint256 proofLen = proof.length;\n        if (proofLen \u003e height) revert TreeHeightTooLow();\n        root_ = leaf;\n        /// @dev Apply unchecked to all ++h operations\n        unchecked {\n            // Go up the tree levels from the leaf following the proof\n            for (uint256 h = 0; h \u003c proofLen; ++h) {\n                // Get a sibling node on current level: this is proof[h]\n                root_ = getParent(root_, proof[h], index, h);\n            }\n            // Go up to the root: the remaining siblings are EMPTY\n            for (uint256 h = proofLen; h \u003c height; ++h) {\n                root_ = getParent(root_, bytes32(0), index, h);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the parent of a node on the path from one of the leafs to root.\n     * @param node          Node on a path from tree leaf to root\n     * @param sibling       Sibling for a given node\n     * @param leafIndex     Index of the tree leaf\n     * @param nodeHeight    \"Level height\" for `node` (ZERO for leafs, ORIGIN_TREE_HEIGHT for root)\n     */\n    function getParent(bytes32 node, bytes32 sibling, uint256 leafIndex, uint256 nodeHeight)\n        internal\n        pure\n        returns (bytes32 parent)\n    {\n        // Index for `node` on its \"tree level\" is (leafIndex / 2**height)\n        // \"Left child\" has even index, \"right child\" has odd index\n        if ((leafIndex \u003e\u003e nodeHeight) \u0026 1 == 0) {\n            // Left child\n            return getParent(node, sibling);\n        } else {\n            // Right child\n            return getParent(sibling, node);\n        }\n    }\n\n    /// @notice Calculates the parent of tow nodes in the merkle tree.\n    /// @dev We use implementation with H(0,0) = 0\n    /// This makes EVERY empty node in the tree equal to ZERO,\n    /// saving us from storing H(0,0), H(H(0,0), H(0, 0)), and so on\n    /// @param leftChild    Left child of the calculated node\n    /// @param rightChild   Right child of the calculated node\n    /// @return parent      Value for the node having above mentioned children\n    function getParent(bytes32 leftChild, bytes32 rightChild) internal pure returns (bytes32 parent) {\n        if (leftChild == bytes32(0) \u0026\u0026 rightChild == bytes32(0)) {\n            return 0;\n        } else {\n            return keccak256(bytes.concat(leftChild, rightChild));\n        }\n    }\n\n    // ════════════════════════════════ ROOT/PROOF CALCULATION FOR A LIST OF LEAFS ═════════════════════════════════════\n\n    /**\n     * @notice Calculates merkle root for a list of given leafs.\n     * Merkle Tree is constructed by padding the list with ZERO values for leafs until list length is `2**height`.\n     * Merkle Root is calculated for the constructed tree, and then saved in `leafs[0]`.\n     * \u003e Note:\n     * \u003e - `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * \u003e - Caller is expected not to reuse `hashes` list after the call, and only use `leafs[0]` value,\n     * which is guaranteed to contain the calculated merkle root.\n     * \u003e - root is calculated using the `H(0,0) = 0` Merkle Tree implementation. See MerkleTree.sol for details.\n     * @dev Amount of leaves should be at most `2**height`\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param height    Height of the Merkle Tree to construct\n     */\n    function calculateRoot(bytes32[] memory hashes, uint256 height) internal pure {\n        uint256 levelLength = hashes.length;\n        // Amount of hashes could not exceed amount of leafs in tree with the given height\n        if (levelLength \u003e (1 \u003c\u003c height)) revert TreeHeightTooLow();\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\": the amount of iterations for the for loop above.\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Generates a proof of inclusion of a leaf in the list. If the requested index is outside\n     * of the list range, generates a proof of inclusion for an empty leaf (proof of non-inclusion).\n     * The Merkle Tree is constructed by padding the list with ZERO values until list length is a power of two\n     * __AND__ index is in the extended list range. For example:\n     *  - `hashes.length == 6` and `0 \u003c= index \u003c= 7` will \"extend\" the list to 8 entries.\n     *  - `hashes.length == 6` and `7 \u003c index \u003c= 15` will \"extend\" the list to 16 entries.\n     * \u003e Note: `leafs` values are overwritten in the process to avoid excessive memory allocations.\n     * Caller is expected not to reuse `hashes` list after the call.\n     * @param hashes    List of leafs for the merkle tree (to be overwritten)\n     * @param index     Leaf index to generate the proof for\n     * @return proof    Generated merkle proof\n     */\n    function calculateProof(bytes32[] memory hashes, uint256 index) internal pure returns (bytes32[] memory proof) {\n        // Use only meaningful values for the shortened proof\n        // Check if index is within the list range (we want to generates proofs for outside leafs as well)\n        uint256 height = getHeight(index \u003c hashes.length ? hashes.length : (index + 1));\n        proof = new bytes32[](height);\n        uint256 levelLength = hashes.length;\n        /// @dev h, leftIndex, rightIndex and levelLength never overflow\n        unchecked {\n            // Iterate `height` levels up from the leaf level\n            // For every level we will only record \"significant values\", i.e. not equal to ZERO\n            for (uint256 h = 0; h \u003c height; ++h) {\n                // Use sibling for the merkle proof; `index^1` is index of our sibling\n                proof[h] = (index ^ 1 \u003c levelLength) ? hashes[index ^ 1] : bytes32(0);\n\n                // Let H be the height of the \"current level\". H = 0 for the \"leafs level\".\n                // Invariant: a total of 2**(HEIGHT-H) nodes are on the current level\n                // Invariant: hashes[0 .. length) are \"significant values\" for the \"current level\" nodes\n                // Invariant: bytes32(0) is the value for nodes with indexes [length .. 2**(HEIGHT-H))\n\n                // Iterate over every pair of (leftChild, rightChild) on the current level\n                for (uint256 leftIndex = 0; leftIndex \u003c levelLength; leftIndex += 2) {\n                    uint256 rightIndex = leftIndex + 1;\n                    bytes32 leftChild = hashes[leftIndex];\n                    // Note: rightChild might be ZERO\n                    bytes32 rightChild = rightIndex \u003c levelLength ? hashes[rightIndex] : bytes32(0);\n                    // Record the parent hash in the same array. This will not affect\n                    // further calculations for the same level: (leftIndex \u003e\u003e 1) \u003c= leftIndex.\n                    hashes[leftIndex \u003e\u003e 1] = getParent(leftChild, rightChild);\n                }\n                // Set length for the \"parent level\"\n                levelLength = (levelLength + 1) \u003e\u003e 1;\n                // Traverse to parent node\n                index \u003e\u003e= 1;\n            }\n        }\n    }\n\n    /// @notice Returns the height of the tree having a given amount of leafs.\n    function getHeight(uint256 leafs) internal pure returns (uint256 height) {\n        uint256 amount = 1;\n        while (amount \u003c leafs) {\n            unchecked {\n                ++height;\n            }\n            amount \u003c\u003c= 1;\n        }\n    }\n}\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint192;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (024..012] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (012..004] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n/// | (004..000] | version  | uint32 | 4     | Base message version to pass to the recipient        |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint192 private constant SHIFT_GAS_DROP = 12 * 8;\n    /// @dev Amount of bits to shift to gasLimit field\n    uint192 private constant SHIFT_GAS_LIMIT = 4 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    /// @param version_     Base message version to pass to the recipient\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_, uint32 version_) internal pure returns (Request) {\n        return Request.wrap(uint192(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | uint192(gasLimit_) \u003c\u003c SHIFT_GAS_LIMIT | version_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint192(paddedRequest));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request) \u003e\u003e SHIFT_GAS_LIMIT);\n    }\n\n    /// @notice Returns the requested base message version to pass to the recipient.\n    function version(Request request) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Request.unwrap(request));\n    }\n}\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Convenience function to encode tips with uint256 values.\n    function encodeTips256(uint256 summitTip_, uint256 attestationTip_, uint256 executionTip_, uint256 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return encodeTips({\n            summitTip_: uint64(summitTip_ \u003e\u003e TIPS_GRANULARITY),\n            attestationTip_: uint64(attestationTip_ \u003e\u003e TIPS_GRANULARITY),\n            executionTip_: uint64(executionTip_ \u003e\u003e TIPS_GRANULARITY),\n            deliveryTip_: uint64(deliveryTip_ \u003e\u003e TIPS_GRANULARITY)\n        });\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    /// @notice Returns tips's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Tips tips) internal pure returns (bytes32 hashedTips) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store tips in scratch space\n            mstore(0, tips)\n            // Compute hash of tips padded to 32 bytes\n            hashedTips := keccak256(0, 32)\n        }\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    // ════════════════════════════════════════════════ TIPS VALUE ═════════════════════════════════════════════════════\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = uint256(tips.summitTip()) + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    /// @notice Increases the delivery tip to match the new value.\n    function matchValue(Tips tips, uint256 newValue) internal pure returns (Tips newTips) {\n        uint256 oldValue = tips.value();\n        if (newValue \u003c oldValue) revert TipsValueTooLow();\n        // We want to increase the delivery tip, while keeping the other tips the same\n        unchecked {\n            uint256 delta = (newValue - oldValue) \u003e\u003e TIPS_GRANULARITY;\n            // `delta` fits into uint224, as TIPS_GRANULARITY is 32, so this never overflows uint256.\n            // In practice, this will never overflow uint64 as well, but we still check it just in case.\n            if (delta + tips.deliveryTip() \u003e type(uint64).max) revert TipsOverflow();\n            // Delivery tips occupy lowest 8 bytes, so we can just add delta to the tips value\n            // to effectively increase the delivery tip (knowing that delta fits into uint64).\n            newTips = Tips.wrap(Tips.unwrap(tips) + delta);\n        }\n    }\n}\n\n/// BaseMessage is a memory view over the base message supported by Origin-Destination\ntype BaseMessage is uint256;\n\nusing BaseMessageLib for BaseMessage global;\n\n/// BaseMessage structure represents a base message sent via the Origin-Destination contracts.\n/// - It only contains data relevant to the base message, the rest of data is encoded in the message header.\n/// - `sender` and `recipient` for EVM chains are EVM addresses casted to bytes32, while preserving left-alignment.\n/// - `tips` and `request` parameters are specified by a message sender\n/// \u003e Origin will calculate minimum tips for given request and content length, and will reject messages with tips\n/// lower than that.\n///\n/// # Memory layout of BaseMessage fields\n///\n/// | Position   | Field     | Type    | Bytes | Description                            |\n/// | ---------- | --------- | ------- | ----- | -------------------------------------- |\n/// | [000..032) | tips      | uint256 | 32    | Encoded tips paid on origin chain      |\n/// | [032..064) | sender    | bytes32 | 32    | Sender address on origin chain         |\n/// | [064..096) | recipient | bytes32 | 32    | Recipient address on destination chain |\n/// | [096..116) | request   | uint160 | 20    | Encoded request for message execution  |\n/// | [104..AAA) | content   | bytes   | ??    | Content to be passed to recipient      |\nlibrary BaseMessageLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_TIPS = 0;\n    uint256 private constant OFFSET_SENDER = 32;\n    uint256 private constant OFFSET_RECIPIENT = 64;\n    uint256 private constant OFFSET_REQUEST = OFFSET_RECIPIENT + TIPS_LENGTH;\n    uint256 private constant OFFSET_CONTENT = OFFSET_REQUEST + REQUEST_LENGTH;\n\n    // ═══════════════════════════════════════════════ BASE MESSAGE ════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted BaseMessage payload with provided fields.\n     * @param tips_         Encoded tips information\n     * @param sender_       Sender address on origin chain\n     * @param recipient_    Recipient address on destination chain\n     * @param request_      Encoded request for message execution\n     * @param content_      Raw content to be passed to recipient on destination chain\n     * @return Formatted base message\n     */\n    function formatBaseMessage(Tips tips_, bytes32 sender_, bytes32 recipient_, Request request_, bytes memory content_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(tips_, sender_, recipient_, request_, content_);\n    }\n\n    /**\n     * @notice Returns a BaseMessage view over the given payload.\n     * @dev Will revert if the payload is not a base message.\n     */\n    function castToBaseMessage(bytes memory payload) internal pure returns (BaseMessage) {\n        return castToBaseMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a BaseMessage view.\n     * @dev Will revert if the memory view is not over a base message payload.\n     */\n    function castToBaseMessage(MemView memView) internal pure returns (BaseMessage) {\n        if (!isBaseMessage(memView)) revert UnformattedBaseMessage();\n        return BaseMessage.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted BaseMessage.\n    function isBaseMessage(MemView memView) internal pure returns (bool) {\n        // Check if sender, recipient, tips fields exist\n        return (memView.len() \u003e= OFFSET_CONTENT);\n        // Content could be empty, so we don't check that\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(BaseMessage baseMessage) internal pure returns (MemView) {\n        return MemView.wrap(BaseMessage.unwrap(baseMessage));\n    }\n\n    /// @notice Returns baseMessage's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        // We hash \"tips\" and \"everything but tips\" to make tips proofs easier to verify\n        return MerkleMath.getParent(baseMessage.tips().leaf(), baseMessage.bodyLeaf());\n    }\n\n    /// @notice Returns hash for the \"everything but tips\" part of the base message.\n    function bodyLeaf(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_SENDER}).keccak();\n    }\n\n    // ═══════════════════════════════════════════ BASE MESSAGE SLICING ════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips paid on origin chain.\n    function tips(BaseMessage baseMessage) internal pure returns (Tips) {\n        return TipsLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_TIPS, bytes_: TIPS_LENGTH})));\n    }\n\n    /// @notice Returns sender address on origin chain.\n    function sender(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_SENDER, bytes_: 32});\n    }\n\n    /// @notice Returns recipient address on destination chain.\n    function recipient(BaseMessage baseMessage) internal pure returns (bytes32) {\n        return baseMessage.unwrap().index({index_: OFFSET_RECIPIENT, bytes_: 32});\n    }\n\n    /// @notice Returns an encoded request for message execution on destination chain.\n    function request(BaseMessage baseMessage) internal pure returns (Request) {\n        return RequestLib.wrapPadded((baseMessage.unwrap().indexUint({index_: OFFSET_REQUEST, bytes_: REQUEST_LENGTH})));\n    }\n\n    /// @notice Returns an untyped memory view over the content to be passed to recipient.\n    function content(BaseMessage baseMessage) internal pure returns (MemView) {\n        return baseMessage.unwrap().sliceFrom({index_: OFFSET_CONTENT});\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is uint256;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is uint256;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 private constant OFFSET_R = 0;\n    uint256 private constant OFFSET_S = 32;\n    uint256 private constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 private constant OFFSET_SELECTOR = 0;\n    uint256 private constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(MemView memView) internal pure returns (Signature) {\n        if (!isSignature(memView)) revert UnformattedSignature();\n        return Signature.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(MemView memView) internal pure returns (bool) {\n        return memView.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (MemView) {\n        return MemView.wrap(Signature.unwrap(signature));\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        MemView memView = unwrap(signature);\n        r = memView.index({index_: OFFSET_R, bytes_: 32});\n        s = memView.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(memView.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        if (!_fullWords(prefix.length)) revert UnformattedCallDataPrefix();\n        MemView[] memory views = new MemView[](3);\n        // Use payload's function selector\n        views[0] = abi.encodePacked(callData.callSelector()).ref();\n        // Use prefix as the first arguments\n        views[1] = prefix.ref();\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return MemViewLib.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(MemView memView) internal pure returns (CallData) {\n        if (!isCallData(memView)) revert UnformattedCallData();\n        return CallData.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (MemView) {\n        return MemView.wrap(CallData.unwrap(callData));\n    }\n\n    /// @notice Returns callData's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(CallData callData) internal pure returns (bytes32) {\n        return callData.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (memView.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes4) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return bytes4(memView.index({index_: OFFSET_SELECTOR, bytes_: SELECTOR_LENGTH}));\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (MemView) {\n        // Get the underlying memory view\n        MemView memView = unwrap(callData);\n        return memView.sliceFrom({index_: OFFSET_ARGUMENTS});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/// Message is a memory over over a formatted message payload.\ntype Message is uint256;\n\nusing MessageLib for Message global;\n\n/// Library for formatting the various messages supported by Origin and Destination.\n///\n/// # Message memory layout\n///\n/// | Position   | Field  | Type    | Bytes | Description                                             |\n/// | ---------- | ------ | ------- | ----- | ------------------------------------------------------- |\n/// | [000..017) | header | uint136 | 17    | Encoded general routing information for the message     |\n/// | [017..AAA) | body   | bytes   | ??    | Formatted payload (according to flag) with message body |\nlibrary MessageLib {\n    using BaseMessageLib for MemView;\n    using ByteString for MemView;\n    using MemViewLib for bytes;\n    using HeaderLib for MemView;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_HEADER = 0;\n    uint256 private constant OFFSET_BODY = OFFSET_HEADER + HEADER_LENGTH;\n\n    // ══════════════════════════════════════════════════ MESSAGE ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns formatted message with provided fields.\n     * @param header_   Encoded general routing information for the message\n     * @param body_     Formatted payload (according to flag) with message body\n     * @return Formatted message\n     */\n    function formatMessage(Header header_, bytes memory body_) internal pure returns (bytes memory) {\n        return abi.encodePacked(header_, body_);\n    }\n\n    /**\n     * @notice Returns a Message view over for the given payload.\n     * @dev Will revert if the payload is not a message payload.\n     */\n    function castToMessage(bytes memory payload) internal pure returns (Message) {\n        return castToMessage(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Message view.\n     * @dev Will revert if the memory view is not over a message payload.\n     */\n    function castToMessage(MemView memView) internal pure returns (Message) {\n        if (!isMessage(memView)) revert UnformattedMessage();\n        return Message.wrap(MemView.unwrap(memView));\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Message.\n     */\n    function isMessage(MemView memView) internal pure returns (bool) {\n        uint256 length = memView.len();\n        // Check if headers exist in the payload\n        if (length \u003c OFFSET_BODY) return false;\n        // Check that Header is valid\n        uint256 paddedHeader = _header(memView);\n        if (!HeaderLib.isHeader(paddedHeader)) return false;\n        // Check that body is formatted according to the flag\n        // Only Base/Manager message flags exist\n        if (HeaderLib.wrapPadded(paddedHeader).flag() == MessageFlag.Base) {\n            // Check if body is a formatted base message\n            return _body(memView).isBaseMessage();\n        } else {\n            // Check if body is a formatted calldata for AgentManager call\n            return _body(memView).isCallData();\n        }\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Message message) internal pure returns (MemView) {\n        return MemView.wrap(Message.unwrap(message));\n    }\n\n    /// @notice Returns message's hash: a leaf to be inserted in the Merkle tree.\n    function leaf(Message message) internal pure returns (bytes32) {\n        // We hash header and body separately to make message proofs easier to verify\n        Header header_ = message.header();\n        // Only Base/Manager message flags exist\n        if (header_.flag() == MessageFlag.Base) {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToBaseMessage().leaf());\n        } else {\n            return MerkleMath.getParent(header_.leaf(), message.body().castToCallData().leaf());\n        }\n    }\n\n    // ══════════════════════════════════════════════ MESSAGE SLICING ══════════════════════════════════════════════════\n\n    /// @notice Returns message's encoded header field.\n    function header(Message message) internal pure returns (Header) {\n        return HeaderLib.wrapPadded((message.unwrap().indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH})));\n    }\n\n    /// @notice Returns message's body field as an untyped memory view.\n    function body(Message message) internal pure returns (MemView) {\n        MemView memView = message.unwrap();\n        return _body(memView);\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns message's padded header without checking that it is a valid header.\n    function _header(MemView memView) private pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_HEADER, bytes_: HEADER_LENGTH});\n    }\n\n    /// @dev Returns an untyped memory view over the body field without checking\n    /// if the whole payload or the body are properly formatted.\n    function _body(MemView memView) private pure returns (MemView) {\n        return memView.sliceFrom({index_: OFFSET_BODY});\n    }\n}\n\n// solhint-disable ordering\n/**\n * @notice Exposes Message methods for testing against golang.\n */\ncontract MessageHarness {\n    using MessageLib for bytes;\n    using MessageLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToMessage(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Message message = MessageLib.castToMessage(payload);\n        return message.unwrap().clone();\n    }\n\n    function header(bytes memory payload) public pure returns (Header) {\n        return payload.castToMessage().header();\n    }\n\n    function body(bytes memory payload) public view returns (bytes memory) {\n        return payload.castToMessage().body().clone();\n    }\n\n    function leaf(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToMessage().leaf();\n    }\n\n    function isMessage(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isMessage();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatMessage(Header header_, bytes memory body_) public pure returns (bytes memory) {\n        return MessageLib.formatMessage(header_, body_);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"44296:6340:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;44296:6340:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"44296:6340:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"# Tips Library for formatting _the tips part_ of _the base messages_. ## How the tips are awarded Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible. ### Summit tips Split between:     - Guard posting a snapshot with state ST_G for the origin chain.     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.     - Notary posting a message receipt after it is executed on destination chain. ### Attestation tips Paid to:     - Notary posting attestation A to destination chain. ### Execution tips Paid to:     - First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not. ### Delivery tips. Paid to:     - Executor who successfully executed the message on destination chain. ## Tips encoding - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory. - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency. # Tips stack layout (from highest bits to lowest) | Position   | Field          | Type   | Bytes | Description                                                | | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- | | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            | | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract | | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       | | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_ATTESTATION_TIP":{"details":"Amount of bits to shift to attestationTip field"},"SHIFT_EXECUTION_TIP":{"details":"Amount of bits to shift to executionTip field"},"SHIFT_SUMMIT_TIP":{"details":"Amount of bits to shift to summitTip field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_ATTESTATION_TIP\":{\"details\":\"Amount of bits to shift to attestationTip field\"},\"SHIFT_EXECUTION_TIP\":{\"details\":\"Amount of bits to shift to executionTip field\"},\"SHIFT_SUMMIT_TIP\":{\"details\":\"Amount of bits to shift to summitTip field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"# Tips Library for formatting _the tips part_ of _the base messages_. ## How the tips are awarded Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible. ### Summit tips Split between:     - Guard posting a snapshot with state ST_G for the origin chain.     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.     - Notary posting a message receipt after it is executed on destination chain. ### Attestation tips Paid to:     - Notary posting attestation A to destination chain. ### Execution tips Paid to:     - First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not. ### Delivery tips. Paid to:     - Executor who successfully executed the message on destination chain. ## Tips encoding - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory. - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. \u003e The only downside is that the \\\"real tip values\\\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency. # Tips stack layout (from highest bits to lowest) | Position   | Field          | Type   | Bytes | Description                                                | | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- | | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            | | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract | | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       | | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.t.sol\":{\"keccak256\":\"0x80d427a7951dd510f3a34e6c5dfa50502f5fac5ba178bc60d55df817edca0eb4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://b06c4fee09f6aef4eeaa3e08b18025b76cc63686e3749d008eaf12c26d0e82c3\",\"dweb:/ipfs/QmeDnMQRjNxrYWH7u9Bfzo79zKTrcoZX99bCX3Y4AzPtky\"]}},\"version\":1}"},"hashes":{}}}