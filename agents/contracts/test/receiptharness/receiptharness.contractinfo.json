{"solidity/ReceiptHarness.t.sol:MemViewLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122098ba55b416243182207f740336f4d47eefd196c497e1514c833c96f889800b9064736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122098ba55b416243182207f740336f4d47eefd196c497e1514c833c96f889800b9064736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\n// contracts/libs/Constants.sol\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Timeout between the agent root could be proposed and resolved in LightManager\nuint32 constant AGENT_ROOT_PROPOSAL_TIMEOUT = 12 hours;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time that the Notary will not be considered active after they won a dispute\nuint32 constant DISPUTE_TIMEOUT_NOTARY = 12 hours;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Maximum value for the summit tip that could be set in GasOracle\nuint256 constant MAX_SUMMIT_TIP = 0.01 ether;\n\n// contracts/libs/Errors.sol\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectAgentRoot();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror AgentRootNotProposed();\nerror AgentRootTimeoutNotOver();\n\nerror NotStuck();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeTimeoutNotOver();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror SummitTipTooHigh();\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n// contracts/libs/memory/MemView.sol\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// contracts/libs/memory/Receipt.sol\n\n/// Receipt is a memory view over a formatted \"full receipt\" payload.\ntype Receipt is uint256;\n\nusing ReceiptLib for Receipt global;\n\n/// Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`.\n/// - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not\n///   included in the receipt.\n/// - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an\n///   executed message.\n/// - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this\n///   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both\n///   receipts will be considered valid.\n/// # Memory layout of Receipt fields\n///\n/// | Position   | Field         | Type    | Bytes | Description                                      |\n/// | ---------- | ------------- | ------- | ----- | ------------------------------------------------ |\n/// | [000..004) | origin        | uint32  | 4     | Domain where message originated                  |\n/// | [004..008) | destination   | uint32  | 4     | Domain where message was executed                |\n/// | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              |\n/// | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       |\n/// | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       |\n/// | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root |\n/// | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     |\n/// | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\nlibrary ReceiptLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_DESTINATION = 4;\n    uint256 private constant OFFSET_MESSAGE_HASH = 8;\n    uint256 private constant OFFSET_SNAPSHOT_ROOT = 40;\n    uint256 private constant OFFSET_STATE_INDEX = 72;\n    uint256 private constant OFFSET_ATT_NOTARY = 73;\n    uint256 private constant OFFSET_FIRST_EXECUTOR = 93;\n    uint256 private constant OFFSET_FINAL_EXECUTOR = 113;\n\n    // ═════════════════════════════════════════════════ RECEIPT ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Receipt payload with provided fields.\n     * @param origin_           Domain where message originated\n     * @param destination_      Domain where message was executed\n     * @param messageHash_      Hash of the message\n     * @param snapshotRoot_     Snapshot root used for proving the message\n     * @param stateIndex_       Index of state used for the snapshot proof\n     * @param attNotary_        Notary who posted attestation with snapshot root\n     * @param firstExecutor_    Executor who performed first valid execution attempt\n     * @param finalExecutor_    Executor who successfully executed the message\n     * @return Formatted receipt\n     */\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n\n    /**\n     * @notice Returns a Receipt view over the given payload.\n     * @dev Will revert if the payload is not a receipt.\n     */\n    function castToReceipt(bytes memory payload) internal pure returns (Receipt) {\n        return castToReceipt(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Receipt view.\n     * @dev Will revert if the memory view is not over a receipt.\n     */\n    function castToReceipt(MemView memView) internal pure returns (Receipt) {\n        if (!isReceipt(memView)) revert UnformattedReceipt();\n        return Receipt.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Receipt.\n    function isReceipt(MemView memView) internal pure returns (bool) {\n        // Check payload length\n        return memView.len() == RECEIPT_LENGTH;\n    }\n\n    /// @notice Returns the hash of an Receipt, that could be later signed by a Notary to signal\n    /// that the receipt is valid.\n    function hashValid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_VALID_SALT);\n    }\n\n    /// @notice Returns the hash of a Receipt, that could be later signed by a Guard to signal\n    /// that the receipt is invalid.\n    function hashInvalid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptBodyInvalidSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_INVALID_SALT);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Receipt receipt) internal pure returns (MemView) {\n        return MemView.wrap(Receipt.unwrap(receipt));\n    }\n\n    /// @notice Compares two Receipt structures.\n    function equals(Receipt a, Receipt b) internal pure returns (bool) {\n        // Length of a Receipt payload is fixed, so we just need to compare the hashes\n        return a.unwrap().keccak() == b.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ RECEIPT SLICING ═════════════════════════════════════════════════\n\n    /// @notice Returns receipt's origin field\n    function origin(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_ORIGIN, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_DESTINATION, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_MESSAGE_HASH, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_SNAPSHOT_ROOT, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(Receipt receipt) internal pure returns (uint8) {\n        // Can be safely casted to uint8, since we index a single byte\n        return uint8(receipt.unwrap().indexUint({index_: OFFSET_STATE_INDEX, bytes_: 1}));\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_ATT_NOTARY});\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FIRST_EXECUTOR});\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FINAL_EXECUTOR});\n    }\n}\n\n// test/harnesses/libs/memory/ReceiptHarness.t.sol\n\n// solhint-disable ordering\ncontract ReceiptHarness {\n    using ReceiptLib for bytes;\n    using ReceiptLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToReceipt(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Receipt receipt = ReceiptLib.castToReceipt(payload);\n        return receipt.unwrap().clone();\n    }\n\n    /// @notice Returns receipt's origin field\n    function origin(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().origin();\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().destination();\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().messageHash();\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().snapshotRoot();\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(bytes memory payload) public pure returns (uint8) {\n        return payload.castToReceipt().stateIndex();\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().attNotary();\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().firstExecutor();\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().finalExecutor();\n    }\n\n    function equals(bytes memory a, bytes memory b) public pure returns (bool) {\n        return a.ref().castToReceipt().equals(b.ref().castToReceipt());\n    }\n\n    function isReceipt(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isReceipt();\n    }\n\n    function hashValid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashValid();\n    }\n\n    function hashInvalid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashInvalid();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) public pure returns (bytes memory) {\n        return ReceiptLib.formatReceipt(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"10022:19162:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;10022:19162:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"10022:19162:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \\\"memory view\\\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \\\"type\\\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ReceiptHarness.t.sol\":\"MemViewLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ReceiptHarness.t.sol\":{\"keccak256\":\"0x3ba212bbdc6831d0b39943a93abe224045c71b2078f41230e4a40455321659c4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ac3f7396377cba0f85792e07c04671a6063fe0ac89a3417cbb31d4fdcbc03aa7\",\"dweb:/ipfs/QmcASETFBmZGfcxskjs4g2Yuf571MTzM6Q3JHNbYkf5bpk\"]}},\"version\":1}"},"hashes":{}},"solidity/ReceiptHarness.t.sol:ReceiptHarness":{"code":"0x608060405234801561001057600080fd5b50610c09806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063854dfcd71161008c578063cb3eb0e111610066578063cb3eb0e1146102f5578063e152a8cb14610308578063ed54c3b61461031b578063f7e6a05b1461032e57600080fd5b8063854dfcd7146101db578063c3bfda6c146101ee578063c81aa9c8146102cd57600080fd5b8063595271d1116100c8578063595271d1146101625780635cab5d3b1461018757806360cf3bf0146101a7578063730dbf63146101c857600080fd5b80630bb3b580146100ef578063137e618a1461011757806327f2ee361461012a575b600080fd5b6101026100fd3660046109c6565b610341565b60405190151581526020015b60405180910390f35b6101026101253660046109fb565b61036d565b61013d6101383660046109c6565b61039c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010e565b6101756101703660046109c6565b6103af565b60405160ff909116815260200161010e565b61019a6101953660046109c6565b6103c2565b60405161010e9190610a5f565b6101ba6101b53660046109c6565b6103da565b60405190815260200161010e565b6101ba6101d63660046109c6565b6103f0565b6101ba6101e93660046109c6565b610406565b61019a6101fc366004610b08565b6040805160e0998a1b7fffffffff0000000000000000000000000000000000000000000000000000000090811660208301529890991b90971660248901526028880195909552604887019390935260f89190911b7fff00000000000000000000000000000000000000000000000000000000000000166068860152606090811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116606987015291811b8216607d8601529190911b1660918301528051608581840301815260a5909201905290565b6102e06102db3660046109c6565b610419565b60405163ffffffff909116815260200161010e565b6102e06103033660046109c6565b61042c565b61013d6103163660046109c6565b61043f565b6101ba6103293660046109c6565b610452565b61013d61033c3660046109c6565b610465565b600061036761034f83610478565b6fffffffffffffffffffffffffffffffff1660851490565b92915050565b600061039561038361037e84610478565b610493565b61038f61037e86610478565b906104e5565b9392505050565b60006103676103aa83610501565b61050f565b60006103676103bd83610501565b61051e565b606060006103cf83610501565b905061039581610530565b60006103676103eb61037e84610478565b61058d565b600061036761040161037e84610478565b6105bb565b600061036761041483610501565b6105e7565b600061036761042783610501565b6105f9565b600061036761043a83610501565b610607565b600061036761044d83610501565b610615565b600061036761046083610501565b610622565b600061036761047383610501565b610631565b80516000906020830161048b818361063e565b949350505050565b600060856fffffffffffffffffffffffffffffffff8316146104e1576040517f76b4e13c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b60006104f0826106a1565b6104f9846106a1565b149392505050565b600061036761037e83610478565b6000610367605d835b906106cc565b600061036760486001845b91906106d6565b6040518061054183602083016106f7565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60006103677fdf42b2c0137811ba604f5c79e20c4d6b94770aa819cc524eca444056544f8ab7835b906107a6565b60006103677fb38669e8ca41a27fcd85729b868e8ab047d0f142073a017213e58f0a91e88ef3836105b5565b600061036760286020845b91906107e2565b600061036760048084610529565b600061036781600484610529565b6000610367604983610518565b600061036760086020846105f2565b6000610367607183610518565b60008061064b8385610b99565b905060405181111561065b575060005b80600003610695576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b831761048b565b6000806106ae8360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b6000610395838360145b6000806106e48585856107e2565b602084900360031b1c9150509392505050565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610751576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610794576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b6000816107b2846106a1565b60408051602081019390935282015260600160405160208183030381529060405280519060200120905092915050565b6000816000036107f457506000610395565b602082111561082f576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661084c8385610b99565b1115610884576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006108958660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261092c57600080fd5b813567ffffffffffffffff80821115610947576109476108ec565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561098d5761098d6108ec565b816040528381528660208588010111156109a657600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156109d857600080fd5b813567ffffffffffffffff8111156109ef57600080fd5b61048b8482850161091b565b60008060408385031215610a0e57600080fd5b823567ffffffffffffffff80821115610a2657600080fd5b610a328683870161091b565b93506020850135915080821115610a4857600080fd5b50610a558582860161091b565b9150509250929050565b600060208083528351808285015260005b81811015610a8c57858101830151858201604001528201610a70565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b803563ffffffff81168114610adf57600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610adf57600080fd5b600080600080600080600080610100898b031215610b2557600080fd5b610b2e89610acb565b9750610b3c60208a01610acb565b96506040890135955060608901359450608089013560ff81168114610b6057600080fd5b9350610b6e60a08a01610ae4565b9250610b7c60c08a01610ae4565b9150610b8a60e08a01610ae4565b90509295985092959890939650565b80820180821115610367577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea2646970667358221220b93caf0b14f17123f7eaf8f533297a403221cbafb5d951eac6f5799eb185fad864736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063854dfcd71161008c578063cb3eb0e111610066578063cb3eb0e1146102f5578063e152a8cb14610308578063ed54c3b61461031b578063f7e6a05b1461032e57600080fd5b8063854dfcd7146101db578063c3bfda6c146101ee578063c81aa9c8146102cd57600080fd5b8063595271d1116100c8578063595271d1146101625780635cab5d3b1461018757806360cf3bf0146101a7578063730dbf63146101c857600080fd5b80630bb3b580146100ef578063137e618a1461011757806327f2ee361461012a575b600080fd5b6101026100fd3660046109c6565b610341565b60405190151581526020015b60405180910390f35b6101026101253660046109fb565b61036d565b61013d6101383660046109c6565b61039c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010e565b6101756101703660046109c6565b6103af565b60405160ff909116815260200161010e565b61019a6101953660046109c6565b6103c2565b60405161010e9190610a5f565b6101ba6101b53660046109c6565b6103da565b60405190815260200161010e565b6101ba6101d63660046109c6565b6103f0565b6101ba6101e93660046109c6565b610406565b61019a6101fc366004610b08565b6040805160e0998a1b7fffffffff0000000000000000000000000000000000000000000000000000000090811660208301529890991b90971660248901526028880195909552604887019390935260f89190911b7fff00000000000000000000000000000000000000000000000000000000000000166068860152606090811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116606987015291811b8216607d8601529190911b1660918301528051608581840301815260a5909201905290565b6102e06102db3660046109c6565b610419565b60405163ffffffff909116815260200161010e565b6102e06103033660046109c6565b61042c565b61013d6103163660046109c6565b61043f565b6101ba6103293660046109c6565b610452565b61013d61033c3660046109c6565b610465565b600061036761034f83610478565b6fffffffffffffffffffffffffffffffff1660851490565b92915050565b600061039561038361037e84610478565b610493565b61038f61037e86610478565b906104e5565b9392505050565b60006103676103aa83610501565b61050f565b60006103676103bd83610501565b61051e565b606060006103cf83610501565b905061039581610530565b60006103676103eb61037e84610478565b61058d565b600061036761040161037e84610478565b6105bb565b600061036761041483610501565b6105e7565b600061036761042783610501565b6105f9565b600061036761043a83610501565b610607565b600061036761044d83610501565b610615565b600061036761046083610501565b610622565b600061036761047383610501565b610631565b80516000906020830161048b818361063e565b949350505050565b600060856fffffffffffffffffffffffffffffffff8316146104e1576040517f76b4e13c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b60006104f0826106a1565b6104f9846106a1565b149392505050565b600061036761037e83610478565b6000610367605d835b906106cc565b600061036760486001845b91906106d6565b6040518061054183602083016106f7565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60006103677fdf42b2c0137811ba604f5c79e20c4d6b94770aa819cc524eca444056544f8ab7835b906107a6565b60006103677fb38669e8ca41a27fcd85729b868e8ab047d0f142073a017213e58f0a91e88ef3836105b5565b600061036760286020845b91906107e2565b600061036760048084610529565b600061036781600484610529565b6000610367604983610518565b600061036760086020846105f2565b6000610367607183610518565b60008061064b8385610b99565b905060405181111561065b575060005b80600003610695576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b831761048b565b6000806106ae8360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b6000610395838360145b6000806106e48585856107e2565b602084900360031b1c9150509392505050565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610751576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610794576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b6000816107b2846106a1565b60408051602081019390935282015260600160405160208183030381529060405280519060200120905092915050565b6000816000036107f457506000610395565b602082111561082f576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661084c8385610b99565b1115610884576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006108958660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261092c57600080fd5b813567ffffffffffffffff80821115610947576109476108ec565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561098d5761098d6108ec565b816040528381528660208588010111156109a657600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156109d857600080fd5b813567ffffffffffffffff8111156109ef57600080fd5b61048b8482850161091b565b60008060408385031215610a0e57600080fd5b823567ffffffffffffffff80821115610a2657600080fd5b610a328683870161091b565b93506020850135915080821115610a4857600080fd5b50610a558582860161091b565b9150509250929050565b600060208083528351808285015260005b81811015610a8c57858101830151858201604001528201610a70565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b803563ffffffff81168114610adf57600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610adf57600080fd5b600080600080600080600080610100898b031215610b2557600080fd5b610b2e89610acb565b9750610b3c60208a01610acb565b96506040890135955060608901359450608089013560ff81168114610b6057600080fd5b9350610b6e60a08a01610ae4565b9250610b7c60c08a01610ae4565b9150610b8a60e08a01610ae4565b90509295985092959890939650565b80820180821115610367577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea2646970667358221220b93caf0b14f17123f7eaf8f533297a403221cbafb5d951eac6f5799eb185fad864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\n// contracts/libs/Constants.sol\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Timeout between the agent root could be proposed and resolved in LightManager\nuint32 constant AGENT_ROOT_PROPOSAL_TIMEOUT = 12 hours;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time that the Notary will not be considered active after they won a dispute\nuint32 constant DISPUTE_TIMEOUT_NOTARY = 12 hours;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Maximum value for the summit tip that could be set in GasOracle\nuint256 constant MAX_SUMMIT_TIP = 0.01 ether;\n\n// contracts/libs/Errors.sol\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectAgentRoot();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror AgentRootNotProposed();\nerror AgentRootTimeoutNotOver();\n\nerror NotStuck();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeTimeoutNotOver();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror SummitTipTooHigh();\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n// contracts/libs/memory/MemView.sol\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// contracts/libs/memory/Receipt.sol\n\n/// Receipt is a memory view over a formatted \"full receipt\" payload.\ntype Receipt is uint256;\n\nusing ReceiptLib for Receipt global;\n\n/// Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`.\n/// - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not\n///   included in the receipt.\n/// - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an\n///   executed message.\n/// - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this\n///   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both\n///   receipts will be considered valid.\n/// # Memory layout of Receipt fields\n///\n/// | Position   | Field         | Type    | Bytes | Description                                      |\n/// | ---------- | ------------- | ------- | ----- | ------------------------------------------------ |\n/// | [000..004) | origin        | uint32  | 4     | Domain where message originated                  |\n/// | [004..008) | destination   | uint32  | 4     | Domain where message was executed                |\n/// | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              |\n/// | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       |\n/// | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       |\n/// | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root |\n/// | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     |\n/// | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\nlibrary ReceiptLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_DESTINATION = 4;\n    uint256 private constant OFFSET_MESSAGE_HASH = 8;\n    uint256 private constant OFFSET_SNAPSHOT_ROOT = 40;\n    uint256 private constant OFFSET_STATE_INDEX = 72;\n    uint256 private constant OFFSET_ATT_NOTARY = 73;\n    uint256 private constant OFFSET_FIRST_EXECUTOR = 93;\n    uint256 private constant OFFSET_FINAL_EXECUTOR = 113;\n\n    // ═════════════════════════════════════════════════ RECEIPT ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Receipt payload with provided fields.\n     * @param origin_           Domain where message originated\n     * @param destination_      Domain where message was executed\n     * @param messageHash_      Hash of the message\n     * @param snapshotRoot_     Snapshot root used for proving the message\n     * @param stateIndex_       Index of state used for the snapshot proof\n     * @param attNotary_        Notary who posted attestation with snapshot root\n     * @param firstExecutor_    Executor who performed first valid execution attempt\n     * @param finalExecutor_    Executor who successfully executed the message\n     * @return Formatted receipt\n     */\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n\n    /**\n     * @notice Returns a Receipt view over the given payload.\n     * @dev Will revert if the payload is not a receipt.\n     */\n    function castToReceipt(bytes memory payload) internal pure returns (Receipt) {\n        return castToReceipt(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Receipt view.\n     * @dev Will revert if the memory view is not over a receipt.\n     */\n    function castToReceipt(MemView memView) internal pure returns (Receipt) {\n        if (!isReceipt(memView)) revert UnformattedReceipt();\n        return Receipt.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Receipt.\n    function isReceipt(MemView memView) internal pure returns (bool) {\n        // Check payload length\n        return memView.len() == RECEIPT_LENGTH;\n    }\n\n    /// @notice Returns the hash of an Receipt, that could be later signed by a Notary to signal\n    /// that the receipt is valid.\n    function hashValid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_VALID_SALT);\n    }\n\n    /// @notice Returns the hash of a Receipt, that could be later signed by a Guard to signal\n    /// that the receipt is invalid.\n    function hashInvalid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptBodyInvalidSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_INVALID_SALT);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Receipt receipt) internal pure returns (MemView) {\n        return MemView.wrap(Receipt.unwrap(receipt));\n    }\n\n    /// @notice Compares two Receipt structures.\n    function equals(Receipt a, Receipt b) internal pure returns (bool) {\n        // Length of a Receipt payload is fixed, so we just need to compare the hashes\n        return a.unwrap().keccak() == b.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ RECEIPT SLICING ═════════════════════════════════════════════════\n\n    /// @notice Returns receipt's origin field\n    function origin(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_ORIGIN, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_DESTINATION, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_MESSAGE_HASH, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_SNAPSHOT_ROOT, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(Receipt receipt) internal pure returns (uint8) {\n        // Can be safely casted to uint8, since we index a single byte\n        return uint8(receipt.unwrap().indexUint({index_: OFFSET_STATE_INDEX, bytes_: 1}));\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_ATT_NOTARY});\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FIRST_EXECUTOR});\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FINAL_EXECUTOR});\n    }\n}\n\n// test/harnesses/libs/memory/ReceiptHarness.t.sol\n\n// solhint-disable ordering\ncontract ReceiptHarness {\n    using ReceiptLib for bytes;\n    using ReceiptLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToReceipt(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Receipt receipt = ReceiptLib.castToReceipt(payload);\n        return receipt.unwrap().clone();\n    }\n\n    /// @notice Returns receipt's origin field\n    function origin(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().origin();\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().destination();\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().messageHash();\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().snapshotRoot();\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(bytes memory payload) public pure returns (uint8) {\n        return payload.castToReceipt().stateIndex();\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().attNotary();\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().firstExecutor();\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().finalExecutor();\n    }\n\n    function equals(bytes memory a, bytes memory b) public pure returns (bool) {\n        return a.ref().castToReceipt().equals(b.ref().castToReceipt());\n    }\n\n    function isReceipt(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isReceipt();\n    }\n\n    function hashValid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashValid();\n    }\n\n    function hashInvalid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashInvalid();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) public pure returns (bytes memory) {\n        return ReceiptLib.formatReceipt(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"37551:3867:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"37551:3867:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;40205:117;;;;;;:::i;:::-;;:::i;:::-;;;1475:14:1;;1468:22;1450:41;;1438:2;1423:18;40205:117:0;;;;;;;;40045:154;;;;;;:::i;:::-;;:::i;39700:138::-;;;;;;:::i;:::-;;:::i;:::-;;;2222:42:1;2210:55;;;2192:74;;2180:2;2165:18;39700:138:0;2046:226:1;39310:130:0;;;;;;:::i;:::-;;:::i;:::-;;;2449:4:1;2437:17;;;2419:36;;2407:2;2392:18;39310:130:0;2277:184:1;38144:346:0;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;40470:140::-;;;;;;:::i;:::-;;:::i;:::-;;;3222:25:1;;;3210:2;3195:18;40470:140:0;3076:177:1;40328:136:0;;;;;;:::i;:::-;;:::i;39114:::-;;;;;;:::i;:::-;;:::i;40940:476::-;;;;;;:::i;:::-;33023:147;;;5027:3:1;5023:16;;;4932:66;5019:25;;;33023:147:0;;;5007:38:1;5078:16;;;;5074:25;;;5061:11;;;5054:46;5116:11;;;5109:27;;;;5152:12;;;5145:28;;;;5211:3;5207:16;;;;5225:66;5203:89;5189:12;;;5182:111;41223:12:0;5412:15:1;;;5312:66;5408:24;;;5394:12;;;5387:46;5467:15;;;5463:24;;5449:12;;;5442:46;5523:15;;;;5519:24;5504:13;;;5497:47;33023:147:0;;;;;;;;;5560:13:1;;;;33023:147:0;;;40940:476;38724:133;;;;;;:::i;:::-;;:::i;:::-;;;4582:10:1;4570:23;;;4552:42;;4540:2;4525:18;38724:133:0;4408:192:1;38543:123:0;;;;;;:::i;:::-;;:::i;39507:130::-;;;;;;:::i;:::-;;:::i;38918:134::-;;;;;;:::i;:::-;;:::i;39901:138::-;;;;;;:::i;:::-;;:::i;40205:117::-;40267:4;40290:25;:13;:7;:11;:13::i;:::-;16054:17;16028:43;1289:3;33966:31;;33852:152;40290:25;40283:32;40205:117;-1:-1:-1;;40205:117:0:o;40045:154::-;40114:4;40137:55;40168:23;:7;:1;:5;:7::i;:::-;:21;:23::i;:::-;40137;:7;:1;:5;:7::i;:23::-;:30;;:55::i;:::-;40130:62;40045:154;-1:-1:-1;;;40045:154:0:o;39700:138::-;39766:7;39792:39;:23;:7;:21;:23::i;:::-;:37;:39::i;39310:130::-;39373:5;39397:36;:23;:7;:21;:23::i;:::-;:34;:36::i;38144:346::-;38210:12;38391:15;38409:33;38434:7;38409:24;:33::i;:::-;38391:51;-1:-1:-1;38459:24:0;38391:51;38459:22;:24::i;40470:140::-;40534:7;40560:43;:29;:13;:7;:11;:13::i;:29::-;:41;:43::i;40328:136::-;40390:7;40416:41;:29;:13;:7;:11;:13::i;:29::-;:39;:41::i;39114:136::-;39179:7;39205:38;:23;:7;:21;:23::i;:::-;:36;:38::i;38724:133::-;38788:6;38813:37;:23;:7;:21;:23::i;:::-;:35;:37::i;38543:123::-;38602:6;38627:32;:23;:7;:21;:23::i;:::-;:30;:32::i;39507:130::-;39569:7;39595:35;:23;:7;:21;:23::i;:::-;:33;:35::i;38918:134::-;38982:7;39008:37;:23;:7;:21;:23::i;:::-;:35;:37::i;39901:138::-;39967:7;39993:39;:23;:7;:21;:23::i;:::-;:37;:39::i;11761:569::-;11849:10;;11815:7;;12275:4;12266:14;;12306:17;12266:14;11849:10;12306:5;:17::i;:::-;12299:24;11761:569;-1:-1:-1;;;;11761:569:0:o;33589:195::-;33652:7;1289:3;16054:17;16028:43;;33966:31;33671:52;;33703:20;;;;;;;;;;;;;;33671:52;-1:-1:-1;33768:7:0;33589:195::o;34972:220::-;35033:4;35166:19;:1;:17;:19::i;:::-;35143;:1;35166:17;:19::i;35143:::-;:42;;34972:220;-1:-1:-1;;;34972:220:0:o;33318:129::-;33386:7;33412:28;33426:13;:7;:11;:13::i;37088:158::-;37151:7;37177:62;31617:2;37177:7;:16;:29;;:62::i;36572:236::-;36632:5;36733:67;31507:2;36797:1;36733:7;:16;:26;:67;:26;:67::i;12868:1041::-;13114:4;13108:11;;13244:34;13258:7;13273:4;13267:10;;13244:13;:34::i;:::-;-1:-1:-1;16054:17:0;16028:43;;13490:12;16886:2;16870:18;;17254:20;;13786;;13808:4;13782:31;13776:4;13769:45;-1:-1:-1;13876:17:0;;12868:1041;;-1:-1:-1;12868:1041:0:o;34495:230::-;34556:7;34667:51;2884:33;34667:7;:16;:29;;:51::i;34142:215::-;34201:7;34301:49;2811:31;34301:7;:16;34791:126;36351:161;36413:7;36439:66;31453:2;36501;36439:7;:16;:22;:66;:22;:66::i;35835:234::-;35896:6;35994:67;31344:1;;35994:7;:16;34791:126;35553:224;35609:6;35707:62;35609:6;35766:1;35707:7;:16;34791:126;36875:150;36934:7;36960:58;31560:2;36960:7;:16;34791:126;36130:159;36191:7;36217:65;31398:1;36278:2;36217:7;:16;34791:126;37309:158;37372:7;37398:62;31674:3;37398:7;:16;34791:126;10881:540;10947:7;;10981:11;10988:4;10981;:11;:::i;:::-;10966:26;;11260:4;11254:11;11248:4;11245:21;11242:38;;;-1:-1:-1;11277:1:0;11242:38;11303:4;11311:1;11303:9;11299:66;;11335:19;;;;;;;;;;;;;;11299:66;26151:3;26143:11;;;26142:20;;11381:33;25818:352;17792:292;17848:14;17874:12;17889:13;:7;15687:3;15660:30;;15501:196;17889:13;16054:17;16028:43;;;;18047:21;;;;;-1:-1:-1;;17792:292:0:o;25142:225::-;25220:7;25329:29;:7;25347:6;25355:2;24341:538;24432:7;;24474:29;:7;24488:6;24496;24474:13;:29::i;:::-;24844:2;:11;;;24860:1;24843:18;24817:45;;-1:-1:-1;;24341:538:0;;;;;:::o;26802:842::-;27141:4;27135:11;26880:7;;16054:17;16028:43;;;15687:3;15660:30;;;;27223:12;;;27219:66;;;27258:16;;;;;;;;;;;;;;27219:66;27294:8;27510:4;27502:6;27496:4;27488:6;27482:4;27475:5;27464:51;27457:58;;27539:3;27534:37;;27551:20;;;;;;;;;;;;;;27534:37;26151:3;26143:11;;;26142:20;;27581:56;26802:842;-1:-1:-1;;;;;;;26802:842:0:o;18347:169::-;18423:20;18485:4;18491:16;:7;:14;:16::i;:::-;18472:36;;;;;;6025:19:1;;;;6060:12;;6053:28;6097:12;;18472:36:0;;;;;;;;;;;;18462:47;;;;;;18455:54;;18347:169;;;;:::o;22649:1334::-;22736:14;22766:6;22776:1;22766:11;22762:59;;-1:-1:-1;22808:1:0;22793:17;;22762:59;22907:2;22898:6;:11;22894:65;;;22932:16;;;;;;;;;;;;;;22894:65;16054:17;16028:43;;23038:15;23047:6;23038;:15;:::i;:::-;:31;23034:82;;;23092:13;;;;;;;;;;;;;;23034:82;23155:1;23145:11;;;23125:17;23195:13;:7;15687:3;15660:30;;15501:196;23195:13;23942:17;;;23936:24;23653:66;23634:17;;;;;23630:90;;;;23932:35;;22649:1334;-1:-1:-1;;;;22649:1334:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1502:539::-;1588:6;1596;1649:2;1637:9;1628:7;1624:23;1620:32;1617:52;;;1665:1;1662;1655:12;1617:52;1705:9;1692:23;1734:18;1775:2;1767:6;1764:14;1761:34;;;1791:1;1788;1781:12;1761:34;1814:49;1855:7;1846:6;1835:9;1831:22;1814:49;:::i;:::-;1804:59;;1916:2;1905:9;1901:18;1888:32;1872:48;;1945:2;1935:8;1932:16;1929:36;;;1961:1;1958;1951:12;1929:36;;1984:51;2027:7;2016:8;2005:9;2001:24;1984:51;:::i;:::-;1974:61;;;1502:539;;;;;:::o;2466:605::-;2576:4;2605:2;2634;2623:9;2616:21;2666:6;2660:13;2709:6;2704:2;2693:9;2689:18;2682:34;2734:1;2744:140;2758:6;2755:1;2752:13;2744:140;;;2853:14;;;2849:23;;2843:30;2819:17;;;2838:2;2815:26;2808:66;2773:10;;2744:140;;;2748:3;2933:1;2928:2;2919:6;2908:9;2904:22;2900:31;2893:42;3062:2;2992:66;2987:2;2979:6;2975:15;2971:88;2960:9;2956:104;2952:113;2944:121;;;;2466:605;;;;:::o;3258:163::-;3325:20;;3385:10;3374:22;;3364:33;;3354:61;;3411:1;3408;3401:12;3354:61;3258:163;;;:::o;3426:196::-;3494:20;;3554:42;3543:54;;3533:65;;3523:93;;3612:1;3609;3602:12;3627:776;3745:6;3753;3761;3769;3777;3785;3793;3801;3854:3;3842:9;3833:7;3829:23;3825:33;3822:53;;;3871:1;3868;3861:12;3822:53;3894:28;3912:9;3894:28;:::i;:::-;3884:38;;3941:37;3974:2;3963:9;3959:18;3941:37;:::i;:::-;3931:47;;4025:2;4014:9;4010:18;3997:32;3987:42;;4076:2;4065:9;4061:18;4048:32;4038:42;;4130:3;4119:9;4115:19;4102:33;4175:4;4168:5;4164:16;4157:5;4154:27;4144:55;;4195:1;4192;4185:12;4144:55;4218:5;-1:-1:-1;4242:39:1;4276:3;4261:19;;4242:39;:::i;:::-;4232:49;;4300:39;4334:3;4323:9;4319:19;4300:39;:::i;:::-;4290:49;;4358:39;4392:3;4381:9;4377:19;4358:39;:::i;:::-;4348:49;;3627:776;;;;;;;;;;;:::o;5584:279::-;5649:9;;;5670:10;;;5667:190;;;5713:77;5710:1;5703:88;5814:4;5811:1;5804:15;5842:4;5839:1;5832:15","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"UnformattedReceipt","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"attNotary","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToReceipt","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"a","type":"bytes"},{"internalType":"bytes","name":"b","type":"bytes"}],"name":"equals","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"finalExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"firstExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"origin_","type":"uint32"},{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"bytes32","name":"messageHash_","type":"bytes32"},{"internalType":"bytes32","name":"snapshotRoot_","type":"bytes32"},{"internalType":"uint8","name":"stateIndex_","type":"uint8"},{"internalType":"address","name":"attNotary_","type":"address"},{"internalType":"address","name":"firstExecutor_","type":"address"},{"internalType":"address","name":"finalExecutor_","type":"address"}],"name":"formatReceipt","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"hashInvalid","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"hashValid","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isReceipt","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"messageHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"snapshotRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"stateIndex","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"attNotary(bytes)":{"notice":"Returns receipt's \"attestation notary\" field"},"destination(bytes)":{"notice":"Returns receipt's destination field"},"finalExecutor(bytes)":{"notice":"Returns receipt's \"final executor\" field"},"firstExecutor(bytes)":{"notice":"Returns receipt's \"first executor\" field"},"messageHash(bytes)":{"notice":"Returns receipt's \"message hash\" field"},"origin(bytes)":{"notice":"Returns receipt's origin field"},"snapshotRoot(bytes)":{"notice":"Returns receipt's \"snapshot root\" field"},"stateIndex(bytes)":{"notice":"Returns receipt's \"state index\" field"}},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnformattedReceipt\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"attNotary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"a\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"equals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"finalExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"firstExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"snapshotRoot_\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"stateIndex_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attNotary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"firstExecutor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"finalExecutor_\",\"type\":\"address\"}],\"name\":\"formatReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"hashInvalid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"hashValid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isReceipt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"messageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"snapshotRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"stateIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"attNotary(bytes)\":{\"notice\":\"Returns receipt's \\\"attestation notary\\\" field\"},\"destination(bytes)\":{\"notice\":\"Returns receipt's destination field\"},\"finalExecutor(bytes)\":{\"notice\":\"Returns receipt's \\\"final executor\\\" field\"},\"firstExecutor(bytes)\":{\"notice\":\"Returns receipt's \\\"first executor\\\" field\"},\"messageHash(bytes)\":{\"notice\":\"Returns receipt's \\\"message hash\\\" field\"},\"origin(bytes)\":{\"notice\":\"Returns receipt's origin field\"},\"snapshotRoot(bytes)\":{\"notice\":\"Returns receipt's \\\"snapshot root\\\" field\"},\"stateIndex(bytes)\":{\"notice\":\"Returns receipt's \\\"state index\\\" field\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ReceiptHarness.t.sol\":\"ReceiptHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ReceiptHarness.t.sol\":{\"keccak256\":\"0x3ba212bbdc6831d0b39943a93abe224045c71b2078f41230e4a40455321659c4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ac3f7396377cba0f85792e07c04671a6063fe0ac89a3417cbb31d4fdcbc03aa7\",\"dweb:/ipfs/QmcASETFBmZGfcxskjs4g2Yuf571MTzM6Q3JHNbYkf5bpk\"]}},\"version\":1}"},"hashes":{"attNotary(bytes)":"e152a8cb","castToReceipt(bytes)":"5cab5d3b","destination(bytes)":"c81aa9c8","equals(bytes,bytes)":"137e618a","finalExecutor(bytes)":"f7e6a05b","firstExecutor(bytes)":"27f2ee36","formatReceipt(uint32,uint32,bytes32,bytes32,uint8,address,address,address)":"c3bfda6c","hashInvalid(bytes)":"60cf3bf0","hashValid(bytes)":"730dbf63","isReceipt(bytes)":"0bb3b580","messageHash(bytes)":"ed54c3b6","origin(bytes)":"cb3eb0e1","snapshotRoot(bytes)":"854dfcd7","stateIndex(bytes)":"595271d1"}},"solidity/ReceiptHarness.t.sol:ReceiptLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122033acc2a263c77f7eca8fa40f9b4091c06953c904198db594fc51cf6274efde9d64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122033acc2a263c77f7eca8fa40f9b4091c06953c904198db594fc51cf6274efde9d64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\n// contracts/libs/Constants.sol\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Timeout between the agent root could be proposed and resolved in LightManager\nuint32 constant AGENT_ROOT_PROPOSAL_TIMEOUT = 12 hours;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time that the Notary will not be considered active after they won a dispute\nuint32 constant DISPUTE_TIMEOUT_NOTARY = 12 hours;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Maximum value for the summit tip that could be set in GasOracle\nuint256 constant MAX_SUMMIT_TIP = 0.01 ether;\n\n// contracts/libs/Errors.sol\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectAgentRoot();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror AgentRootNotProposed();\nerror AgentRootTimeoutNotOver();\n\nerror NotStuck();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeTimeoutNotOver();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror SummitTipTooHigh();\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n// contracts/libs/memory/MemView.sol\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// contracts/libs/memory/Receipt.sol\n\n/// Receipt is a memory view over a formatted \"full receipt\" payload.\ntype Receipt is uint256;\n\nusing ReceiptLib for Receipt global;\n\n/// Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`.\n/// - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not\n///   included in the receipt.\n/// - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an\n///   executed message.\n/// - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this\n///   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both\n///   receipts will be considered valid.\n/// # Memory layout of Receipt fields\n///\n/// | Position   | Field         | Type    | Bytes | Description                                      |\n/// | ---------- | ------------- | ------- | ----- | ------------------------------------------------ |\n/// | [000..004) | origin        | uint32  | 4     | Domain where message originated                  |\n/// | [004..008) | destination   | uint32  | 4     | Domain where message was executed                |\n/// | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              |\n/// | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       |\n/// | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       |\n/// | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root |\n/// | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     |\n/// | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\nlibrary ReceiptLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_DESTINATION = 4;\n    uint256 private constant OFFSET_MESSAGE_HASH = 8;\n    uint256 private constant OFFSET_SNAPSHOT_ROOT = 40;\n    uint256 private constant OFFSET_STATE_INDEX = 72;\n    uint256 private constant OFFSET_ATT_NOTARY = 73;\n    uint256 private constant OFFSET_FIRST_EXECUTOR = 93;\n    uint256 private constant OFFSET_FINAL_EXECUTOR = 113;\n\n    // ═════════════════════════════════════════════════ RECEIPT ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Receipt payload with provided fields.\n     * @param origin_           Domain where message originated\n     * @param destination_      Domain where message was executed\n     * @param messageHash_      Hash of the message\n     * @param snapshotRoot_     Snapshot root used for proving the message\n     * @param stateIndex_       Index of state used for the snapshot proof\n     * @param attNotary_        Notary who posted attestation with snapshot root\n     * @param firstExecutor_    Executor who performed first valid execution attempt\n     * @param finalExecutor_    Executor who successfully executed the message\n     * @return Formatted receipt\n     */\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n\n    /**\n     * @notice Returns a Receipt view over the given payload.\n     * @dev Will revert if the payload is not a receipt.\n     */\n    function castToReceipt(bytes memory payload) internal pure returns (Receipt) {\n        return castToReceipt(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Receipt view.\n     * @dev Will revert if the memory view is not over a receipt.\n     */\n    function castToReceipt(MemView memView) internal pure returns (Receipt) {\n        if (!isReceipt(memView)) revert UnformattedReceipt();\n        return Receipt.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Receipt.\n    function isReceipt(MemView memView) internal pure returns (bool) {\n        // Check payload length\n        return memView.len() == RECEIPT_LENGTH;\n    }\n\n    /// @notice Returns the hash of an Receipt, that could be later signed by a Notary to signal\n    /// that the receipt is valid.\n    function hashValid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_VALID_SALT);\n    }\n\n    /// @notice Returns the hash of a Receipt, that could be later signed by a Guard to signal\n    /// that the receipt is invalid.\n    function hashInvalid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptBodyInvalidSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_INVALID_SALT);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Receipt receipt) internal pure returns (MemView) {\n        return MemView.wrap(Receipt.unwrap(receipt));\n    }\n\n    /// @notice Compares two Receipt structures.\n    function equals(Receipt a, Receipt b) internal pure returns (bool) {\n        // Length of a Receipt payload is fixed, so we just need to compare the hashes\n        return a.unwrap().keccak() == b.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ RECEIPT SLICING ═════════════════════════════════════════════════\n\n    /// @notice Returns receipt's origin field\n    function origin(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_ORIGIN, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_DESTINATION, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_MESSAGE_HASH, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_SNAPSHOT_ROOT, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(Receipt receipt) internal pure returns (uint8) {\n        // Can be safely casted to uint8, since we index a single byte\n        return uint8(receipt.unwrap().indexUint({index_: OFFSET_STATE_INDEX, bytes_: 1}));\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_ATT_NOTARY});\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FIRST_EXECUTOR});\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FINAL_EXECUTOR});\n    }\n}\n\n// test/harnesses/libs/memory/ReceiptHarness.t.sol\n\n// solhint-disable ordering\ncontract ReceiptHarness {\n    using ReceiptLib for bytes;\n    using ReceiptLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToReceipt(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Receipt receipt = ReceiptLib.castToReceipt(payload);\n        return receipt.unwrap().clone();\n    }\n\n    /// @notice Returns receipt's origin field\n    function origin(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().origin();\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().destination();\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().messageHash();\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().snapshotRoot();\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(bytes memory payload) public pure returns (uint8) {\n        return payload.castToReceipt().stateIndex();\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().attNotary();\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().firstExecutor();\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().finalExecutor();\n    }\n\n    function equals(bytes memory a, bytes memory b) public pure returns (bool) {\n        return a.ref().castToReceipt().equals(b.ref().castToReceipt());\n    }\n\n    function isReceipt(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isReceipt();\n    }\n\n    function hashValid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashValid();\n    }\n\n    function hashInvalid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashInvalid();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) public pure returns (bytes memory) {\n        return ReceiptLib.formatReceipt(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"31098:6371:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;31098:6371:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"31098:6371:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`. - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not   included in the receipt. - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an   executed message. - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both   receipts will be considered valid. # Memory layout of Receipt fields | Position   | Field         | Type    | Bytes | Description                                      | | ---------- | ------------- | ------- | ----- | ------------------------------------------------ | | [000..004) | origin        | uint32  | 4     | Domain where message originated                  | | [004..008) | destination   | uint32  | 4     | Domain where message was executed                | | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              | | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       | | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       | | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root | | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     | | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`. - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not   included in the receipt. - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an   executed message. - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both   receipts will be considered valid. # Memory layout of Receipt fields | Position   | Field         | Type    | Bytes | Description                                      | | ---------- | ------------- | ------- | ----- | ------------------------------------------------ | | [000..004) | origin        | uint32  | 4     | Domain where message originated                  | | [004..008) | destination   | uint32  | 4     | Domain where message was executed                | | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              | | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       | | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       | | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root | | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     | | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ReceiptHarness.t.sol\":\"ReceiptLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ReceiptHarness.t.sol\":{\"keccak256\":\"0x3ba212bbdc6831d0b39943a93abe224045c71b2078f41230e4a40455321659c4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ac3f7396377cba0f85792e07c04671a6063fe0ac89a3417cbb31d4fdcbc03aa7\",\"dweb:/ipfs/QmcASETFBmZGfcxskjs4g2Yuf571MTzM6Q3JHNbYkf5bpk\"]}},\"version\":1}"},"hashes":{}}}