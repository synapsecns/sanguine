{"solidity/ReceiptHarness.t.sol:MemViewLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208c9ff5c8ae0945b0c310bf8ac4023f902435a7617ef72f632817973b5b0ac26664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208c9ff5c8ae0945b0c310bf8ac4023f902435a7617ef72f632817973b5b0ac26664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectAgentRoot();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror AgentRootNotProposed();\nerror AgentRootTimeoutNotOver();\n\nerror NotStuck();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeTimeoutNotOver();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror SummitTipTooHigh();\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Timeout between the agent root could be proposed and resolved in LightManager\nuint32 constant AGENT_ROOT_PROPOSAL_TIMEOUT = 12 hours;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time that the Notary will not be considered active after they won a dispute\nuint32 constant DISPUTE_TIMEOUT_NOTARY = 12 hours;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Maximum value for the summit tip that could be set in GasOracle\nuint256 constant MAX_SUMMIT_TIP = 0.01 ether;\n\n/// Receipt is a memory view over a formatted \"full receipt\" payload.\ntype Receipt is uint256;\n\nusing ReceiptLib for Receipt global;\n\n/// Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`.\n/// - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not\n///   included in the receipt.\n/// - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an\n///   executed message.\n/// - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this\n///   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both\n///   receipts will be considered valid.\n/// # Memory layout of Receipt fields\n///\n/// | Position   | Field         | Type    | Bytes | Description                                      |\n/// | ---------- | ------------- | ------- | ----- | ------------------------------------------------ |\n/// | [000..004) | origin        | uint32  | 4     | Domain where message originated                  |\n/// | [004..008) | destination   | uint32  | 4     | Domain where message was executed                |\n/// | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              |\n/// | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       |\n/// | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       |\n/// | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root |\n/// | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     |\n/// | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\nlibrary ReceiptLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_DESTINATION = 4;\n    uint256 private constant OFFSET_MESSAGE_HASH = 8;\n    uint256 private constant OFFSET_SNAPSHOT_ROOT = 40;\n    uint256 private constant OFFSET_STATE_INDEX = 72;\n    uint256 private constant OFFSET_ATT_NOTARY = 73;\n    uint256 private constant OFFSET_FIRST_EXECUTOR = 93;\n    uint256 private constant OFFSET_FINAL_EXECUTOR = 113;\n\n    // ═════════════════════════════════════════════════ RECEIPT ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Receipt payload with provided fields.\n     * @param origin_           Domain where message originated\n     * @param destination_      Domain where message was executed\n     * @param messageHash_      Hash of the message\n     * @param snapshotRoot_     Snapshot root used for proving the message\n     * @param stateIndex_       Index of state used for the snapshot proof\n     * @param attNotary_        Notary who posted attestation with snapshot root\n     * @param firstExecutor_    Executor who performed first valid execution attempt\n     * @param finalExecutor_    Executor who successfully executed the message\n     * @return Formatted receipt\n     */\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n\n    /**\n     * @notice Returns a Receipt view over the given payload.\n     * @dev Will revert if the payload is not a receipt.\n     */\n    function castToReceipt(bytes memory payload) internal pure returns (Receipt) {\n        return castToReceipt(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Receipt view.\n     * @dev Will revert if the memory view is not over a receipt.\n     */\n    function castToReceipt(MemView memView) internal pure returns (Receipt) {\n        if (!isReceipt(memView)) revert UnformattedReceipt();\n        return Receipt.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Receipt.\n    function isReceipt(MemView memView) internal pure returns (bool) {\n        // Check payload length\n        return memView.len() == RECEIPT_LENGTH;\n    }\n\n    /// @notice Returns the hash of an Receipt, that could be later signed by a Notary to signal\n    /// that the receipt is valid.\n    function hashValid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_VALID_SALT);\n    }\n\n    /// @notice Returns the hash of a Receipt, that could be later signed by a Guard to signal\n    /// that the receipt is invalid.\n    function hashInvalid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptBodyInvalidSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_INVALID_SALT);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Receipt receipt) internal pure returns (MemView) {\n        return MemView.wrap(Receipt.unwrap(receipt));\n    }\n\n    /// @notice Compares two Receipt structures.\n    function equals(Receipt a, Receipt b) internal pure returns (bool) {\n        // Length of a Receipt payload is fixed, so we just need to compare the hashes\n        return a.unwrap().keccak() == b.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ RECEIPT SLICING ═════════════════════════════════════════════════\n\n    /// @notice Returns receipt's origin field\n    function origin(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_ORIGIN, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_DESTINATION, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_MESSAGE_HASH, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_SNAPSHOT_ROOT, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(Receipt receipt) internal pure returns (uint8) {\n        // Can be safely casted to uint8, since we index a single byte\n        return uint8(receipt.unwrap().indexUint({index_: OFFSET_STATE_INDEX, bytes_: 1}));\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_ATT_NOTARY});\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FIRST_EXECUTOR});\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FINAL_EXECUTOR});\n    }\n}\n\n// solhint-disable ordering\ncontract ReceiptHarness {\n    using ReceiptLib for bytes;\n    using ReceiptLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToReceipt(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Receipt receipt = ReceiptLib.castToReceipt(payload);\n        return receipt.unwrap().clone();\n    }\n\n    /// @notice Returns receipt's origin field\n    function origin(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().origin();\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().destination();\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().messageHash();\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().snapshotRoot();\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(bytes memory payload) public pure returns (uint8) {\n        return payload.castToReceipt().stateIndex();\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().attNotary();\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().firstExecutor();\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().finalExecutor();\n    }\n\n    function equals(bytes memory a, bytes memory b) public pure returns (bool) {\n        return a.ref().castToReceipt().equals(b.ref().castToReceipt());\n    }\n\n    function isReceipt(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isReceipt();\n    }\n\n    function hashValid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashValid();\n    }\n\n    function hashInvalid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashInvalid();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) public pure returns (bytes memory) {\n        return ReceiptLib.formatReceipt(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"5863:19162:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5863:19162:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5863:19162:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \\\"memory view\\\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \\\"type\\\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ReceiptHarness.t.sol\":\"MemViewLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ReceiptHarness.t.sol\":{\"keccak256\":\"0x8df6c87bb556e30a8fb50acbd2820596e7b3cda12a6103ee8a853fe819c22e17\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://9b5ae9c447efb24bf3d2697a5d5955e08c435482c760b2276cb2902708d4a2fb\",\"dweb:/ipfs/QmNk3vsmECFcQidLwjq7oYvP5TiiFWMbmLmwUKzMwvsSRs\"]}},\"version\":1}"},"hashes":{}},"solidity/ReceiptHarness.t.sol:ReceiptHarness":{"code":"0x608060405234801561001057600080fd5b50610c09806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063854dfcd71161008c578063cb3eb0e111610066578063cb3eb0e1146102f5578063e152a8cb14610308578063ed54c3b61461031b578063f7e6a05b1461032e57600080fd5b8063854dfcd7146101db578063c3bfda6c146101ee578063c81aa9c8146102cd57600080fd5b8063595271d1116100c8578063595271d1146101625780635cab5d3b1461018757806360cf3bf0146101a7578063730dbf63146101c857600080fd5b80630bb3b580146100ef578063137e618a1461011757806327f2ee361461012a575b600080fd5b6101026100fd3660046109c6565b610341565b60405190151581526020015b60405180910390f35b6101026101253660046109fb565b61036d565b61013d6101383660046109c6565b61039c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010e565b6101756101703660046109c6565b6103af565b60405160ff909116815260200161010e565b61019a6101953660046109c6565b6103c2565b60405161010e9190610a5f565b6101ba6101b53660046109c6565b6103da565b60405190815260200161010e565b6101ba6101d63660046109c6565b6103f0565b6101ba6101e93660046109c6565b610406565b61019a6101fc366004610b08565b6040805160e0998a1b7fffffffff0000000000000000000000000000000000000000000000000000000090811660208301529890991b90971660248901526028880195909552604887019390935260f89190911b7fff00000000000000000000000000000000000000000000000000000000000000166068860152606090811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116606987015291811b8216607d8601529190911b1660918301528051608581840301815260a5909201905290565b6102e06102db3660046109c6565b610419565b60405163ffffffff909116815260200161010e565b6102e06103033660046109c6565b61042c565b61013d6103163660046109c6565b61043f565b6101ba6103293660046109c6565b610452565b61013d61033c3660046109c6565b610465565b600061036761034f83610478565b6fffffffffffffffffffffffffffffffff1660851490565b92915050565b600061039561038361037e84610478565b610493565b61038f61037e86610478565b906104e5565b9392505050565b60006103676103aa83610501565b61050f565b60006103676103bd83610501565b61051e565b606060006103cf83610501565b905061039581610530565b60006103676103eb61037e84610478565b61058d565b600061036761040161037e84610478565b6105bb565b600061036761041483610501565b6105e7565b600061036761042783610501565b6105f9565b600061036761043a83610501565b610607565b600061036761044d83610501565b610615565b600061036761046083610501565b610622565b600061036761047383610501565b610631565b80516000906020830161048b818361063e565b949350505050565b600060856fffffffffffffffffffffffffffffffff8316146104e1576040517f76b4e13c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b60006104f0826106a1565b6104f9846106a1565b149392505050565b600061036761037e83610478565b6000610367605d835b906106cc565b600061036760486001845b91906106d6565b6040518061054183602083016106f7565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60006103677fdf42b2c0137811ba604f5c79e20c4d6b94770aa819cc524eca444056544f8ab7835b906107a6565b60006103677fb38669e8ca41a27fcd85729b868e8ab047d0f142073a017213e58f0a91e88ef3836105b5565b600061036760286020845b91906107e2565b600061036760048084610529565b600061036781600484610529565b6000610367604983610518565b600061036760086020846105f2565b6000610367607183610518565b60008061064b8385610b99565b905060405181111561065b575060005b80600003610695576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b831761048b565b6000806106ae8360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b6000610395838360145b6000806106e48585856107e2565b602084900360031b1c9150509392505050565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610751576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610794576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b6000816107b2846106a1565b60408051602081019390935282015260600160405160208183030381529060405280519060200120905092915050565b6000816000036107f457506000610395565b602082111561082f576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661084c8385610b99565b1115610884576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006108958660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261092c57600080fd5b813567ffffffffffffffff80821115610947576109476108ec565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561098d5761098d6108ec565b816040528381528660208588010111156109a657600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156109d857600080fd5b813567ffffffffffffffff8111156109ef57600080fd5b61048b8482850161091b565b60008060408385031215610a0e57600080fd5b823567ffffffffffffffff80821115610a2657600080fd5b610a328683870161091b565b93506020850135915080821115610a4857600080fd5b50610a558582860161091b565b9150509250929050565b600060208083528351808285015260005b81811015610a8c57858101830151858201604001528201610a70565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b803563ffffffff81168114610adf57600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610adf57600080fd5b600080600080600080600080610100898b031215610b2557600080fd5b610b2e89610acb565b9750610b3c60208a01610acb565b96506040890135955060608901359450608089013560ff81168114610b6057600080fd5b9350610b6e60a08a01610ae4565b9250610b7c60c08a01610ae4565b9150610b8a60e08a01610ae4565b90509295985092959890939650565b80820180821115610367577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea264697066735822122052b2b9231b76e4c4c31e614753009f7513a2ada3af2c039576adcd2563189f8664736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063854dfcd71161008c578063cb3eb0e111610066578063cb3eb0e1146102f5578063e152a8cb14610308578063ed54c3b61461031b578063f7e6a05b1461032e57600080fd5b8063854dfcd7146101db578063c3bfda6c146101ee578063c81aa9c8146102cd57600080fd5b8063595271d1116100c8578063595271d1146101625780635cab5d3b1461018757806360cf3bf0146101a7578063730dbf63146101c857600080fd5b80630bb3b580146100ef578063137e618a1461011757806327f2ee361461012a575b600080fd5b6101026100fd3660046109c6565b610341565b60405190151581526020015b60405180910390f35b6101026101253660046109fb565b61036d565b61013d6101383660046109c6565b61039c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010e565b6101756101703660046109c6565b6103af565b60405160ff909116815260200161010e565b61019a6101953660046109c6565b6103c2565b60405161010e9190610a5f565b6101ba6101b53660046109c6565b6103da565b60405190815260200161010e565b6101ba6101d63660046109c6565b6103f0565b6101ba6101e93660046109c6565b610406565b61019a6101fc366004610b08565b6040805160e0998a1b7fffffffff0000000000000000000000000000000000000000000000000000000090811660208301529890991b90971660248901526028880195909552604887019390935260f89190911b7fff00000000000000000000000000000000000000000000000000000000000000166068860152606090811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116606987015291811b8216607d8601529190911b1660918301528051608581840301815260a5909201905290565b6102e06102db3660046109c6565b610419565b60405163ffffffff909116815260200161010e565b6102e06103033660046109c6565b61042c565b61013d6103163660046109c6565b61043f565b6101ba6103293660046109c6565b610452565b61013d61033c3660046109c6565b610465565b600061036761034f83610478565b6fffffffffffffffffffffffffffffffff1660851490565b92915050565b600061039561038361037e84610478565b610493565b61038f61037e86610478565b906104e5565b9392505050565b60006103676103aa83610501565b61050f565b60006103676103bd83610501565b61051e565b606060006103cf83610501565b905061039581610530565b60006103676103eb61037e84610478565b61058d565b600061036761040161037e84610478565b6105bb565b600061036761041483610501565b6105e7565b600061036761042783610501565b6105f9565b600061036761043a83610501565b610607565b600061036761044d83610501565b610615565b600061036761046083610501565b610622565b600061036761047383610501565b610631565b80516000906020830161048b818361063e565b949350505050565b600060856fffffffffffffffffffffffffffffffff8316146104e1576040517f76b4e13c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b60006104f0826106a1565b6104f9846106a1565b149392505050565b600061036761037e83610478565b6000610367605d835b906106cc565b600061036760486001845b91906106d6565b6040518061054183602083016106f7565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60006103677fdf42b2c0137811ba604f5c79e20c4d6b94770aa819cc524eca444056544f8ab7835b906107a6565b60006103677fb38669e8ca41a27fcd85729b868e8ab047d0f142073a017213e58f0a91e88ef3836105b5565b600061036760286020845b91906107e2565b600061036760048084610529565b600061036781600484610529565b6000610367604983610518565b600061036760086020846105f2565b6000610367607183610518565b60008061064b8385610b99565b905060405181111561065b575060005b80600003610695576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b831761048b565b6000806106ae8360801c90565b6fffffffffffffffffffffffffffffffff9390931690922092915050565b6000610395838360145b6000806106e48585856107e2565b602084900360031b1c9150509392505050565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c9080851015610751576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610794576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b6000816107b2846106a1565b60408051602081019390935282015260600160405160208183030381529060405280519060200120905092915050565b6000816000036107f457506000610395565b602082111561082f576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661084c8385610b99565b1115610884576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b60006108958660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261092c57600080fd5b813567ffffffffffffffff80821115610947576109476108ec565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561098d5761098d6108ec565b816040528381528660208588010111156109a657600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156109d857600080fd5b813567ffffffffffffffff8111156109ef57600080fd5b61048b8482850161091b565b60008060408385031215610a0e57600080fd5b823567ffffffffffffffff80821115610a2657600080fd5b610a328683870161091b565b93506020850135915080821115610a4857600080fd5b50610a558582860161091b565b9150509250929050565b600060208083528351808285015260005b81811015610a8c57858101830151858201604001528201610a70565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b803563ffffffff81168114610adf57600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610adf57600080fd5b600080600080600080600080610100898b031215610b2557600080fd5b610b2e89610acb565b9750610b3c60208a01610acb565b96506040890135955060608901359450608089013560ff81168114610b6057600080fd5b9350610b6e60a08a01610ae4565b9250610b7c60c08a01610ae4565b9150610b8a60e08a01610ae4565b90509295985092959890939650565b80820180821115610367577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea264697066735822122052b2b9231b76e4c4c31e614753009f7513a2ada3af2c039576adcd2563189f8664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectAgentRoot();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror AgentRootNotProposed();\nerror AgentRootTimeoutNotOver();\n\nerror NotStuck();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeTimeoutNotOver();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror SummitTipTooHigh();\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Timeout between the agent root could be proposed and resolved in LightManager\nuint32 constant AGENT_ROOT_PROPOSAL_TIMEOUT = 12 hours;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time that the Notary will not be considered active after they won a dispute\nuint32 constant DISPUTE_TIMEOUT_NOTARY = 12 hours;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Maximum value for the summit tip that could be set in GasOracle\nuint256 constant MAX_SUMMIT_TIP = 0.01 ether;\n\n/// Receipt is a memory view over a formatted \"full receipt\" payload.\ntype Receipt is uint256;\n\nusing ReceiptLib for Receipt global;\n\n/// Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`.\n/// - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not\n///   included in the receipt.\n/// - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an\n///   executed message.\n/// - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this\n///   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both\n///   receipts will be considered valid.\n/// # Memory layout of Receipt fields\n///\n/// | Position   | Field         | Type    | Bytes | Description                                      |\n/// | ---------- | ------------- | ------- | ----- | ------------------------------------------------ |\n/// | [000..004) | origin        | uint32  | 4     | Domain where message originated                  |\n/// | [004..008) | destination   | uint32  | 4     | Domain where message was executed                |\n/// | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              |\n/// | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       |\n/// | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       |\n/// | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root |\n/// | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     |\n/// | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\nlibrary ReceiptLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_DESTINATION = 4;\n    uint256 private constant OFFSET_MESSAGE_HASH = 8;\n    uint256 private constant OFFSET_SNAPSHOT_ROOT = 40;\n    uint256 private constant OFFSET_STATE_INDEX = 72;\n    uint256 private constant OFFSET_ATT_NOTARY = 73;\n    uint256 private constant OFFSET_FIRST_EXECUTOR = 93;\n    uint256 private constant OFFSET_FINAL_EXECUTOR = 113;\n\n    // ═════════════════════════════════════════════════ RECEIPT ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Receipt payload with provided fields.\n     * @param origin_           Domain where message originated\n     * @param destination_      Domain where message was executed\n     * @param messageHash_      Hash of the message\n     * @param snapshotRoot_     Snapshot root used for proving the message\n     * @param stateIndex_       Index of state used for the snapshot proof\n     * @param attNotary_        Notary who posted attestation with snapshot root\n     * @param firstExecutor_    Executor who performed first valid execution attempt\n     * @param finalExecutor_    Executor who successfully executed the message\n     * @return Formatted receipt\n     */\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n\n    /**\n     * @notice Returns a Receipt view over the given payload.\n     * @dev Will revert if the payload is not a receipt.\n     */\n    function castToReceipt(bytes memory payload) internal pure returns (Receipt) {\n        return castToReceipt(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Receipt view.\n     * @dev Will revert if the memory view is not over a receipt.\n     */\n    function castToReceipt(MemView memView) internal pure returns (Receipt) {\n        if (!isReceipt(memView)) revert UnformattedReceipt();\n        return Receipt.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Receipt.\n    function isReceipt(MemView memView) internal pure returns (bool) {\n        // Check payload length\n        return memView.len() == RECEIPT_LENGTH;\n    }\n\n    /// @notice Returns the hash of an Receipt, that could be later signed by a Notary to signal\n    /// that the receipt is valid.\n    function hashValid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_VALID_SALT);\n    }\n\n    /// @notice Returns the hash of a Receipt, that could be later signed by a Guard to signal\n    /// that the receipt is invalid.\n    function hashInvalid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptBodyInvalidSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_INVALID_SALT);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Receipt receipt) internal pure returns (MemView) {\n        return MemView.wrap(Receipt.unwrap(receipt));\n    }\n\n    /// @notice Compares two Receipt structures.\n    function equals(Receipt a, Receipt b) internal pure returns (bool) {\n        // Length of a Receipt payload is fixed, so we just need to compare the hashes\n        return a.unwrap().keccak() == b.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ RECEIPT SLICING ═════════════════════════════════════════════════\n\n    /// @notice Returns receipt's origin field\n    function origin(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_ORIGIN, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_DESTINATION, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_MESSAGE_HASH, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_SNAPSHOT_ROOT, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(Receipt receipt) internal pure returns (uint8) {\n        // Can be safely casted to uint8, since we index a single byte\n        return uint8(receipt.unwrap().indexUint({index_: OFFSET_STATE_INDEX, bytes_: 1}));\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_ATT_NOTARY});\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FIRST_EXECUTOR});\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FINAL_EXECUTOR});\n    }\n}\n\n// solhint-disable ordering\ncontract ReceiptHarness {\n    using ReceiptLib for bytes;\n    using ReceiptLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToReceipt(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Receipt receipt = ReceiptLib.castToReceipt(payload);\n        return receipt.unwrap().clone();\n    }\n\n    /// @notice Returns receipt's origin field\n    function origin(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().origin();\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().destination();\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().messageHash();\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().snapshotRoot();\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(bytes memory payload) public pure returns (uint8) {\n        return payload.castToReceipt().stateIndex();\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().attNotary();\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().firstExecutor();\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().finalExecutor();\n    }\n\n    function equals(bytes memory a, bytes memory b) public pure returns (bool) {\n        return a.ref().castToReceipt().equals(b.ref().castToReceipt());\n    }\n\n    function isReceipt(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isReceipt();\n    }\n\n    function hashValid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashValid();\n    }\n\n    function hashInvalid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashInvalid();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) public pure returns (bytes memory) {\n        return ReceiptLib.formatReceipt(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"37359:3867:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"37359:3867:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;40013:117;;;;;;:::i;:::-;;:::i;:::-;;;1475:14:1;;1468:22;1450:41;;1438:2;1423:18;40013:117:0;;;;;;;;39853:154;;;;;;:::i;:::-;;:::i;39508:138::-;;;;;;:::i;:::-;;:::i;:::-;;;2222:42:1;2210:55;;;2192:74;;2180:2;2165:18;39508:138:0;2046:226:1;39118:130:0;;;;;;:::i;:::-;;:::i;:::-;;;2449:4:1;2437:17;;;2419:36;;2407:2;2392:18;39118:130:0;2277:184:1;37952:346:0;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;40278:140::-;;;;;;:::i;:::-;;:::i;:::-;;;3222:25:1;;;3210:2;3195:18;40278:140:0;3076:177:1;40136:136:0;;;;;;:::i;:::-;;:::i;38922:::-;;;;;;:::i;:::-;;:::i;40748:476::-;;;;;;:::i;:::-;32883:147;;;5027:3:1;5023:16;;;4932:66;5019:25;;;32883:147:0;;;5007:38:1;5078:16;;;;5074:25;;;5061:11;;;5054:46;5116:11;;;5109:27;;;;5152:12;;;5145:28;;;;5211:3;5207:16;;;;5225:66;5203:89;5189:12;;;5182:111;41031:12:0;5412:15:1;;;5312:66;5408:24;;;5394:12;;;5387:46;5467:15;;;5463:24;;5449:12;;;5442:46;5523:15;;;;5519:24;5504:13;;;5497:47;32883:147:0;;;;;;;;;5560:13:1;;;;32883:147:0;;;40748:476;38532:133;;;;;;:::i;:::-;;:::i;:::-;;;4582:10:1;4570:23;;;4552:42;;4540:2;4525:18;38532:133:0;4408:192:1;38351:123:0;;;;;;:::i;:::-;;:::i;39315:130::-;;;;;;:::i;:::-;;:::i;38726:134::-;;;;;;:::i;:::-;;:::i;39709:138::-;;;;;;:::i;:::-;;:::i;40013:117::-;40075:4;40098:25;:13;:7;:11;:13::i;:::-;11895:17;11869:43;26225:3;33826:31;;33712:152;40098:25;40091:32;40013:117;-1:-1:-1;;40013:117:0:o;39853:154::-;39922:4;39945:55;39976:23;:7;:1;:5;:7::i;:::-;:21;:23::i;:::-;39945;:7;:1;:5;:7::i;:23::-;:30;;:55::i;:::-;39938:62;39853:154;-1:-1:-1;;;39853:154:0:o;39508:138::-;39574:7;39600:39;:23;:7;:21;:23::i;:::-;:37;:39::i;39118:130::-;39181:5;39205:36;:23;:7;:21;:23::i;:::-;:34;:36::i;37952:346::-;38018:12;38199:15;38217:33;38242:7;38217:24;:33::i;:::-;38199:51;-1:-1:-1;38267:24:0;38199:51;38267:22;:24::i;40278:140::-;40342:7;40368:43;:29;:13;:7;:11;:13::i;:29::-;:41;:43::i;40136:136::-;40198:7;40224:41;:29;:13;:7;:11;:13::i;:29::-;:39;:41::i;38922:136::-;38987:7;39013:38;:23;:7;:21;:23::i;:::-;:36;:38::i;38532:133::-;38596:6;38621:37;:23;:7;:21;:23::i;:::-;:35;:37::i;38351:123::-;38410:6;38435:32;:23;:7;:21;:23::i;:::-;:30;:32::i;39315:130::-;39377:7;39403:35;:23;:7;:21;:23::i;:::-;:33;:35::i;38726:134::-;38790:7;38816:37;:23;:7;:21;:23::i;:::-;:35;:37::i;39709:138::-;39775:7;39801:39;:23;:7;:21;:23::i;:::-;:37;:39::i;7602:569::-;7690:10;;7656:7;;8116:4;8107:14;;8147:17;8107:14;7690:10;8147:5;:17::i;:::-;8140:24;7602:569;-1:-1:-1;;;;7602:569:0:o;33449:195::-;33512:7;26225:3;11895:17;11869:43;;33826:31;33531:52;;33563:20;;;;;;;;;;;;;;33531:52;-1:-1:-1;33628:7:0;33449:195::o;34832:220::-;34893:4;35026:19;:1;:17;:19::i;:::-;35003;:1;35026:17;:19::i;35003:::-;:42;;34832:220;-1:-1:-1;;;34832:220:0:o;33178:129::-;33246:7;33272:28;33286:13;:7;:11;:13::i;36948:158::-;37011:7;37037:62;31477:2;37037:7;:16;:29;;:62::i;36432:236::-;36492:5;36593:67;31367:2;36657:1;36593:7;:16;:26;:67;:26;:67::i;8709:1041::-;8955:4;8949:11;;9085:34;9099:7;9114:4;9108:10;;9085:13;:34::i;:::-;-1:-1:-1;11895:17:0;11869:43;;9331:12;12727:2;12711:18;;13095:20;;9627;;9649:4;9623:31;9617:4;9610:45;-1:-1:-1;9717:17:0;;8709:1041;;-1:-1:-1;8709:1041:0:o;34355:230::-;34416:7;34527:51;27820:33;34527:7;:16;:29;;:51::i;34002:215::-;34061:7;34161:49;27747:31;34161:7;:16;34651:126;36211:161;36273:7;36299:66;31313:2;36361;36299:7;:16;:22;:66;:22;:66::i;35695:234::-;35756:6;35854:67;31204:1;;35854:7;:16;34651:126;35413:224;35469:6;35567:62;35469:6;35626:1;35567:7;:16;34651:126;36735:150;36794:7;36820:58;31420:2;36820:7;:16;34651:126;35990:159;36051:7;36077:65;31258:1;36138:2;36077:7;:16;34651:126;37169:158;37232:7;37258:62;31534:3;37258:7;:16;34651:126;6722:540;6788:7;;6822:11;6829:4;6822;:11;:::i;:::-;6807:26;;7101:4;7095:11;7089:4;7086:21;7083:38;;;-1:-1:-1;7118:1:0;7083:38;7144:4;7152:1;7144:9;7140:66;;7176:19;;;;;;;;;;;;;;7140:66;21992:3;21984:11;;;21983:20;;7222:33;21659:352;13633:292;13689:14;13715:12;13730:13;:7;11528:3;11501:30;;11342:196;13730:13;11895:17;11869:43;;;;13888:21;;;;;-1:-1:-1;;13633:292:0:o;20983:225::-;21061:7;21170:29;:7;21188:6;21196:2;20182:538;20273:7;;20315:29;:7;20329:6;20337;20315:13;:29::i;:::-;20685:2;:11;;;20701:1;20684:18;20658:45;;-1:-1:-1;;20182:538:0;;;;;:::o;22643:842::-;22982:4;22976:11;22721:7;;11895:17;11869:43;;;11528:3;11501:30;;;;23064:12;;;23060:66;;;23099:16;;;;;;;;;;;;;;23060:66;23135:8;23351:4;23343:6;23337:4;23329:6;23323:4;23316:5;23305:51;23298:58;;23380:3;23375:37;;23392:20;;;;;;;;;;;;;;23375:37;21992:3;21984:11;;;21983:20;;23422:56;22643:842;-1:-1:-1;;;;;;;22643:842:0:o;14188:169::-;14264:20;14326:4;14332:16;:7;:14;:16::i;:::-;14313:36;;;;;;6025:19:1;;;;6060:12;;6053:28;6097:12;;14313:36:0;;;;;;;;;;;;14303:47;;;;;;14296:54;;14188:169;;;;:::o;18490:1334::-;18577:14;18607:6;18617:1;18607:11;18603:59;;-1:-1:-1;18649:1:0;18634:17;;18603:59;18748:2;18739:6;:11;18735:65;;;18773:16;;;;;;;;;;;;;;18735:65;11895:17;11869:43;;18879:15;18888:6;18879;:15;:::i;:::-;:31;18875:82;;;18933:13;;;;;;;;;;;;;;18875:82;18996:1;18986:11;;;18966:17;19036:13;:7;11528:3;11501:30;;11342:196;19036:13;19783:17;;;19777:24;19494:66;19475:17;;;;;19471:90;;;;19773:35;;18490:1334;-1:-1:-1;;;;18490:1334:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1502:539::-;1588:6;1596;1649:2;1637:9;1628:7;1624:23;1620:32;1617:52;;;1665:1;1662;1655:12;1617:52;1705:9;1692:23;1734:18;1775:2;1767:6;1764:14;1761:34;;;1791:1;1788;1781:12;1761:34;1814:49;1855:7;1846:6;1835:9;1831:22;1814:49;:::i;:::-;1804:59;;1916:2;1905:9;1901:18;1888:32;1872:48;;1945:2;1935:8;1932:16;1929:36;;;1961:1;1958;1951:12;1929:36;;1984:51;2027:7;2016:8;2005:9;2001:24;1984:51;:::i;:::-;1974:61;;;1502:539;;;;;:::o;2466:605::-;2576:4;2605:2;2634;2623:9;2616:21;2666:6;2660:13;2709:6;2704:2;2693:9;2689:18;2682:34;2734:1;2744:140;2758:6;2755:1;2752:13;2744:140;;;2853:14;;;2849:23;;2843:30;2819:17;;;2838:2;2815:26;2808:66;2773:10;;2744:140;;;2748:3;2933:1;2928:2;2919:6;2908:9;2904:22;2900:31;2893:42;3062:2;2992:66;2987:2;2979:6;2975:15;2971:88;2960:9;2956:104;2952:113;2944:121;;;;2466:605;;;;:::o;3258:163::-;3325:20;;3385:10;3374:22;;3364:33;;3354:61;;3411:1;3408;3401:12;3354:61;3258:163;;;:::o;3426:196::-;3494:20;;3554:42;3543:54;;3533:65;;3523:93;;3612:1;3609;3602:12;3627:776;3745:6;3753;3761;3769;3777;3785;3793;3801;3854:3;3842:9;3833:7;3829:23;3825:33;3822:53;;;3871:1;3868;3861:12;3822:53;3894:28;3912:9;3894:28;:::i;:::-;3884:38;;3941:37;3974:2;3963:9;3959:18;3941:37;:::i;:::-;3931:47;;4025:2;4014:9;4010:18;3997:32;3987:42;;4076:2;4065:9;4061:18;4048:32;4038:42;;4130:3;4119:9;4115:19;4102:33;4175:4;4168:5;4164:16;4157:5;4154:27;4144:55;;4195:1;4192;4185:12;4144:55;4218:5;-1:-1:-1;4242:39:1;4276:3;4261:19;;4242:39;:::i;:::-;4232:49;;4300:39;4334:3;4323:9;4319:19;4300:39;:::i;:::-;4290:49;;4358:39;4392:3;4381:9;4377:19;4358:39;:::i;:::-;4348:49;;3627:776;;;;;;;;;;;:::o;5584:279::-;5649:9;;;5670:10;;;5667:190;;;5713:77;5710:1;5703:88;5814:4;5811:1;5804:15;5842:4;5839:1;5832:15","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"UnformattedReceipt","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"attNotary","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToReceipt","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"a","type":"bytes"},{"internalType":"bytes","name":"b","type":"bytes"}],"name":"equals","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"finalExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"firstExecutor","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"origin_","type":"uint32"},{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"bytes32","name":"messageHash_","type":"bytes32"},{"internalType":"bytes32","name":"snapshotRoot_","type":"bytes32"},{"internalType":"uint8","name":"stateIndex_","type":"uint8"},{"internalType":"address","name":"attNotary_","type":"address"},{"internalType":"address","name":"firstExecutor_","type":"address"},{"internalType":"address","name":"finalExecutor_","type":"address"}],"name":"formatReceipt","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"hashInvalid","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"hashValid","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isReceipt","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"messageHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"snapshotRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"stateIndex","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"attNotary(bytes)":{"notice":"Returns receipt's \"attestation notary\" field"},"destination(bytes)":{"notice":"Returns receipt's destination field"},"finalExecutor(bytes)":{"notice":"Returns receipt's \"final executor\" field"},"firstExecutor(bytes)":{"notice":"Returns receipt's \"first executor\" field"},"messageHash(bytes)":{"notice":"Returns receipt's \"message hash\" field"},"origin(bytes)":{"notice":"Returns receipt's origin field"},"snapshotRoot(bytes)":{"notice":"Returns receipt's \"snapshot root\" field"},"stateIndex(bytes)":{"notice":"Returns receipt's \"state index\" field"}},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnformattedReceipt\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"attNotary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"a\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"equals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"finalExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"firstExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"snapshotRoot_\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"stateIndex_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attNotary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"firstExecutor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"finalExecutor_\",\"type\":\"address\"}],\"name\":\"formatReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"hashInvalid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"hashValid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isReceipt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"messageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"snapshotRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"stateIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"attNotary(bytes)\":{\"notice\":\"Returns receipt's \\\"attestation notary\\\" field\"},\"destination(bytes)\":{\"notice\":\"Returns receipt's destination field\"},\"finalExecutor(bytes)\":{\"notice\":\"Returns receipt's \\\"final executor\\\" field\"},\"firstExecutor(bytes)\":{\"notice\":\"Returns receipt's \\\"first executor\\\" field\"},\"messageHash(bytes)\":{\"notice\":\"Returns receipt's \\\"message hash\\\" field\"},\"origin(bytes)\":{\"notice\":\"Returns receipt's origin field\"},\"snapshotRoot(bytes)\":{\"notice\":\"Returns receipt's \\\"snapshot root\\\" field\"},\"stateIndex(bytes)\":{\"notice\":\"Returns receipt's \\\"state index\\\" field\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ReceiptHarness.t.sol\":\"ReceiptHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ReceiptHarness.t.sol\":{\"keccak256\":\"0x8df6c87bb556e30a8fb50acbd2820596e7b3cda12a6103ee8a853fe819c22e17\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://9b5ae9c447efb24bf3d2697a5d5955e08c435482c760b2276cb2902708d4a2fb\",\"dweb:/ipfs/QmNk3vsmECFcQidLwjq7oYvP5TiiFWMbmLmwUKzMwvsSRs\"]}},\"version\":1}"},"hashes":{"attNotary(bytes)":"e152a8cb","castToReceipt(bytes)":"5cab5d3b","destination(bytes)":"c81aa9c8","equals(bytes,bytes)":"137e618a","finalExecutor(bytes)":"f7e6a05b","firstExecutor(bytes)":"27f2ee36","formatReceipt(uint32,uint32,bytes32,bytes32,uint8,address,address,address)":"c3bfda6c","hashInvalid(bytes)":"60cf3bf0","hashValid(bytes)":"730dbf63","isReceipt(bytes)":"0bb3b580","messageHash(bytes)":"ed54c3b6","origin(bytes)":"cb3eb0e1","snapshotRoot(bytes)":"854dfcd7","stateIndex(bytes)":"595271d1"}},"solidity/ReceiptHarness.t.sol:ReceiptLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a50933beb11fb42dc6651c2cec100ea72eb83325f49b408f1b7033266650f01964736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a50933beb11fb42dc6651c2cec100ea72eb83325f49b408f1b7033266650f01964736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectAgentRoot();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectTipsProof();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror AgentRootNotProposed();\nerror AgentRootTimeoutNotOver();\n\nerror NotStuck();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeTimeoutNotOver();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ════════════════════════════════ GAS ORACLE ═════════════════════════════════\n\nerror LocalGasDataNotSet();\nerror RemoteGasDataNotSet();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror SummitTipTooHigh();\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32,uint32,uint40,uint40): 32+32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See GasData.sol: (uint16,uint16,uint16,uint16,uint16,uint16): 2+2+2+2+2+2\nuint256 constant GAS_DATA_LENGTH = 12;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_LENGTH = 133;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40,GasData): 32+4+4+5+5+len(GasData)\nuint256 constant STATE_LENGTH = 50 + GAS_DATA_LENGTH;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint8,uint32,uint32,uint32,uint32): 1+4+4+4+4\nuint256 constant HEADER_LENGTH = 17;\n/// @dev See Request.sol: (uint96,uint64,uint32): 12+8+4\nuint256 constant REQUEST_LENGTH = 24;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_VALID_SALT = keccak256(\"ATTESTATION_VALID_SALT\");\nbytes32 constant ATTESTATION_INVALID_SALT = keccak256(\"ATTESTATION_INVALID_SALT\");\nbytes32 constant RECEIPT_VALID_SALT = keccak256(\"RECEIPT_VALID_SALT\");\nbytes32 constant RECEIPT_INVALID_SALT = keccak256(\"RECEIPT_INVALID_SALT\");\nbytes32 constant SNAPSHOT_VALID_SALT = keccak256(\"SNAPSHOT_VALID_SALT\");\nbytes32 constant STATE_INVALID_SALT = keccak256(\"STATE_INVALID_SALT\");\n// ═════════════════════════════════ PROTOCOL ══════════════════════════════════\n/// @dev Optimistic period for new agent roots in LightManager\nuint32 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Timeout between the agent root could be proposed and resolved in LightManager\nuint32 constant AGENT_ROOT_PROPOSAL_TIMEOUT = 12 hours;\nuint32 constant BONDING_OPTIMISTIC_PERIOD = 1 days;\n/// @dev Amount of time that the Notary will not be considered active after they won a dispute\nuint32 constant DISPUTE_TIMEOUT_NOTARY = 12 hours;\n/// @dev Amount of time without fresh data from Notaries before contract owner can resolve stuck disputes manually\nuint256 constant FRESH_DATA_TIMEOUT = 4 hours;\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n/// @dev Maximum value for the summit tip that could be set in GasOracle\nuint256 constant MAX_SUMMIT_TIP = 0.01 ether;\n\n/// Receipt is a memory view over a formatted \"full receipt\" payload.\ntype Receipt is uint256;\n\nusing ReceiptLib for Receipt global;\n\n/// Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`.\n/// - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not\n///   included in the receipt.\n/// - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an\n///   executed message.\n/// - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this\n///   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both\n///   receipts will be considered valid.\n/// # Memory layout of Receipt fields\n///\n/// | Position   | Field         | Type    | Bytes | Description                                      |\n/// | ---------- | ------------- | ------- | ----- | ------------------------------------------------ |\n/// | [000..004) | origin        | uint32  | 4     | Domain where message originated                  |\n/// | [004..008) | destination   | uint32  | 4     | Domain where message was executed                |\n/// | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              |\n/// | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       |\n/// | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       |\n/// | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root |\n/// | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     |\n/// | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\nlibrary ReceiptLib {\n    using MemViewLib for bytes;\n\n    /// @dev The variables below are not supposed to be used outside of the library directly.\n    uint256 private constant OFFSET_ORIGIN = 0;\n    uint256 private constant OFFSET_DESTINATION = 4;\n    uint256 private constant OFFSET_MESSAGE_HASH = 8;\n    uint256 private constant OFFSET_SNAPSHOT_ROOT = 40;\n    uint256 private constant OFFSET_STATE_INDEX = 72;\n    uint256 private constant OFFSET_ATT_NOTARY = 73;\n    uint256 private constant OFFSET_FIRST_EXECUTOR = 93;\n    uint256 private constant OFFSET_FINAL_EXECUTOR = 113;\n\n    // ═════════════════════════════════════════════════ RECEIPT ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Receipt payload with provided fields.\n     * @param origin_           Domain where message originated\n     * @param destination_      Domain where message was executed\n     * @param messageHash_      Hash of the message\n     * @param snapshotRoot_     Snapshot root used for proving the message\n     * @param stateIndex_       Index of state used for the snapshot proof\n     * @param attNotary_        Notary who posted attestation with snapshot root\n     * @param firstExecutor_    Executor who performed first valid execution attempt\n     * @param finalExecutor_    Executor who successfully executed the message\n     * @return Formatted receipt\n     */\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n\n    /**\n     * @notice Returns a Receipt view over the given payload.\n     * @dev Will revert if the payload is not a receipt.\n     */\n    function castToReceipt(bytes memory payload) internal pure returns (Receipt) {\n        return castToReceipt(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Receipt view.\n     * @dev Will revert if the memory view is not over a receipt.\n     */\n    function castToReceipt(MemView memView) internal pure returns (Receipt) {\n        if (!isReceipt(memView)) revert UnformattedReceipt();\n        return Receipt.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Receipt.\n    function isReceipt(MemView memView) internal pure returns (bool) {\n        // Check payload length\n        return memView.len() == RECEIPT_LENGTH;\n    }\n\n    /// @notice Returns the hash of an Receipt, that could be later signed by a Notary to signal\n    /// that the receipt is valid.\n    function hashValid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_VALID_SALT);\n    }\n\n    /// @notice Returns the hash of a Receipt, that could be later signed by a Guard to signal\n    /// that the receipt is invalid.\n    function hashInvalid(Receipt receipt) internal pure returns (bytes32) {\n        // The final hash to sign is keccak(receiptBodyInvalidSalt, keccak(receipt))\n        return receipt.unwrap().keccakSalted(RECEIPT_INVALID_SALT);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Receipt receipt) internal pure returns (MemView) {\n        return MemView.wrap(Receipt.unwrap(receipt));\n    }\n\n    /// @notice Compares two Receipt structures.\n    function equals(Receipt a, Receipt b) internal pure returns (bool) {\n        // Length of a Receipt payload is fixed, so we just need to compare the hashes\n        return a.unwrap().keccak() == b.unwrap().keccak();\n    }\n\n    // ═════════════════════════════════════════════ RECEIPT SLICING ═════════════════════════════════════════════════\n\n    /// @notice Returns receipt's origin field\n    function origin(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_ORIGIN, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(Receipt receipt) internal pure returns (uint32) {\n        // Can be safely casted to uint32, since we index 4 bytes\n        return uint32(receipt.unwrap().indexUint({index_: OFFSET_DESTINATION, bytes_: 4}));\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_MESSAGE_HASH, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(Receipt receipt) internal pure returns (bytes32) {\n        return receipt.unwrap().index({index_: OFFSET_SNAPSHOT_ROOT, bytes_: 32});\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(Receipt receipt) internal pure returns (uint8) {\n        // Can be safely casted to uint8, since we index a single byte\n        return uint8(receipt.unwrap().indexUint({index_: OFFSET_STATE_INDEX, bytes_: 1}));\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_ATT_NOTARY});\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FIRST_EXECUTOR});\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(Receipt receipt) internal pure returns (address) {\n        return receipt.unwrap().indexAddress({index_: OFFSET_FINAL_EXECUTOR});\n    }\n}\n\n// solhint-disable ordering\ncontract ReceiptHarness {\n    using ReceiptLib for bytes;\n    using ReceiptLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToReceipt(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Receipt receipt = ReceiptLib.castToReceipt(payload);\n        return receipt.unwrap().clone();\n    }\n\n    /// @notice Returns receipt's origin field\n    function origin(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().origin();\n    }\n\n    /// @notice Returns receipt's destination field\n    function destination(bytes memory payload) public pure returns (uint32) {\n        return payload.castToReceipt().destination();\n    }\n\n    /// @notice Returns receipt's \"message hash\" field\n    function messageHash(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().messageHash();\n    }\n\n    /// @notice Returns receipt's \"snapshot root\" field\n    function snapshotRoot(bytes memory payload) public pure returns (bytes32) {\n        return payload.castToReceipt().snapshotRoot();\n    }\n\n    /// @notice Returns receipt's \"state index\" field\n    function stateIndex(bytes memory payload) public pure returns (uint8) {\n        return payload.castToReceipt().stateIndex();\n    }\n\n    /// @notice Returns receipt's \"attestation notary\" field\n    function attNotary(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().attNotary();\n    }\n\n    /// @notice Returns receipt's \"first executor\" field\n    function firstExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().firstExecutor();\n    }\n\n    /// @notice Returns receipt's \"final executor\" field\n    function finalExecutor(bytes memory payload) public pure returns (address) {\n        return payload.castToReceipt().finalExecutor();\n    }\n\n    function equals(bytes memory a, bytes memory b) public pure returns (bool) {\n        return a.ref().castToReceipt().equals(b.ref().castToReceipt());\n    }\n\n    function isReceipt(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isReceipt();\n    }\n\n    function hashValid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashValid();\n    }\n\n    function hashInvalid(bytes memory payload) public pure returns (bytes32) {\n        return payload.ref().castToReceipt().hashInvalid();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatReceipt(\n        uint32 origin_,\n        uint32 destination_,\n        bytes32 messageHash_,\n        bytes32 snapshotRoot_,\n        uint8 stateIndex_,\n        address attNotary_,\n        address firstExecutor_,\n        address finalExecutor_\n    ) public pure returns (bytes memory) {\n        return ReceiptLib.formatReceipt(\n            origin_, destination_, messageHash_, snapshotRoot_, stateIndex_, attNotary_, firstExecutor_, finalExecutor_\n        );\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"30958:6371:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;30958:6371:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"30958:6371:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`. - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not   included in the receipt. - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an   executed message. - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both   receipts will be considered valid. # Memory layout of Receipt fields | Position   | Field         | Type    | Bytes | Description                                      | | ---------- | ------------- | ------- | ----- | ------------------------------------------------ | | [000..004) | origin        | uint32  | 4     | Domain where message originated                  | | [004..008) | destination   | uint32  | 4     | Domain where message was executed                | | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              | | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       | | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       | | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root | | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     | | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Receipt structure represents a Notary statement that a certain message has been executed in `ExecutionHub`. - It is possible to prove the correctness of the tips payload using the message hash, therefore tips are not   included in the receipt. - Receipt is signed by a Notary and submitted to `Summit` in order to initiate the tips distribution for an   executed message. - If a message execution fails the first time, the `finalExecutor` field will be set to zero address. In this   case, when the message is finally executed successfully, the `finalExecutor` field will be updated. Both   receipts will be considered valid. # Memory layout of Receipt fields | Position   | Field         | Type    | Bytes | Description                                      | | ---------- | ------------- | ------- | ----- | ------------------------------------------------ | | [000..004) | origin        | uint32  | 4     | Domain where message originated                  | | [004..008) | destination   | uint32  | 4     | Domain where message was executed                | | [008..040) | messageHash   | bytes32 | 32    | Hash of the message                              | | [040..072) | snapshotRoot  | bytes32 | 32    | Snapshot root used for proving the message       | | [072..073) | stateIndex    | uint8   | 1     | Index of state used for the snapshot proof       | | [073..093) | attNotary     | address | 20    | Notary who posted attestation with snapshot root | | [093..113) | firstExecutor | address | 20    | Executor who performed first valid execution     | | [113..133) | finalExecutor | address | 20    | Executor who successfully executed the message   |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/ReceiptHarness.t.sol\":\"ReceiptLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/ReceiptHarness.t.sol\":{\"keccak256\":\"0x8df6c87bb556e30a8fb50acbd2820596e7b3cda12a6103ee8a853fe819c22e17\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://9b5ae9c447efb24bf3d2697a5d5955e08c435482c760b2276cb2902708d4a2fb\",\"dweb:/ipfs/QmNk3vsmECFcQidLwjq7oYvP5TiiFWMbmLmwUKzMwvsSRs\"]}},\"version\":1}"},"hashes":{}}}