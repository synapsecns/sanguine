{"solidity/HeaderHarness.t.sol:Header":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205c2e4d3f8bbebdf555373bcdb0ed2208fe798bee60066f67dcc6851ce471ecc164736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205c2e4d3f8bbebdf555373bcdb0ed2208fe798bee60066f67dcc6851ce471ecc164736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(SynapseTypes.MESSAGE_HEADER);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.MESSAGE_HEADER);\n    }\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return headerVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    using Header for bytes;\n    using Header for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToHeader(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Header.castToHeader(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    /// @notice Returns header's version field.\n    function headerVersion(uint40 _type, bytes memory _payload) public pure returns (uint16) {\n        return _payload.ref(_type).headerVersion();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).origin();\n    }\n\n    /// @notice Returns header's sender field\n    function sender(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).sender();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).destination();\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).recipient();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).optimisticSeconds();\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(uint40 _type, bytes memory _payload) public pure returns (address) {\n        return _payload.ref(_type).recipientAddress();\n    }\n\n    function isHeader(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToHeader().isHeader();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) public pure returns (bytes memory) {\n        return\n            Header.formatHeader(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function headerLength() public pure returns (uint256) {\n        return Header.HEADER_LENGTH;\n    }\n\n    function headerVersion() public pure returns (uint16) {\n        return Header.HEADER_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return Header.OFFSET_VERSION;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Header.OFFSET_ORIGIN;\n    }\n\n    function offsetSender() public pure returns (uint256) {\n        return Header.OFFSET_SENDER;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Header.OFFSET_NONCE;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Header.OFFSET_DESTINATION;\n    }\n\n    function offsetRecipient() public pure returns (uint256) {\n        return Header.OFFSET_RECIPIENT;\n    }\n\n    function offsetOptimisticSeconds() public pure returns (uint256) {\n        return Header.OFFSET_OPTIMISTIC_SECONDS;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"41114:6119:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;41114:6119:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"41114:6119:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_VERSION":{"details":"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): origin             uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destination        uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_VERSION\":{\"details\":\"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): origin             uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destination        uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"Header\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0xf0f5bc46d2a6571a325a040b678cc25bc3ab4ea1b98eacc3cc9f0ba97d147e7a\",\"urls\":[\"bzz-raw://8de8fffd2689a9c11fa81c50661308e010e3d652b7f1ef4827b49ad479369af7\",\"dweb:/ipfs/QmVwMooJ23CQFmfb8nnCbhL8BD4aLguBssUUvRL6WBof5W\"]}},\"version\":1}"},"hashes":{}},"solidity/HeaderHarness.t.sol:HeaderHarness":{"code":"0x608060405234801561001057600080fd5b50611366806100206000396000f3fe608060405234801561001057600080fd5b506004361061016c5760003560e01c806372a2f4a8116100cd578063aabd995611610081578063ce42947411610066578063ce429474146102d7578063d2c4428a146102ea578063d455d504146102f157600080fd5b8063aabd995614610294578063ac124002146102b757600080fd5b80639a3c57ad116100b25780639a3c57ad146102675780639b011d881461027a578063a2ce1f351461028d57600080fd5b806372a2f4a81461023f57806380bfe8a31461026057600080fd5b80631900888f116101245780634155c3d5116101095780634155c3d51461021b578063569e1eaf146102225780635cf682c61461022957600080fd5b80631900888f14610201578063320bfc441461021457600080fd5b80630c096e8d116101555780630c096e8d146101af57806311dca44d146101b6578063170cd79b146101ee57600080fd5b806306dc2d1a1461017157806307fd670d1461019e575b600080fd5b61018461017f3660046110d6565b610304565b60405163ffffffff90911681526020015b60405180910390f35b60065b604051908152602001610195565b60006101a1565b6101c96101c43660046110d6565b610327565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610195565b6101846101fc3660046110d6565b610341565b61018461020f3660046110d6565b61035b565b60026101a1565b604e6101a1565b60266101a1565b60015b60405161ffff9091168152602001610195565b61025261024d3660046110d6565b610375565b604051610195929190611194565b60526101a1565b61022c6102753660046110d6565b6103b0565b6101a16102883660046110d6565b6103ca565b602e6101a1565b6102a76102a23660046111bc565b6103e4565b6040519015158152602001610195565b6102ca6102c536600461120a565b6103fd565b6040516101959190611270565b6101a16102e53660046110d6565b61049f565b602a6101a1565b6101846102ff3660046110d6565b6104b9565b600061031e61031383856104d3565b62ffffff19166104f7565b90505b92915050565b600061031e61033683856104d3565b62ffffff191661052a565b600061031e61035083856104d3565b62ffffff191661053b565b600061031e61036a83856104d3565b62ffffff1916610567565b60006060600061038484610593565b905061039562ffffff1982166105a4565b6103a462ffffff1983166105c8565b92509250509250929050565b600061031e6103bf83856104d3565b62ffffff191661061b565b600061031e6103d983856104d3565b62ffffff1916610647565b60006103216103f283610593565b62ffffff1916610673565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e089811b821660228401526026830189905287811b8216604684015286811b8216604a840152604e830186905284901b16606e8201528151808203605201815260729091019091526060905b979650505050505050565b600061031e6104ae83856104d3565b62ffffff19166106ba565b600061031e6104c883856104d3565b62ffffff19166106e6565b8151600090602084016104ee64ffffffffff85168284610712565b95945050505050565b60008161050f62ffffff198216640301010000610759565b5061052362ffffff198416602a600461087c565b9392505050565b600061032161053883610647565b90565b60008161055362ffffff198216640301010000610759565b5061052362ffffff1984166026600461087c565b60008161057f62ffffff198216640301010000610759565b5061052362ffffff198416604e600461087c565b6000610321826403010100006104d3565b60008060606105b48160186112b2565b6105be91906112b2565b9290921c92915050565b60606000806105e58460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061060a84836020016108ac565b508181016020016040529052919050565b60008161063362ffffff198216640301010000610759565b5061052362ffffff1984166000600261087c565b60008161065f62ffffff198216640301010000610759565b5061052362ffffff198416602e6020610a88565b6000601882901c6bffffffffffffffffffffffff16600281101561069a5750600092915050565b60016106a58461061b565b61ffff16148015610523575060521492915050565b6000816106d262ffffff198216640301010000610759565b5061052362ffffff19841660066020610a88565b6000816106fe62ffffff198216640301010000610759565b5061052362ffffff1984166002600461087c565b60008061071f83856112b2565b905060405181111561072f575060005b806000036107445762ffffff19915050610523565b5050606092831b9190911790911b1760181b90565b60006107658383610c36565b610875576000610783610777856105a4565b64ffffffffff16610c58565b91505060006107988464ffffffffff16610c58565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086c9190611270565b60405180910390fd5b5090919050565b60006108898260206112c5565b6108949060086112de565b60ff166108a2858585610a88565b901c949350505050565b600062ffffff198084160361091d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e746572206465726566000000000000604482015260640161086c565b61092683610d42565b61098c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e746572206465726566000000604482015260640161086c565b60006109a68460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060006109c185610d7e565b6bffffffffffffffffffffffff1690506000806040519150858211156109e75760206060fd5b8386858560045afa905080610a58576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f6620676173000000000000000000000000604482015260640161086c565b610494610a64886105a4565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b60008160ff16600003610a9d57506000610523565b610ab58460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610ad060ff8416856112b2565b1115610b5357610b20610ae285610d7e565b6bffffffffffffffffffffffff16610b088660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16610da5565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086c9190611270565b60208260ff161115610bc1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e20333220627974657300000000000000604482015260640161086c565b600882026000610bd086610d7e565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008164ffffffffff16610c49846105a4565b64ffffffffff16149392505050565b600080601f5b600f8160ff161115610ccb576000610c778260086112de565b60ff1685901c9050610c8881610f35565b61ffff16841793508160ff16601014610ca357601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610c5e565b50600f5b60ff8160ff161015610d3c576000610ce88260086112de565b60ff1685901c9050610cf981610f35565b61ffff16831792508160ff16600014610d1457601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610ccf565b50915091565b6000610d4d826105a4565b64ffffffffff1664ffffffffff03610d6757506000919050565b6000610d7283610f67565b60405110199392505050565b600080610d8d606060186112b2565b9290921c6bffffffffffffffffffffffff1692915050565b60606000610db286610c58565b9150506000610dc086610c58565b9150506000610dce86610c58565b9150506000610ddc86610c58565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b6000610f4760048360ff16901c610fa0565b60ff1661ffff919091161760081b610f5e82610fa0565b60ff1617919050565b6000610f818260181c6bffffffffffffffffffffffff1690565b610f8a83610d7e565b016bffffffffffffffffffffffff169050919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f84169182908110610fed57610fed611301565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261103c57600080fd5b813567ffffffffffffffff8082111561105757611057610ffc565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561109d5761109d610ffc565b816040528381528660208588010111156110b657600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080604083850312156110e957600080fd5b823564ffffffffff811681146110fe57600080fd5b9150602083013567ffffffffffffffff81111561111a57600080fd5b6111268582860161102b565b9150509250929050565b6000815180845260005b818110156111565760208185018101518683018201520161113a565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b64ffffffffff831681526040602082015260006111b46040830184611130565b949350505050565b6000602082840312156111ce57600080fd5b813567ffffffffffffffff8111156111e557600080fd5b6111b48482850161102b565b803563ffffffff8116811461120557600080fd5b919050565b60008060008060008060c0878903121561122357600080fd5b61122c876111f1565b955060208701359450611241604088016111f1565b935061124f606088016111f1565b92506080870135915061126460a088016111f1565b90509295509295509295565b60208152600061031e6020830184611130565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561032157610321611283565b60ff828116828216039081111561032157610321611283565b60ff81811683821602908116908181146112fa576112fa611283565b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220a9e053f2075267dde35db53e51f98753c8ba02a649f4811309e61a36cc1df83964736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b506004361061016c5760003560e01c806372a2f4a8116100cd578063aabd995611610081578063ce42947411610066578063ce429474146102d7578063d2c4428a146102ea578063d455d504146102f157600080fd5b8063aabd995614610294578063ac124002146102b757600080fd5b80639a3c57ad116100b25780639a3c57ad146102675780639b011d881461027a578063a2ce1f351461028d57600080fd5b806372a2f4a81461023f57806380bfe8a31461026057600080fd5b80631900888f116101245780634155c3d5116101095780634155c3d51461021b578063569e1eaf146102225780635cf682c61461022957600080fd5b80631900888f14610201578063320bfc441461021457600080fd5b80630c096e8d116101555780630c096e8d146101af57806311dca44d146101b6578063170cd79b146101ee57600080fd5b806306dc2d1a1461017157806307fd670d1461019e575b600080fd5b61018461017f3660046110d6565b610304565b60405163ffffffff90911681526020015b60405180910390f35b60065b604051908152602001610195565b60006101a1565b6101c96101c43660046110d6565b610327565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610195565b6101846101fc3660046110d6565b610341565b61018461020f3660046110d6565b61035b565b60026101a1565b604e6101a1565b60266101a1565b60015b60405161ffff9091168152602001610195565b61025261024d3660046110d6565b610375565b604051610195929190611194565b60526101a1565b61022c6102753660046110d6565b6103b0565b6101a16102883660046110d6565b6103ca565b602e6101a1565b6102a76102a23660046111bc565b6103e4565b6040519015158152602001610195565b6102ca6102c536600461120a565b6103fd565b6040516101959190611270565b6101a16102e53660046110d6565b61049f565b602a6101a1565b6101846102ff3660046110d6565b6104b9565b600061031e61031383856104d3565b62ffffff19166104f7565b90505b92915050565b600061031e61033683856104d3565b62ffffff191661052a565b600061031e61035083856104d3565b62ffffff191661053b565b600061031e61036a83856104d3565b62ffffff1916610567565b60006060600061038484610593565b905061039562ffffff1982166105a4565b6103a462ffffff1983166105c8565b92509250509250929050565b600061031e6103bf83856104d3565b62ffffff191661061b565b600061031e6103d983856104d3565b62ffffff1916610647565b60006103216103f283610593565b62ffffff1916610673565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e089811b821660228401526026830189905287811b8216604684015286811b8216604a840152604e830186905284901b16606e8201528151808203605201815260729091019091526060905b979650505050505050565b600061031e6104ae83856104d3565b62ffffff19166106ba565b600061031e6104c883856104d3565b62ffffff19166106e6565b8151600090602084016104ee64ffffffffff85168284610712565b95945050505050565b60008161050f62ffffff198216640301010000610759565b5061052362ffffff198416602a600461087c565b9392505050565b600061032161053883610647565b90565b60008161055362ffffff198216640301010000610759565b5061052362ffffff1984166026600461087c565b60008161057f62ffffff198216640301010000610759565b5061052362ffffff198416604e600461087c565b6000610321826403010100006104d3565b60008060606105b48160186112b2565b6105be91906112b2565b9290921c92915050565b60606000806105e58460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061060a84836020016108ac565b508181016020016040529052919050565b60008161063362ffffff198216640301010000610759565b5061052362ffffff1984166000600261087c565b60008161065f62ffffff198216640301010000610759565b5061052362ffffff198416602e6020610a88565b6000601882901c6bffffffffffffffffffffffff16600281101561069a5750600092915050565b60016106a58461061b565b61ffff16148015610523575060521492915050565b6000816106d262ffffff198216640301010000610759565b5061052362ffffff19841660066020610a88565b6000816106fe62ffffff198216640301010000610759565b5061052362ffffff1984166002600461087c565b60008061071f83856112b2565b905060405181111561072f575060005b806000036107445762ffffff19915050610523565b5050606092831b9190911790911b1760181b90565b60006107658383610c36565b610875576000610783610777856105a4565b64ffffffffff16610c58565b91505060006107988464ffffffffff16610c58565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086c9190611270565b60405180910390fd5b5090919050565b60006108898260206112c5565b6108949060086112de565b60ff166108a2858585610a88565b901c949350505050565b600062ffffff198084160361091d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e746572206465726566000000000000604482015260640161086c565b61092683610d42565b61098c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e746572206465726566000000604482015260640161086c565b60006109a68460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060006109c185610d7e565b6bffffffffffffffffffffffff1690506000806040519150858211156109e75760206060fd5b8386858560045afa905080610a58576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f6620676173000000000000000000000000604482015260640161086c565b610494610a64886105a4565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b60008160ff16600003610a9d57506000610523565b610ab58460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610ad060ff8416856112b2565b1115610b5357610b20610ae285610d7e565b6bffffffffffffffffffffffff16610b088660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16610da5565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161086c9190611270565b60208260ff161115610bc1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e20333220627974657300000000000000604482015260640161086c565b600882026000610bd086610d7e565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008164ffffffffff16610c49846105a4565b64ffffffffff16149392505050565b600080601f5b600f8160ff161115610ccb576000610c778260086112de565b60ff1685901c9050610c8881610f35565b61ffff16841793508160ff16601014610ca357601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610c5e565b50600f5b60ff8160ff161015610d3c576000610ce88260086112de565b60ff1685901c9050610cf981610f35565b61ffff16831792508160ff16600014610d1457601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610ccf565b50915091565b6000610d4d826105a4565b64ffffffffff1664ffffffffff03610d6757506000919050565b6000610d7283610f67565b60405110199392505050565b600080610d8d606060186112b2565b9290921c6bffffffffffffffffffffffff1692915050565b60606000610db286610c58565b9150506000610dc086610c58565b9150506000610dce86610c58565b9150506000610ddc86610c58565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b6000610f4760048360ff16901c610fa0565b60ff1661ffff919091161760081b610f5e82610fa0565b60ff1617919050565b6000610f818260181c6bffffffffffffffffffffffff1690565b610f8a83610d7e565b016bffffffffffffffffffffffff169050919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f84169182908110610fed57610fed611301565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261103c57600080fd5b813567ffffffffffffffff8082111561105757611057610ffc565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561109d5761109d610ffc565b816040528381528660208588010111156110b657600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080604083850312156110e957600080fd5b823564ffffffffff811681146110fe57600080fd5b9150602083013567ffffffffffffffff81111561111a57600080fd5b6111268582860161102b565b9150509250929050565b6000815180845260005b818110156111565760208185018101518683018201520161113a565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b64ffffffffff831681526040602082015260006111b46040830184611130565b949350505050565b6000602082840312156111ce57600080fd5b813567ffffffffffffffff8111156111e557600080fd5b6111b48482850161102b565b803563ffffffff8116811461120557600080fd5b919050565b60008060008060008060c0878903121561122357600080fd5b61122c876111f1565b955060208701359450611241604088016111f1565b935061124f606088016111f1565b92506080870135915061126460a088016111f1565b90509295509295509295565b60208152600061031e6020830184611130565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561032157610321611283565b60ff828116828216039081111561032157610321611283565b60ff81811683821602908116908181146112fa576112fa611283565b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220a9e053f2075267dde35db53e51f98753c8ba02a649f4811309e61a36cc1df83964736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(SynapseTypes.MESSAGE_HEADER);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.MESSAGE_HEADER);\n    }\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return headerVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    using Header for bytes;\n    using Header for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToHeader(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Header.castToHeader(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    /// @notice Returns header's version field.\n    function headerVersion(uint40 _type, bytes memory _payload) public pure returns (uint16) {\n        return _payload.ref(_type).headerVersion();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).origin();\n    }\n\n    /// @notice Returns header's sender field\n    function sender(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).sender();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).destination();\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).recipient();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).optimisticSeconds();\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(uint40 _type, bytes memory _payload) public pure returns (address) {\n        return _payload.ref(_type).recipientAddress();\n    }\n\n    function isHeader(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToHeader().isHeader();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) public pure returns (bytes memory) {\n        return\n            Header.formatHeader(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function headerLength() public pure returns (uint256) {\n        return Header.HEADER_LENGTH;\n    }\n\n    function headerVersion() public pure returns (uint16) {\n        return Header.HEADER_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return Header.OFFSET_VERSION;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Header.OFFSET_ORIGIN;\n    }\n\n    function offsetSender() public pure returns (uint256) {\n        return Header.OFFSET_SENDER;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Header.OFFSET_NONCE;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Header.OFFSET_DESTINATION;\n    }\n\n    function offsetRecipient() public pure returns (uint256) {\n        return Header.OFFSET_RECIPIENT;\n    }\n\n    function offsetOptimisticSeconds() public pure returns (uint256) {\n        return Header.OFFSET_OPTIMISTIC_SECONDS;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"47309:5359:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"47309:5359:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;49213:144;;;;;;:::i;:::-;;:::i;:::-;;;1650:10:1;1638:23;;;1620:42;;1608:2;1593:18;49213:144:0;;;;;;;;52115:98;41846:1;52115:98;;;1819:25:1;;;1807:2;1792:18;52115:98:0;1673:177:1;51905:100:0;51951:7;51905:100;;49853:155;;;;;;:::i;:::-;;:::i;:::-;;;2031:42:1;2019:55;;;2001:74;;1989:2;1974:18;49853:155:0;1855:226:1;49024:132:0;;;;;;:::i;:::-;;:::i;49628:156::-;;;;;;:::i;:::-;;:::i;52011:98::-;41797:1;52011:98;;52545:121;42064:2;52545:121;;52219:96;41894:2;52219:96;;51800:99;41248:1;51800:99;;;2260:6:1;2248:19;;;2230:38;;2218:2;2203:18;51800:99:0;2086:188:1;48007:391:0;;;;;;:::i;:::-;;:::i;:::-;;;;;;;;:::i;51696:98::-;42115:2;51696:98;;48452:148;;;;;;:::i;:::-;;:::i;49423:141::-;;;;;;:::i;:::-;;:::i;52435:104::-;42002:2;52435:104;;50014:126;;;;;;:::i;:::-;;:::i;:::-;;;3747:14:1;;3740:22;3722:41;;3710:2;3695:18;50014:126:0;3582:187:1;50686:464:0;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;48838:135::-;;;;;;:::i;:::-;;:::i;52321:108::-;41949:2;52321:108;;48652:134;;;;;;:::i;:::-;;:::i;49213:144::-;49292:6;49317:33;:19;:8;49330:5;49317:12;:19::i;:::-;-1:-1:-1;;49317:31:0;;:33::i;:::-;49310:40;;49213:144;;;;;:::o;49853:155::-;49937:7;49963:38;:19;:8;49976:5;49963:12;:19::i;:::-;-1:-1:-1;;49963:36:0;;:38::i;49024:132::-;49097:6;49122:27;:19;:8;49135:5;49122:12;:19::i;:::-;-1:-1:-1;;49122:25:0;;:27::i;49628:156::-;49713:6;49738:39;:19;:8;49751:5;49738:12;:19::i;:::-;-1:-1:-1;;49738:37:0;;:39::i;48007:391::-;48105:6;48113:12;48298:13;48314:29;48334:8;48314:19;:29::i;:::-;48298:45;-1:-1:-1;48361:14:0;-1:-1:-1;;48361:12:0;;;:14::i;:::-;48377:13;-1:-1:-1;;48377:11:0;;;:13::i;:::-;48353:38;;;;;48007:391;;;;;:::o;48452:148::-;48533:6;48558:35;:19;:8;48571:5;48558:12;:19::i;:::-;-1:-1:-1;;48558:33:0;;:35::i;49423:141::-;49500:7;49526:31;:19;:8;49539:5;49526:12;:19::i;:::-;-1:-1:-1;;49526:29:0;;:31::i;50014:126::-;50076:4;50099:34;:23;:8;:21;:23::i;:::-;-1:-1:-1;;50099:32:0;;:34::i;50686:464::-;44343:230;;;5330:16:1;44343:230:0;;;5314:102:1;5435:66;5538:3;5534:16;;;5530:25;;5517:11;;;5510:46;5572:11;;;5565:27;;;5626:16;;;5622:25;;5608:12;;;5601:47;5682:16;;;5678:25;;5664:12;;;5657:47;5720:12;;;5713:28;;;5775:16;;;5771:25;5757:12;;;5750:47;44343:230:0;;;;;;;;;5813:12:1;;;;44343:230:0;;;50899:12;;50942:201;50923:220;50686:464;-1:-1:-1;;;;;;;50686:464:0:o;48838:135::-;48912:7;48938:28;:19;:8;48951:5;48938:12;:19::i;:::-;-1:-1:-1;;48938:26:0;;:28::i;48652:134::-;48726:6;48751:28;:19;:8;48764:5;48751:12;:19::i;:::-;-1:-1:-1;;48751:26:0;;:28::i;14644:595::-;14748:10;;14714:7;;15174:4;15165:14;;15206:26;;;;15165:14;14748:10;15206:5;:26::i;:::-;15199:33;14644:595;-1:-1:-1;;;;;14644:595:0:o;46405:161::-;46486:6;46468:7;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;46518:40:0::1;-1:-1:-1::0;;46518:17:0;::::1;41949:2;46556:1;46518:17;:40::i;:::-;46504:55:::0;46405:161;-1:-1:-1;;;46405:161:0:o;47086:145::-;47152:7;47178:46;47205:18;47215:7;47205:9;:18::i;:::-;36634:4;36521:127;46199:149;46274:6;46256:7;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;46306:34:0::1;-1:-1:-1::0;;46306:17:0;::::1;41894:2;46338:1;46306:17;:34::i;46843:174::-:0;46930:6;46912:7;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;46962:47:0::1;-1:-1:-1::0;;46962:17:0;::::1;42064:2;47007:1;46962:17;:47::i;43412:142::-:0;43480:7;43506:41;:8;40354:16;43506:12;:41::i;15431:504::-;15487:12;;3031:2;3303:20;3031:2;3119;3303:20;:::i;:::-;3383;;;;:::i;:::-;15895:24;;;;;15431:504;-1:-1:-1;;15431:504:0:o;31574:632::-;31629:16;31657:11;31678:12;31693;31697:7;3119:2;18555:23;3512:16;18551:41;;18035:573;31693:12;31678:27;;;;31815:4;31809:11;31802:18;;31870:3;31863:10;;31916:33;31929:7;31938:3;31944:4;31938:10;31916:12;:33::i;:::-;-1:-1:-1;32073:14:0;;;32089:4;32069:25;32063:4;32056:39;32136:17;;31574:632;;-1:-1:-1;31574:632:0:o;45593:159::-;45676:6;45658:7;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;45708:36:0::1;-1:-1:-1::0;;45708:17:0;::::1;41748:1;45742;45708:17;:36::i;46632:147::-:0;46711:7;46693;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;46737:35:0::1;-1:-1:-1::0;;46737:13:0;::::1;42002:2;46769;46737:13;:35::i;44662:337::-:0;44718:4;3119:2;18555:23;;;3512:16;18551:41;44835:1;44826:10;;44822:28;;;-1:-1:-1;44845:5:0;;44662:337;-1:-1:-1;;44662:337:0:o;44822:28::-;41248:1;44927:20;44941:5;44927:13;:20::i;:::-;:38;;;:65;;;;-1:-1:-1;42115:2:0;44969:23;;44920:72;-1:-1:-1;;44662:337:0:o;46007:141::-;46083:7;46065;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;46109:32:0::1;-1:-1:-1::0;;46109:13:0;::::1;41846:1;46138:2;46109:13;:32::i;45804:151::-:0;45880:6;45862:7;42709:45;-1:-1:-1;;42709:16:0;;40354;42709;:45::i;:::-;-1:-1:-1;45912:35:0::1;-1:-1:-1::0;;45912:17:0;::::1;41797:1;45945;45912:17;:35::i;13632:615::-:0;13743:15;;13785:11;13792:4;13785;:11;:::i;:::-;13770:26;;14064:4;14058:11;14052:4;14049:21;14046:66;;;-1:-1:-1;14097:1:0;14046:66;14135:4;14143:1;14135:9;14131:51;;-1:-1:-1;;14160:11:0;;;;;14131:51;-1:-1:-1;;3031:2:0;12798:33;;;12936:17;;;;12922:32;;;13059:17;3119:2;13043:34;;13632:615::o;10137:578::-;10215:7;10239:26;10246:7;10255:9;10239:6;:26::i;:::-;10234:451;;10284:9;10297:35;10315:15;10322:7;10315:6;:15::i;:::-;10307:24;;10297:9;:35::i;:::-;10281:51;;;10349:9;10362:29;10380:9;10372:18;;10362:9;:29::i;:::-;10449:186;;6203:31:1;10449:186:0;;;6191:44:1;6254:66;6358:3;6354:16;;;6350:25;;6336:12;;;6329:47;6406:15;6392:12;;;6385:37;6456:16;;;6452:25;6438:12;;;6431:47;10346:45:0;;-1:-1:-1;10405:17:0;;-1:-1:-1;6494:12:1;;10449:186:0;;;;;;;;;;;;10405:244;;10670:3;10663:11;;;;;;;;;;;:::i;:::-;;;;;;;;10234:451;-1:-1:-1;10701:7:0;;10137:578;-1:-1:-1;10137:578:0:o;23838:374::-;23957:14;24188:11;24193:6;24188:2;:11;:::i;:::-;24187:17;;24203:1;24187:17;:::i;:::-;24143:62;;24151:30;24157:7;24166:6;24174;24151:5;:30::i;:::-;24143:62;;;23838:374;-1:-1:-1;;;;23838:374:0:o;30311:892::-;30389:15;-1:-1:-1;;7904:15:0;;;;30416:55;;;;;;;7329:2:1;30416:55:0;;;7311:21:1;7368:2;7348:18;;;7341:30;7407:28;7387:18;;;7380:56;7453:18;;30416:55:0;7127:350:1;30416:55:0;30489:16;30497:7;30489;:16::i;:::-;30481:58;;;;;;;7684:2:1;30481:58:0;;;7666:21:1;7723:2;7703:18;;;7696:30;7762:31;7742:18;;;7735:59;7811:18;;30481:58:0;7482:353:1;30481:58:0;30549:12;30564;30568:7;3119:2;18555:23;3512:16;18551:41;;18035:573;30564:12;30549:27;;;;30586:15;30604:12;30608:7;30604:3;:12::i;:::-;30586:30;;;;30627:11;30648:8;30766:4;30760:11;30753:18;;30853:7;30848:3;30845:16;30842:94;;;30893:4;30887;30880:18;30842:94;31063:4;31054:7;31048:4;31039:7;31033:4;31026:5;31015:53;31008:60;;31095:3;31087:36;;;;;;;8042:2:1;31087:36:0;;;8024:21:1;8081:2;8061:18;;;8054:30;8120:22;8100:18;;;8093:50;8160:18;;31087:36:0;7840:344:1;31087:36:0;31144:52;31165:15;31172:7;31165:6;:15::i;:::-;12798:33;3031:2;12798:33;;;;12936:17;;12922:32;;13059:17;;3119:2;13043:34;;12157:936;22602:890;22717:14;22747:6;:11;;22757:1;22747:11;22743:59;;-1:-1:-1;22789:1:0;22774:17;;22743:59;22833:12;22837:7;3119:2;18555:23;3512:16;18551:41;;18035:573;22833:12;22815:30;;:15;;;;:6;:15;:::i;:::-;:30;22811:137;;;22868:68;22884:12;22888:7;22884:3;:12::i;:::-;22868:68;;22898:12;22902:7;3119:2;18555:23;3512:16;18551:41;;18035:573;22898:12;22868:68;;22912:6;22928;22920:15;;22868;:68::i;:::-;22861:76;;;;;;;;;;;:::i;22811:137::-;22975:2;22965:6;:12;;;;22957:50;;;;;;;8391:2:1;22957:50:0;;;8373:21:1;8430:2;8410:18;;;8403:30;8469:27;8449:18;;;8442:55;8514:18;;22957:50:0;8189:349:1;22957:50:0;23088:1;23079:10;;23018:15;23124:12;23128:7;23124:3;:12::i;:::-;23109:27;;;-1:-1:-1;23202:13:0;7378:66;7348:12;;;7327:131;23450:17;;;;23444:24;23440:36;;;-1:-1:-1;;;;;22602:890:0:o;9707:132::-;9781:4;9823:9;9804:28;;:15;9811:7;9804:6;:15::i;:::-;:28;;;;9707:132;-1:-1:-1;;;9707:132:0:o;4722:667::-;4776:13;;4832:2;4817:258;4840:2;4836:1;:6;;;4817:258;;;4860:11;4887:5;:1;4891;4887:5;:::i;:::-;4880:13;;:2;:13;;4860:34;;4917:14;4925:5;4917:7;:14::i;:::-;4908:23;;;;;;4949:1;:7;;4954:2;4949:7;4945:58;;4986:2;4976:12;;;;;4945:58;-1:-1:-1;5044:6:0;;4817:258;;;-1:-1:-1;5138:2:0;5123:260;5146:3;5142:1;:7;;;5123:260;;;5167:11;5194:5;:1;5198;5194:5;:::i;:::-;5187:13;;:2;:13;;5167:34;;5225:14;5233:5;5225:7;:14::i;:::-;5215:24;;;;;;5257:1;:6;;5262:1;5257:6;5253:58;;5294:2;5283:13;;;;;5253:58;-1:-1:-1;5352:6:0;;5123:260;;;;4722:667;;;:::o;8577:465::-;8634:8;8658:15;8665:7;8658:6;:15::i;:::-;:31;;8677:12;8658:31;8654:74;;-1:-1:-1;8712:5:0;;8577:465;-1:-1:-1;8577:465:0:o;8654:74::-;8737:12;8752;8756:7;8752:3;:12::i;:::-;9019:4;9013:11;-1:-1:-1;9000:26:0;;8577:465;-1:-1:-1;;;8577:465:0:o;16598:573::-;16651:11;;3303:20;3074:2;3119;3303:20;:::i;:::-;17118:23;;;;3512:16;17114:41;;16598:573;-1:-1:-1;;16598:573:0:o;21359:741::-;21505:17;21537:9;21550:15;21560:4;21550:9;:15::i;:::-;21534:31;;;21578:9;21591:15;21601:4;21591:9;:15::i;:::-;21575:31;;;21619:9;21632:17;21642:6;21632:9;:17::i;:::-;21616:33;;;21662:9;21675:17;21685:6;21675:9;:17::i;:::-;21728:355;;;9384:34:1;21728:355:0;;;9372:47:1;9449:23;9435:12;;;9428:45;9492:66;9596:3;9592:16;;;9588:25;;9574:12;;;9567:47;9633:17;9666:12;;;9659:24;;;9717:16;;;9713:25;;9699:12;;;9692:47;9769:34;9755:12;;;9748:56;9835:3;9820:13;;;9813:26;9874:16;;;9870:25;;9855:13;;;9848:48;9912:13;;;9905:25;;;;9965:16;;9961:25;;;9946:13;;;9939:48;-1:-1:-1;;8620:3:1;10033:13;;;8608:16;21728:355:0;;;;;;;;;8640:11:1;;;;21728:355:0;;;;;-1:-1:-1;;;;;21359:741:0:o;4199:199::-;4249:14;4286:18;4302:1;4296:2;:7;;;;4286:9;:18::i;:::-;4275:29;;4328:13;;;;;;4340:1;4328:13;4362;4372:2;4362:9;:13::i;:::-;4351:24;;;;4199:199;-1:-1:-1;4199:199:0:o;18782:147::-;18835:7;18900:12;18904:7;3119:2;18555:23;3512:16;18551:41;;18035:573;18900:12;18885;18889:7;18885:3;:12::i;:::-;:27;18878:34;;;;18782:147;;;:::o;3824:203::-;3997:13;;;;;;;;;;;;;;;;;;3879:11;;3926:4;3918:12;;;;;3997:22;;;;;;:::i;:::-;;;;;;;;3824:203;-1:-1:-1;;;3824:203:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:486::-;1061:6;1069;1122:2;1110:9;1101:7;1097:23;1093:32;1090:52;;;1138:1;1135;1128:12;1090:52;1177:9;1164:23;1227:12;1220:5;1216:24;1209:5;1206:35;1196:63;;1255:1;1252;1245:12;1196:63;1278:5;-1:-1:-1;1334:2:1;1319:18;;1306:32;1361:18;1350:30;;1347:50;;;1393:1;1390;1383:12;1347:50;1416:49;1457:7;1448:6;1437:9;1433:22;1416:49;:::i;:::-;1406:59;;;985:486;;;;;:::o;2279:481::-;2320:3;2358:5;2352:12;2385:6;2380:3;2373:19;2410:1;2420:162;2434:6;2431:1;2428:13;2420:162;;;2496:4;2552:13;;;2548:22;;2542:29;2524:11;;;2520:20;;2513:59;2449:12;2420:162;;;2424:3;2627:1;2620:4;2611:6;2606:3;2602:16;2598:27;2591:38;2749:4;2679:66;2674:2;2666:6;2662:15;2658:88;2653:3;2649:98;2645:109;2638:116;;;2279:481;;;;:::o;2765:305::-;2950:12;2942:6;2938:25;2927:9;2920:44;3000:2;2995;2984:9;2980:18;2973:30;2901:4;3020:44;3060:2;3049:9;3045:18;3037:6;3020:44;:::i;:::-;3012:52;2765:305;-1:-1:-1;;;;2765:305:1:o;3257:320::-;3325:6;3378:2;3366:9;3357:7;3353:23;3349:32;3346:52;;;3394:1;3391;3384:12;3346:52;3434:9;3421:23;3467:18;3459:6;3456:30;3453:50;;;3499:1;3496;3489:12;3453:50;3522:49;3563:7;3554:6;3543:9;3539:22;3522:49;:::i;3774:163::-;3841:20;;3901:10;3890:22;;3880:33;;3870:61;;3927:1;3924;3917:12;3870:61;3774:163;;;:::o;3942:539::-;4042:6;4050;4058;4066;4074;4082;4135:3;4123:9;4114:7;4110:23;4106:33;4103:53;;;4152:1;4149;4142:12;4103:53;4175:28;4193:9;4175:28;:::i;:::-;4165:38;;4250:2;4239:9;4235:18;4222:32;4212:42;;4273:37;4306:2;4295:9;4291:18;4273:37;:::i;:::-;4263:47;;4329:37;4362:2;4351:9;4347:18;4329:37;:::i;:::-;4319:47;;4413:3;4402:9;4398:19;4385:33;4375:43;;4437:38;4470:3;4459:9;4455:19;4437:38;:::i;:::-;4427:48;;3942:539;;;;;;;;:::o;4486:217::-;4633:2;4622:9;4615:21;4596:4;4653:44;4693:2;4682:9;4678:18;4670:6;4653:44;:::i;4708:184::-;4760:77;4757:1;4750:88;4857:4;4854:1;4847:15;4881:4;4878:1;4871:15;4897:125;4962:9;;;4983:10;;;4980:36;;;4996:18;;:::i;6741:151::-;6831:4;6824:12;;;6810;;;6806:31;;6849:14;;6846:40;;;6866:18;;:::i;6897:225::-;7001:4;6980:12;;;6994;;;6976:31;7027:22;;;;7068:24;;;7058:58;;7096:18;;:::i;:::-;7058:58;6897:225;;;;:::o;10058:184::-;10110:77;10107:1;10100:88;10207:4;10204:1;10197:15;10231:4;10228:1;10221:15","abiDefinition":[{"inputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"castToHeader","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"}],"name":"formatHeader","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"headerLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"headerVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"headerVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"isHeader","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"nonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetDestination","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetOptimisticSeconds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetOrigin","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetRecipient","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetSender","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"optimisticSeconds","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"recipient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"recipientAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"sender","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"destination(uint40,bytes)":{"notice":"Returns header's destination field"},"headerVersion(uint40,bytes)":{"notice":"Returns header's version field."},"nonce(uint40,bytes)":{"notice":"Returns header's nonce field"},"optimisticSeconds(uint40,bytes)":{"notice":"Returns header's optimistic seconds field"},"origin(uint40,bytes)":{"notice":"Returns header's origin field"},"recipient(uint40,bytes)":{"notice":"Returns header's recipient field as bytes32"},"recipientAddress(uint40,bytes)":{"notice":"Returns header's recipient field as an address"},"sender(uint40,bytes)":{"notice":"Returns header's sender field"}},"notice":"Exposes Header methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"castToHeader\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"}],\"name\":\"formatHeader\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headerLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headerVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"headerVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"isHeader\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetDestination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetOptimisticSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetRecipient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"optimisticSeconds\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"recipientAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"sender\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"destination(uint40,bytes)\":{\"notice\":\"Returns header's destination field\"},\"headerVersion(uint40,bytes)\":{\"notice\":\"Returns header's version field.\"},\"nonce(uint40,bytes)\":{\"notice\":\"Returns header's nonce field\"},\"optimisticSeconds(uint40,bytes)\":{\"notice\":\"Returns header's optimistic seconds field\"},\"origin(uint40,bytes)\":{\"notice\":\"Returns header's origin field\"},\"recipient(uint40,bytes)\":{\"notice\":\"Returns header's recipient field as bytes32\"},\"recipientAddress(uint40,bytes)\":{\"notice\":\"Returns header's recipient field as an address\"},\"sender(uint40,bytes)\":{\"notice\":\"Returns header's sender field\"}},\"notice\":\"Exposes Header methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"HeaderHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0xf0f5bc46d2a6571a325a040b678cc25bc3ab4ea1b98eacc3cc9f0ba97d147e7a\",\"urls\":[\"bzz-raw://8de8fffd2689a9c11fa81c50661308e010e3d652b7f1ef4827b49ad479369af7\",\"dweb:/ipfs/QmVwMooJ23CQFmfb8nnCbhL8BD4aLguBssUUvRL6WBof5W\"]}},\"version\":1}"},"hashes":{"castToHeader(uint40,bytes)":"72a2f4a8","destination(uint40,bytes)":"06dc2d1a","formatHeader(uint32,bytes32,uint32,uint32,bytes32,uint32)":"ac124002","headerLength()":"80bfe8a3","headerVersion()":"5cf682c6","headerVersion(uint40,bytes)":"9a3c57ad","isHeader(bytes)":"aabd9956","nonce(uint40,bytes)":"170cd79b","offsetDestination()":"d2c4428a","offsetNonce()":"569e1eaf","offsetOptimisticSeconds()":"4155c3d5","offsetOrigin()":"320bfc44","offsetRecipient()":"a2ce1f35","offsetSender()":"07fd670d","offsetVersion()":"0c096e8d","optimisticSeconds(uint40,bytes)":"1900888f","origin(uint40,bytes)":"d455d504","recipient(uint40,bytes)":"9b011d88","recipientAddress(uint40,bytes)":"11dca44d","sender(uint40,bytes)":"ce429474"}},"solidity/HeaderHarness.t.sol:SynapseTypes":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ca7b924bfefb7ff8a5a4b66760989e5eb4a6655eee6721b3e93d59c0b12b20ba64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ca7b924bfefb7ff8a5a4b66760989e5eb4a6655eee6721b3e93d59c0b12b20ba64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(SynapseTypes.MESSAGE_HEADER);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.MESSAGE_HEADER);\n    }\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return headerVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    using Header for bytes;\n    using Header for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToHeader(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Header.castToHeader(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    /// @notice Returns header's version field.\n    function headerVersion(uint40 _type, bytes memory _payload) public pure returns (uint16) {\n        return _payload.ref(_type).headerVersion();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).origin();\n    }\n\n    /// @notice Returns header's sender field\n    function sender(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).sender();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).destination();\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).recipient();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).optimisticSeconds();\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(uint40 _type, bytes memory _payload) public pure returns (address) {\n        return _payload.ref(_type).recipientAddress();\n    }\n\n    function isHeader(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToHeader().isHeader();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) public pure returns (bytes memory) {\n        return\n            Header.formatHeader(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function headerLength() public pure returns (uint256) {\n        return Header.HEADER_LENGTH;\n    }\n\n    function headerVersion() public pure returns (uint16) {\n        return Header.HEADER_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return Header.OFFSET_VERSION;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Header.OFFSET_ORIGIN;\n    }\n\n    function offsetSender() public pure returns (uint256) {\n        return Header.OFFSET_SENDER;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Header.OFFSET_NONCE;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Header.OFFSET_DESTINATION;\n    }\n\n    function offsetRecipient() public pure returns (uint256) {\n        return Header.OFFSET_RECIPIENT;\n    }\n\n    function offsetOptimisticSeconds() public pure returns (uint256) {\n        return Header.OFFSET_OPTIMISTIC_SECONDS;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"36652:4460:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;36652:4460:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"36652:4460:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"SynapseTypes\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0xf0f5bc46d2a6571a325a040b678cc25bc3ab4ea1b98eacc3cc9f0ba97d147e7a\",\"urls\":[\"bzz-raw://8de8fffd2689a9c11fa81c50661308e010e3d652b7f1ef4827b49ad479369af7\",\"dweb:/ipfs/QmVwMooJ23CQFmfb8nnCbhL8BD4aLguBssUUvRL6WBof5W\"]}},\"version\":1}"},"hashes":{}},"solidity/HeaderHarness.t.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b7bd711bd47a349b07890835523da23a45c3c2618857af4e789d583c95d1647864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b7bd711bd47a349b07890835523da23a45c3c2618857af4e789d583c95d1647864736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(SynapseTypes.MESSAGE_HEADER);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.MESSAGE_HEADER);\n    }\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return headerVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    using Header for bytes;\n    using Header for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToHeader(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Header.castToHeader(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    /// @notice Returns header's version field.\n    function headerVersion(uint40 _type, bytes memory _payload) public pure returns (uint16) {\n        return _payload.ref(_type).headerVersion();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).origin();\n    }\n\n    /// @notice Returns header's sender field\n    function sender(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).sender();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).destination();\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).recipient();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).optimisticSeconds();\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(uint40 _type, bytes memory _payload) public pure returns (address) {\n        return _payload.ref(_type).recipientAddress();\n    }\n\n    function isHeader(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToHeader().isHeader();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) public pure returns (bytes memory) {\n        return\n            Header.formatHeader(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function headerLength() public pure returns (uint256) {\n        return Header.HEADER_LENGTH;\n    }\n\n    function headerVersion() public pure returns (uint16) {\n        return Header.HEADER_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return Header.OFFSET_VERSION;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Header.OFFSET_ORIGIN;\n    }\n\n    function offsetSender() public pure returns (uint256) {\n        return Header.OFFSET_SENDER;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Header.OFFSET_NONCE;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Header.OFFSET_DESTINATION;\n    }\n\n    function offsetRecipient() public pure returns (uint256) {\n        return Header.OFFSET_RECIPIENT;\n    }\n\n    function offsetOptimisticSeconds() public pure returns (uint256) {\n        return Header.OFFSET_OPTIMISTIC_SECONDS;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35540:1110:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35540:1110:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35540:1110:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0xf0f5bc46d2a6571a325a040b678cc25bc3ab4ea1b98eacc3cc9f0ba97d147e7a\",\"urls\":[\"bzz-raw://8de8fffd2689a9c11fa81c50661308e010e3d652b7f1ef4827b49ad479369af7\",\"dweb:/ipfs/QmVwMooJ23CQFmfb8nnCbhL8BD4aLguBssUUvRL6WBof5W\"]}},\"version\":1}"},"hashes":{}},"solidity/HeaderHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea264697066735822122043d42928f75460b1eefc0e6cf05aa7acb2fedd72a25e76e5185d579e087a201764736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea264697066735822122043d42928f75460b1eefc0e6cf05aa7acb2fedd72a25e76e5185d579e087a201764736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): origin             uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destination        uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_VERSION = 0;\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    uint256 internal constant HEADER_LENGTH = 82;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(SynapseTypes.MESSAGE_HEADER);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a header payload.\n     */\n    function castToHeader(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.MESSAGE_HEADER);\n    }\n\n    /**\n     * @notice Returns a formatted Header payload with provided fields\n     * @param _origin               Domain of origin chain\n     * @param _sender               Address that sent the message\n     * @param _nonce                Message nonce on origin chain\n     * @param _destination          Domain of destination chain\n     * @param _recipient            Address that will receive the message\n     * @param _optimisticSeconds    Optimistic period for message execution\n     * @return Formatted header\n     **/\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Header.\n     */\n    function isHeader(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Check if version exists in the payload\n        if (length \u003c 2) return false;\n        // Check that header version and its length matches\n        return headerVersion(_view) == HEADER_VERSION \u0026\u0026 length == HEADER_LENGTH;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                            HEADER SLICING                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Returns header's version field.\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(OFFSET_VERSION, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    using Header for bytes;\n    using Header for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToHeader(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Header.castToHeader(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    /// @notice Returns header's version field.\n    function headerVersion(uint40 _type, bytes memory _payload) public pure returns (uint16) {\n        return _payload.ref(_type).headerVersion();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).origin();\n    }\n\n    /// @notice Returns header's sender field\n    function sender(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).sender();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).destination();\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).recipient();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).optimisticSeconds();\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(uint40 _type, bytes memory _payload) public pure returns (address) {\n        return _payload.ref(_type).recipientAddress();\n    }\n\n    function isHeader(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToHeader().isHeader();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function formatHeader(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) public pure returns (bytes memory) {\n        return\n            Header.formatHeader(\n                _origin,\n                _sender,\n                _nonce,\n                _destination,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function headerLength() public pure returns (uint256) {\n        return Header.HEADER_LENGTH;\n    }\n\n    function headerVersion() public pure returns (uint16) {\n        return Header.HEADER_VERSION;\n    }\n\n    function offsetVersion() public pure returns (uint256) {\n        return Header.OFFSET_VERSION;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Header.OFFSET_ORIGIN;\n    }\n\n    function offsetSender() public pure returns (uint256) {\n        return Header.OFFSET_SENDER;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Header.OFFSET_NONCE;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Header.OFFSET_DESTINATION;\n    }\n\n    function offsetRecipient() public pure returns (uint256) {\n        return Header.OFFSET_RECIPIENT;\n    }\n\n    function offsetOptimisticSeconds() public pure returns (uint256) {\n        return Header.OFFSET_OPTIMISTIC_SECONDS;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:35508:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:35508:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:35508:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2952:38;;2988:2;2952:38;;;;;168:25:1;;;156:2;141:18;2952:38:0;;;;;;;;3209:46;;3119:2;3209:46;;3346:57;;;:::i;3267:56::-;;;:::i;3469:59::-;;3512:16;3469:59;;3039:37;;3074:2;3039:37;;2540:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2540:94:0;204:258:1;3346:57:0;3031:2;3303:20;3031:2;3119;3303:20;:::i;:::-;3383;;;;:::i;:::-;3346:57;:::o;3267:56::-;3303:20;3074:2;3119;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0xf0f5bc46d2a6571a325a040b678cc25bc3ab4ea1b98eacc3cc9f0ba97d147e7a\",\"urls\":[\"bzz-raw://8de8fffd2689a9c11fa81c50661308e010e3d652b7f1ef4827b49ad479369af7\",\"dweb:/ipfs/QmVwMooJ23CQFmfb8nnCbhL8BD4aLguBssUUvRL6WBof5W\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}