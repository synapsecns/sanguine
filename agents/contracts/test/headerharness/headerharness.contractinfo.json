{"solidity/HeaderHarness.t.sol:HeaderHarness":{"code":"0x608060405234801561001057600080fd5b50610512806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c80637668f03b11610076578063ce03fdab1161005b578063ce03fdab14610163578063e7335c5014610176578063f472a58a1461019957600080fd5b80637668f03b14610130578063bb760a751461014357600080fd5b8063138ac42f146100a85780631e543d64146100e257806344f6891e146100f5578063622db5381461011d575b600080fd5b6100bb6100b63660046103cd565b6101ba565b60405170ffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100bb6100f03660046103ff565b6101cd565b6101086101033660046103cd565b6101fc565b60405163ffffffff90911681526020016100d9565b61010861012b3660046103cd565b610225565b61010861013e3660046103cd565b610240565b6101566101513660046103cd565b610264565b6040516100d9919061049b565b6101086101713660046103cd565b61028a565b6101896101843660046103cd565b6102a9565b60405190151581526020016100d9565b6101ac6101a73660046103cd565b6102bc565b6040519081526020016100d9565b6000806101c6836102e9565b9392505050565b6000806101f18760ff1660018111156101e8576101e861046c565b87878787610331565b979650505050505050565b600061021f61020a836102e9565b60201c6cffffffffffffffffffffffffff1690565b92915050565b600061021f610233836102e9565b60601c64ffffffffff1690565b600061021f61024e836102e9565b70ffffffffffffffffffffffffffffffffff1690565b600061021f610272836102e9565b70ffffffffffffffffffffffffffffffffff1661039a565b600061021f610298836102e9565b60401c68ffffffffffffffffff1690565b6000600160ff608084901c16111561021f565b600061021f6102ca836102e9565b70ffffffffffffffffffffffffffffffffff1660009081526020902090565b6000600160ff608084901c16111561032d576040517f58ebbfbe00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b600063ffffffff821667ffffffff00000000602085901b166bffffffff0000000000000000604087901b166fffffffff000000000000000000000000606089901b1660808a60018111156103875761038761046c565b60ff16901b171717179695505050505050565b60006103b98270ffffffffffffffffffffffffffffffffff1660801c90565b60ff16600181111561021f5761021f61046c565b6000602082840312156103df57600080fd5b5035919050565b803563ffffffff811681146103fa57600080fd5b919050565b600080600080600060a0868803121561041757600080fd5b853560ff8116811461042857600080fd5b9450610436602087016103e6565b9350610444604087016103e6565b9250610452606087016103e6565b9150610460608087016103e6565b90509295509295909350565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208101600283106104d6577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9190529056fea26469706673582212205cbd55d2146d266b7fcd0645ab8b1fceed85fa2f3127421b27621f60cc91ad0964736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100a35760003560e01c80637668f03b11610076578063ce03fdab1161005b578063ce03fdab14610163578063e7335c5014610176578063f472a58a1461019957600080fd5b80637668f03b14610130578063bb760a751461014357600080fd5b8063138ac42f146100a85780631e543d64146100e257806344f6891e146100f5578063622db5381461011d575b600080fd5b6100bb6100b63660046103cd565b6101ba565b60405170ffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100bb6100f03660046103ff565b6101cd565b6101086101033660046103cd565b6101fc565b60405163ffffffff90911681526020016100d9565b61010861012b3660046103cd565b610225565b61010861013e3660046103cd565b610240565b6101566101513660046103cd565b610264565b6040516100d9919061049b565b6101086101713660046103cd565b61028a565b6101896101843660046103cd565b6102a9565b60405190151581526020016100d9565b6101ac6101a73660046103cd565b6102bc565b6040519081526020016100d9565b6000806101c6836102e9565b9392505050565b6000806101f18760ff1660018111156101e8576101e861046c565b87878787610331565b979650505050505050565b600061021f61020a836102e9565b60201c6cffffffffffffffffffffffffff1690565b92915050565b600061021f610233836102e9565b60601c64ffffffffff1690565b600061021f61024e836102e9565b70ffffffffffffffffffffffffffffffffff1690565b600061021f610272836102e9565b70ffffffffffffffffffffffffffffffffff1661039a565b600061021f610298836102e9565b60401c68ffffffffffffffffff1690565b6000600160ff608084901c16111561021f565b600061021f6102ca836102e9565b70ffffffffffffffffffffffffffffffffff1660009081526020902090565b6000600160ff608084901c16111561032d576040517f58ebbfbe00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b600063ffffffff821667ffffffff00000000602085901b166bffffffff0000000000000000604087901b166fffffffff000000000000000000000000606089901b1660808a60018111156103875761038761046c565b60ff16901b171717179695505050505050565b60006103b98270ffffffffffffffffffffffffffffffffff1660801c90565b60ff16600181111561021f5761021f61046c565b6000602082840312156103df57600080fd5b5035919050565b803563ffffffff811681146103fa57600080fd5b919050565b600080600080600060a0868803121561041757600080fd5b853560ff8116811461042857600080fd5b9450610436602087016103e6565b9350610444604087016103e6565b9250610452606087016103e6565b9150610460608087016103e6565b90509295509295909350565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208101600283106104d6577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9190529056fea26469706673582212205cbd55d2146d266b7fcd0645ab8b1fceed85fa2f3127421b27621f60cc91ad0964736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptBody();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(uint256 paddedHeader) public pure returns (MessageFlag) {\n        return HeaderLib.wrapPadded(paddedHeader).flag();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).origin();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).destination();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).optimisticPeriod();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function encodeHeader(uint8 flag_, uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        public\n        pure\n        returns (uint136)\n    {\n        Header header = HeaderLib.encodeHeader(MessageFlag(flag_), origin_, nonce_, destination_, optimisticPeriod_);\n        return Header.unwrap(header);\n    }\n\n    function isHeader(uint256 paddedHeader) public pure returns (bool) {\n        return HeaderLib.isHeader(paddedHeader);\n    }\n\n    function wrapPadded(uint256 paddedHeader) public pure returns (uint136) {\n        Header header = HeaderLib.wrapPadded(paddedHeader);\n        return Header.unwrap(header);\n    }\n\n    function leaf(uint256 paddedHeader) public pure returns (bytes32) {\n        return HeaderLib.wrapPadded(paddedHeader).leaf();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"10918:2575:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"10918:2575:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13177:177;;;;;;:::i;:::-;;:::i;:::-;;;375:36:1;363:49;;;345:68;;333:2;318:18;13177:177:0;;;;;;;;12708:334;;;;;;:::i;:::-;;:::i;12016:144::-;;;;;;:::i;:::-;;:::i;:::-;;;1330:10:1;1318:23;;;1300:42;;1288:2;1273:18;12016:144:0;1156:192:1;11642:134:0;;;;;;:::i;:::-;;:::i;12224:154::-;;;;;;:::i;:::-;;:::i;11455:135::-;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;11827:132::-;;;;;;:::i;:::-;;:::i;13048:123::-;;;;;;:::i;:::-;;:::i;:::-;;;2112:14:1;;2105:22;2087:41;;2075:2;2060:18;13048:123:0;1947:187:1;13360:131:0;;;;;;:::i;:::-;;:::i;:::-;;;2285:25:1;;;2273:2;2258:18;13360:131:0;2139:177:1;13177::0;13240:7;13259:13;13275:34;13296:12;13275:20;:34::i;:::-;13259:50;13177:177;-1:-1:-1;;;13177:177:0:o;12708:334::-;12866:7;12889:13;12905:92;12940:5;12928:18;;;;;;;;;;:::i;:::-;12948:7;12957:6;12965:12;12979:17;12905:22;:92::i;:::-;12889:108;12708:334;-1:-1:-1;;;;;;;12708:334:0:o;12016:144::-;12080:6;12105:48;:34;12126:12;12105:20;:34::i;:::-;6285:5;9909:42;;;;9727:232;12105:48;12098:55;12016:144;-1:-1:-1;;12016:144:0:o;11642:134::-;11701:6;11726:43;:34;11747:12;11726:20;:34::i;:::-;6068:6;9354:37;;;;9177:222;12224:154;12293:6;12318:53;:34;12339:12;12318:20;:34::i;:::-;:51;;10224:6;10023:216;11455:135;11512:11;11542:41;:34;11563:12;11542:20;:34::i;:::-;:39;;;:41::i;11827:132::-;11885:6;11910:42;:34;11931:12;11910:20;:34::i;:::-;6171:5;9626:36;;;;9450:220;13048:123;13109:4;7374:21;7345:51;5963:6;10810:26;;;7345:51;;;13132:32;7216:187;13360:131;13417:7;13443:41;:34;13464:12;13443:20;:34::i;:::-;:39;;8245:20;8401:17;;;8517:2;8504:16;;;8193:343;7855:236;7920:6;7374:21;7345:51;5963:6;10810:26;;;7345:51;;;7981:52;;8017:16;;;;;;;;;;;;;;7981:52;-1:-1:-1;8070:12:0;7855:236::o;6625:519::-;6813:6;7101:26;;;7044:42;6285:5;7044:42;;;;6999:30;6171:5;6999:30;;;;6952:32;6068:6;6952:32;;;;5963:6;6916:5;6910:12;;;;;;;;:::i;:::-;6902:21;;:35;;:82;:127;:184;:225;;6625:519;-1:-1:-1;;;;;;6625:519:0:o;8902:223::-;8954:11;9089:28;9109:6;9089:28;;5963:6;10810:26;;10631:213;9089:28;9077:41;;;;;;;;;;:::i;14:180:1:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;-1:-1:-1;165:23:1;;14:180;-1:-1:-1;14:180:1:o;424:163::-;491:20;;551:10;540:22;;530:33;;520:61;;577:1;574;567:12;520:61;424:163;;;:::o;592:559::-;681:6;689;697;705;713;766:3;754:9;745:7;741:23;737:33;734:53;;;783:1;780;773:12;734:53;822:9;809:23;872:4;865:5;861:16;854:5;851:27;841:55;;892:1;889;882:12;841:55;915:5;-1:-1:-1;939:37:1;972:2;957:18;;939:37;:::i;:::-;929:47;;995:37;1028:2;1017:9;1013:18;995:37;:::i;:::-;985:47;;1051:37;1084:2;1073:9;1069:18;1051:37;:::i;:::-;1041:47;;1107:38;1140:3;1129:9;1125:19;1107:38;:::i;:::-;1097:48;;592:559;;;;;;;;:::o;1353:184::-;1405:77;1402:1;1395:88;1502:4;1499:1;1492:15;1526:4;1523:1;1516:15;1542:400;1689:2;1674:18;;1722:1;1711:13;;1701:201;;1758:77;1755:1;1748:88;1859:4;1856:1;1849:15;1887:4;1884:1;1877:15;1701:201;1911:25;;;1542:400;:::o","abiDefinition":[{"inputs":[],"name":"FlagOutOfRange","type":"error"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint8","name":"flag_","type":"uint8"},{"internalType":"uint32","name":"origin_","type":"uint32"},{"internalType":"uint32","name":"nonce_","type":"uint32"},{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"uint32","name":"optimisticPeriod_","type":"uint32"}],"name":"encodeHeader","outputs":[{"internalType":"uint136","name":"","type":"uint136"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"flag","outputs":[{"internalType":"enum MessageFlag","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"isHeader","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"nonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"optimisticPeriod","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"paddedHeader","type":"uint256"}],"name":"wrapPadded","outputs":[{"internalType":"uint136","name":"","type":"uint136"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"destination(uint256)":{"notice":"Returns header's destination field"},"flag(uint256)":{"notice":"Returns header's flag field"},"nonce(uint256)":{"notice":"Returns header's nonce field"},"optimisticPeriod(uint256)":{"notice":"Returns header's optimistic seconds field"},"origin(uint256)":{"notice":"Returns header's origin field"}},"notice":"Exposes Header methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"FlagOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"flag_\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"origin_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nonce_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod_\",\"type\":\"uint32\"}],\"name\":\"encodeHeader\",\"outputs\":[{\"internalType\":\"uint136\",\"name\":\"\",\"type\":\"uint136\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"enum MessageFlag\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"isHeader\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"optimisticPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paddedHeader\",\"type\":\"uint256\"}],\"name\":\"wrapPadded\",\"outputs\":[{\"internalType\":\"uint136\",\"name\":\"\",\"type\":\"uint136\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"destination(uint256)\":{\"notice\":\"Returns header's destination field\"},\"flag(uint256)\":{\"notice\":\"Returns header's flag field\"},\"nonce(uint256)\":{\"notice\":\"Returns header's nonce field\"},\"optimisticPeriod(uint256)\":{\"notice\":\"Returns header's optimistic seconds field\"},\"origin(uint256)\":{\"notice\":\"Returns header's origin field\"}},\"notice\":\"Exposes Header methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"HeaderHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0x2a2aa869029037df9174fafb460af45439d2f09ff86bd71b6548fa1b94f168b5\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://93c1b77480468caa9ded3c7e01596dba8d5d66f319b222018a23897462c1041b\",\"dweb:/ipfs/QmS5YpdHfPJLu32XhqPbuseb6zHsvs6ehzzYt61WN2QCVy\"]}},\"version\":1}"},"hashes":{"destination(uint256)":"44f6891e","encodeHeader(uint8,uint32,uint32,uint32,uint32)":"1e543d64","flag(uint256)":"bb760a75","isHeader(uint256)":"e7335c50","leaf(uint256)":"f472a58a","nonce(uint256)":"ce03fdab","optimisticPeriod(uint256)":"7668f03b","origin(uint256)":"622db538","wrapPadded(uint256)":"138ac42f"}},"solidity/HeaderHarness.t.sol:HeaderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220830e87b4b5fb4d9d54e1672dc4125ad03f756d12ab93b82e91b042ecb297f85764736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220830e87b4b5fb4d9d54e1672dc4125ad03f756d12ab93b82e91b042ecb297f85764736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// ══════════════════════════════ INVALID CALLER ═══════════════════════════════\n\nerror CallerNotAgentManager();\nerror CallerNotDestination();\nerror CallerNotInbox();\nerror CallerNotSummit();\n\n// ══════════════════════════════ INCORRECT DATA ═══════════════════════════════\n\nerror IncorrectAttestation();\nerror IncorrectAgentDomain();\nerror IncorrectAgentIndex();\nerror IncorrectAgentProof();\nerror IncorrectDataHash();\nerror IncorrectDestinationDomain();\nerror IncorrectOriginDomain();\nerror IncorrectSnapshotProof();\nerror IncorrectSnapshotRoot();\nerror IncorrectState();\nerror IncorrectStatesAmount();\nerror IncorrectVersionLength();\n\nerror IncorrectNonce();\nerror IncorrectSender();\nerror IncorrectRecipient();\n\nerror FlagOutOfRange();\nerror IndexOutOfRange();\nerror NonceOutOfRange();\n\nerror OutdatedNonce();\n\nerror UnformattedAttestation();\nerror UnformattedAttestationReport();\nerror UnformattedBaseMessage();\nerror UnformattedCallData();\nerror UnformattedCallDataPrefix();\nerror UnformattedMessage();\nerror UnformattedReceipt();\nerror UnformattedReceiptBody();\nerror UnformattedReceiptReport();\nerror UnformattedSignature();\nerror UnformattedSnapshot();\nerror UnformattedState();\nerror UnformattedStateReport();\n\n// ═══════════════════════════════ MERKLE TREES ════════════════════════════════\n\nerror LeafNotProven();\nerror MerkleTreeFull();\nerror NotEnoughLeafs();\nerror TreeHeightTooLow();\n\n// ═════════════════════════════ OPTIMISTIC PERIOD ═════════════════════════════\n\nerror BaseClientOptimisticPeriod();\nerror MessageOptimisticPeriod();\nerror SlashAgentOptimisticPeriod();\nerror WithdrawTipsOptimisticPeriod();\nerror ZeroProofMaturity();\n\n// ═══════════════════════════════ AGENT MANAGER ═══════════════════════════════\n\nerror AgentNotGuard();\nerror AgentNotNotary();\n\nerror AgentCantBeAdded();\nerror AgentNotActive();\nerror AgentNotActiveNorUnstaking();\nerror AgentNotFraudulent();\nerror AgentNotUnstaking();\nerror AgentUnknown();\n\nerror DisputeAlreadyResolved();\nerror DisputeNotOpened();\nerror DisputeNotStuck();\nerror GuardInDispute();\nerror NotaryInDispute();\n\nerror MustBeSynapseDomain();\nerror SynapseDomainForbidden();\n\n// ════════════════════════════════ DESTINATION ════════════════════════════════\n\nerror AlreadyExecuted();\nerror AlreadyFailed();\nerror DuplicatedSnapshotRoot();\nerror IncorrectMagicValue();\nerror GasLimitTooLow();\nerror GasSuppliedTooLow();\n\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n\nerror ContentLengthTooBig();\nerror EthTransferFailed();\nerror InsufficientEthBalance();\n\n// ═══════════════════════════════════ TIPS ════════════════════════════════════\n\nerror TipsClaimMoreThanEarned();\nerror TipsClaimZero();\nerror TipsOverflow();\nerror TipsValueTooLow();\n\n// ════════════════════════════════ MEMORY VIEW ════════════════════════════════\n\nerror IndexedTooMuch();\nerror ViewOverrun();\nerror OccupiedMemory();\nerror UnallocatedMemory();\nerror PrecompileOutOfGas();\n\n// ═════════════════════════════════ MULTICALL ═════════════════════════════════\n\nerror MulticallFailed();\n\n/// Header is encoded data with \"general routing information\".\ntype Header is uint136;\n\nusing HeaderLib for Header global;\n\n/// Types of messages supported by Origin-Destination\n/// - Base: message sent by protocol user, contains tips\n/// - Manager: message sent between AgentManager contracts located on different chains, no tips\nenum MessageFlag {\n    Base,\n    Manager\n}\n\nusing HeaderLib for MessageFlag global;\n\n/// Library for formatting _the header part_ of _the messages used by Origin and Destination_.\n/// - Header represents general information for routing a Message for Origin and Destination.\n/// - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n///\n/// # Header stack layout (from highest bits to lowest)\n///\n/// | Position   | Field            | Type   | Bytes | Description                             |\n/// | ---------- | ---------------- | ------ | ----- | --------------------------------------- |\n/// | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     |\n/// | (016..012] | origin           | uint32 | 4     | Domain where message originated         |\n/// | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      |\n/// | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   |\n/// | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\nlibrary HeaderLib {\n    /// @dev Amount of bits to shift to flag field\n    uint136 private constant SHIFT_FLAG = 16 * 8;\n    /// @dev Amount of bits to shift to origin field\n    uint136 private constant SHIFT_ORIGIN = 12 * 8;\n    /// @dev Amount of bits to shift to nonce field\n    uint136 private constant SHIFT_NONCE = 8 * 8;\n    /// @dev Amount of bits to shift to destination field\n    uint136 private constant SHIFT_DESTINATION = 4 * 8;\n\n    /// @notice Returns an encoded header with provided fields\n    /// @param origin_              Domain of origin chain\n    /// @param nonce_               Message nonce on origin chain\n    /// @param destination_         Domain of destination chain\n    /// @param optimisticPeriod_    Optimistic period for message execution\n    function encodeHeader(\n        MessageFlag flag_,\n        uint32 origin_,\n        uint32 nonce_,\n        uint32 destination_,\n        uint32 optimisticPeriod_\n    ) internal pure returns (Header) {\n        // forgefmt: disable-next-item\n        return Header.wrap(\n            uint136(uint8(flag_)) \u003c\u003c SHIFT_FLAG |\n            uint136(origin_) \u003c\u003c SHIFT_ORIGIN |\n            uint136(nonce_) \u003c\u003c SHIFT_NONCE |\n            uint136(destination_) \u003c\u003c SHIFT_DESTINATION |\n            uint136(optimisticPeriod_)\n        );\n    }\n\n    /// @notice Checks that the header is a valid encoded header.\n    function isHeader(uint256 paddedHeader) internal pure returns (bool) {\n        // Check that flag is within range\n        return _flag(paddedHeader) \u003c= uint8(type(MessageFlag).max);\n    }\n\n    /// @notice Wraps the padded encoded request into a Header-typed value.\n    /// @dev The \"padded\" header is simply an encoded header casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded headers\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedHeader) internal pure returns (Header) {\n        // Check that flag is within range\n        if (!isHeader(paddedHeader)) revert FlagOutOfRange();\n        return Header.wrap(uint136(paddedHeader));\n    }\n\n    /// @notice Returns header's hash: a leaf to be inserted in the \"Message mini-Merkle tree\".\n    function leaf(Header header) internal pure returns (bytes32 hashedHeader) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store header in scratch space\n            mstore(0, header)\n            // Compute hash of header padded to 32 bytes\n            hashedHeader := keccak256(0, 32)\n        }\n    }\n\n    // ══════════════════════════════════════════════ HEADER SLICING ═══════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(Header header) internal pure returns (MessageFlag) {\n        // We check that flag is within range when wrapping the header, so this cast is safe\n        return MessageFlag(_flag(Header.unwrap(header)));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_ORIGIN);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_NONCE);\n    }\n\n    /// @notice Returns header's destination field\n    function destination(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header) \u003e\u003e SHIFT_DESTINATION);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(Header header) internal pure returns (uint32) {\n        // Casting to uint32 will truncate the highest bits, which is the behavior we want\n        return uint32(Header.unwrap(header));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns header's flag field without casting to MessageFlag\n    function _flag(uint256 paddedHeader) private pure returns (uint8) {\n        // Casting to uint8 will truncate the highest bits, which is the behavior we want\n        return uint8(paddedHeader \u003e\u003e SHIFT_FLAG);\n    }\n}\n\n/**\n * @notice Exposes Header methods for testing against golang.\n */\ncontract HeaderHarness {\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    /// @notice Returns header's flag field\n    function flag(uint256 paddedHeader) public pure returns (MessageFlag) {\n        return HeaderLib.wrapPadded(paddedHeader).flag();\n    }\n\n    /// @notice Returns header's origin field\n    function origin(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).origin();\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).nonce();\n    }\n\n    /// @notice Returns header's destination field\n    function destination(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).destination();\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticPeriod(uint256 paddedHeader) public pure returns (uint32) {\n        return HeaderLib.wrapPadded(paddedHeader).optimisticPeriod();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function encodeHeader(uint8 flag_, uint32 origin_, uint32 nonce_, uint32 destination_, uint32 optimisticPeriod_)\n        public\n        pure\n        returns (uint136)\n    {\n        Header header = HeaderLib.encodeHeader(MessageFlag(flag_), origin_, nonce_, destination_, optimisticPeriod_);\n        return Header.unwrap(header);\n    }\n\n    function isHeader(uint256 paddedHeader) public pure returns (bool) {\n        return HeaderLib.isHeader(paddedHeader);\n    }\n\n    function wrapPadded(uint256 paddedHeader) public pure returns (uint136) {\n        Header header = HeaderLib.wrapPadded(paddedHeader);\n        return Header.unwrap(header);\n    }\n\n    function leaf(uint256 paddedHeader) public pure returns (bytes32) {\n        return HeaderLib.wrapPadded(paddedHeader).leaf();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"5850:4996:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5850:4996:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5850:4996:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the header part_ of _the messages used by Origin and Destination_. - Header represents general information for routing a Message for Origin and Destination. - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory. # Header stack layout (from highest bits to lowest) | Position   | Field            | Type   | Bytes | Description                             | | ---------- | ---------------- | ------ | ----- | --------------------------------------- | | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     | | (016..012] | origin           | uint32 | 4     | Domain where message originated         | | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      | | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   | | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_DESTINATION":{"details":"Amount of bits to shift to destination field"},"SHIFT_FLAG":{"details":"Amount of bits to shift to flag field"},"SHIFT_NONCE":{"details":"Amount of bits to shift to nonce field"},"SHIFT_ORIGIN":{"details":"Amount of bits to shift to origin field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_DESTINATION\":{\"details\":\"Amount of bits to shift to destination field\"},\"SHIFT_FLAG\":{\"details\":\"Amount of bits to shift to flag field\"},\"SHIFT_NONCE\":{\"details\":\"Amount of bits to shift to nonce field\"},\"SHIFT_ORIGIN\":{\"details\":\"Amount of bits to shift to origin field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the header part_ of _the messages used by Origin and Destination_. - Header represents general information for routing a Message for Origin and Destination. - Header occupies a single storage word, and thus is stored on stack instead of being stored in memory. # Header stack layout (from highest bits to lowest) | Position   | Field            | Type   | Bytes | Description                             | | ---------- | ---------------- | ------ | ----- | --------------------------------------- | | (017..016] | flag             | uint8  | 1     | Flag specifying the type of message     | | (016..012] | origin           | uint32 | 4     | Domain where message originated         | | (012..008] | nonce            | uint32 | 4     | Message nonce on the origin domain      | | (008..004] | destination      | uint32 | 4     | Domain where message will be executed   | | (004..000] | optimisticPeriod | uint32 | 4     | Optimistic period that will be enforced |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/HeaderHarness.t.sol\":\"HeaderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/HeaderHarness.t.sol\":{\"keccak256\":\"0x2a2aa869029037df9174fafb460af45439d2f09ff86bd71b6548fa1b94f168b5\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://93c1b77480468caa9ded3c7e01596dba8d5d66f319b222018a23897462c1041b\",\"dweb:/ipfs/QmS5YpdHfPJLu32XhqPbuseb6zHsvs6ehzzYt61WN2QCVy\"]}},\"version\":1}"},"hashes":{}}}