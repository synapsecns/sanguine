{"solidity/PingPongClient.sol:IMessageRecipient":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = tips.summitTip() + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedTips            Padded encoded paid tips information\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedTips,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        Tips tips = TipsLib.emptyTips();\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Tips.unwrap(tips), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"origin","type":"uint32"},{"internalType":"uint32","name":"nonce","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"proofMaturity","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"receiveBaseMessage","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"notice":"Message recipient needs to implement this function in order to receive cross-chain messages."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"details":"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \"message optimistic period\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.","params":{"content":"Raw bytes content of message","nonce":"Message nonce on the origin domain","origin":"Domain where message originated","proofMaturity":"Message's merkle proof age in seconds","sender":"Sender address on origin chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"proofMaturity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"receiveBaseMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"details\":\"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \\\"message optimistic period\\\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.\",\"params\":{\"content\":\"Raw bytes content of message\",\"nonce\":\"Message nonce on the origin domain\",\"origin\":\"Domain where message originated\",\"proofMaturity\":\"Message's merkle proof age in seconds\",\"sender\":\"Sender address on origin chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"notice\":\"Message recipient needs to implement this function in order to receive cross-chain messages.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"IMessageRecipient\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0x2dfe9f5d08ea139760992cf63728b6ea542fbd8eecbd74f6bfc213f5d6aeca1d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82941da48f3c3321475b9ddd229efd3bebf7cef132849ad2836a152f00373f0e\",\"dweb:/ipfs/QmQmQtKAEv2ujsq5VDLFHmDbxKFP1N9nLGtfgaFWx1eCeH\"]}},\"version\":1}"},"hashes":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":"8d3ea9e7"}},"solidity/PingPongClient.sol:InterfaceOrigin":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = tips.summitTip() + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedTips            Padded encoded paid tips information\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedTips,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        Tips tips = TipsLib.emptyTips();\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Tips.unwrap(tips), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"uint32","name":"optimisticPeriod","type":"uint32"},{"internalType":"uint256","name":"paddedTips","type":"uint256"},{"internalType":"uint256","name":"paddedRequest","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"sendBaseMessage","outputs":[{"internalType":"uint32","name":"messageNonce","type":"uint32"},{"internalType":"bytes32","name":"messageHash","type":"bytes32"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"uint32","name":"optimisticPeriod","type":"uint32"},{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"sendManagerMessage","outputs":[{"internalType":"uint32","name":"messageNonce","type":"uint32"},{"internalType":"bytes32","name":"messageHash","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawTips","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"sendBaseMessage(uint32,bytes32,uint32,uint256,uint256,bytes)":{"notice":"Send a message to the recipient located on destination domain."},"sendManagerMessage(uint32,uint32,bytes)":{"notice":"Send a manager message to the destination domain."},"withdrawTips(address,uint256)":{"notice":"Withdraws locked base message tips to the recipient."}},"version":1},"developerDoc":{"kind":"dev","methods":{"sendBaseMessage(uint32,bytes32,uint32,uint256,uint256,bytes)":{"details":"Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.","params":{"content":"Raw bytes content of message","destination":"Domain of destination chain","optimisticPeriod":"Optimistic period for message execution on destination chain","paddedRequest":"Padded encoded message execution request on destination chain","paddedTips":"Padded encoded paid tips information","recipient":"Address of recipient on destination chain as bytes32"},"returns":{"messageHash":"         Hash of the sent message","messageNonce":"        Nonce of the sent message"}},"sendManagerMessage(uint32,uint32,bytes)":{"details":"This could only be called by AgentManager, which takes care of encoding the calldata payload. Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain so that the AgentManager could verify where the Manager Message came from and how mature is the proof. Note: function is not payable, as no tips are required for sending a manager message.","params":{"destination":"Domain of destination chain","optimisticPeriod":"Optimistic period for message execution on destination chain","payload":"Payload for calling AgentManager on destination chain (with extra security args)"}},"withdrawTips(address,uint256)":{"details":"Could only be called by a local AgentManager.","params":{"amount":"Tips value to withdraw","recipient":"Address to withdraw tips to"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"paddedTips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paddedRequest\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"sendBaseMessage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"messageNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sendManagerMessage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"messageNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"sendBaseMessage(uint32,bytes32,uint32,uint256,uint256,bytes)\":{\"details\":\"Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\",\"params\":{\"content\":\"Raw bytes content of message\",\"destination\":\"Domain of destination chain\",\"optimisticPeriod\":\"Optimistic period for message execution on destination chain\",\"paddedRequest\":\"Padded encoded message execution request on destination chain\",\"paddedTips\":\"Padded encoded paid tips information\",\"recipient\":\"Address of recipient on destination chain as bytes32\"},\"returns\":{\"messageHash\":\"         Hash of the sent message\",\"messageNonce\":\"        Nonce of the sent message\"}},\"sendManagerMessage(uint32,uint32,bytes)\":{\"details\":\"This could only be called by AgentManager, which takes care of encoding the calldata payload. Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain so that the AgentManager could verify where the Manager Message came from and how mature is the proof. Note: function is not payable, as no tips are required for sending a manager message.\",\"params\":{\"destination\":\"Domain of destination chain\",\"optimisticPeriod\":\"Optimistic period for message execution on destination chain\",\"payload\":\"Payload for calling AgentManager on destination chain (with extra security args)\"}},\"withdrawTips(address,uint256)\":{\"details\":\"Could only be called by a local AgentManager.\",\"params\":{\"amount\":\"Tips value to withdraw\",\"recipient\":\"Address to withdraw tips to\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"sendBaseMessage(uint32,bytes32,uint32,uint256,uint256,bytes)\":{\"notice\":\"Send a message to the recipient located on destination domain.\"},\"sendManagerMessage(uint32,uint32,bytes)\":{\"notice\":\"Send a manager message to the destination domain.\"},\"withdrawTips(address,uint256)\":{\"notice\":\"Withdraws locked base message tips to the recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"InterfaceOrigin\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0x2dfe9f5d08ea139760992cf63728b6ea542fbd8eecbd74f6bfc213f5d6aeca1d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82941da48f3c3321475b9ddd229efd3bebf7cef132849ad2836a152f00373f0e\",\"dweb:/ipfs/QmQmQtKAEv2ujsq5VDLFHmDbxKFP1N9nLGtfgaFWx1eCeH\"]}},\"version\":1}"},"hashes":{"sendBaseMessage(uint32,bytes32,uint32,uint256,uint256,bytes)":"f71c4347","sendManagerMessage(uint32,uint32,bytes)":"a1c702a7","withdrawTips(address,uint256)":"4e04e7a7"}},"solidity/PingPongClient.sol:PingPongClient":{"code":"0x60c060405234801561001057600080fd5b50604051610c15380380610c1583398101604081905261002f91610087565b6001600160a01b039182166080521660a052604080514360208083019190915282518083038201815291830190925280519101206000556100ba565b80516001600160a01b038116811461008257600080fd5b919050565b6000806040838503121561009a57600080fd5b6100a38361006b565b91506100b16020840161006b565b90509250929050565b60805160a051610b286100ed600039600081816101df015261028101526000818161016601526105750152610b286000f3fe6080604052600436106100b15760003560e01c8063938b5f3211610069578063b269681d1161004e578063b269681d146101cd578063b475cba314610201578063e3ac3ca01461021757600080fd5b8063938b5f3214610154578063aa402039146101ad57600080fd5b806345a8b8ed1161009a57806345a8b8ed146101075780635ec01e4d1461012b5780638d3ea9e71461014157600080fd5b806308fe5e4e146100b65780632bd56025146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d13660046106d4565b61022d565b005b3480156100e457600080fd5b506100ed610253565b60405163ffffffff90911681526020015b60405180910390f35b34801561011357600080fd5b5061011d60035481565b6040519081526020016100fe565b34801561013757600080fd5b5061011d60005481565b6100d661014f36600461079b565b610269565b34801561016057600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100fe565b3480156101b957600080fd5b506100d66101c8366004610887565b6103ff565b3480156101d957600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b34801561020d57600080fd5b5061011d60015481565b34801561022357600080fd5b5061011d60025481565b61024e8373ffffffffffffffffffffffffffffffffffffffff841683610446565b505050565b6000603c60005461026491906108e1565b905090565b3373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461030c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f50696e67506f6e67436c69656e743a202164657374696e6174696f6e00000000604482015260640160405180910390fd5b600081806020019051810190610322919061091c565b90508060200151156103865760026000815461033d906109b9565b9091555080516040519081527f51c4f05cea43f3d4604f77fd5a656743088090aa726deb5e3a9f670d8da75d659060200160405180910390a16103818685836104c2565b6103f7565b600360008154610395906109b9565b9091555080516040519081527f08d46b5262cb13a84b9421fef5cfd01017e1cb48c879e3fc89acaadf34f2106e9060200160405180910390a1604081015161ffff16156103f7576103f78685600184604001516103f291906109f1565b610446565b505050505050565b60005b8461ffff1681101561043f5761042f8473ffffffffffffffffffffffffffffffffffffffff851684610446565b610438816109b9565b9050610402565b5050505050565b6001805460009182610457836109b9565b919050559050610489848460405180606001604052808581526020016001151581526020018661ffff16815250610530565b6040518181527f14089a5f67ef0667796ead5223612a15d24422be4bdaa19abc32fb26d4c8b3db9060200160405180910390a150505050565b6104f68383604051806060016040528085600001518152602001600015158152602001856040015161ffff16815250610530565b80516040519081527f0a72872b9cfe43d6c13b13553f28d4879e427f3b456545649fd0761fdcbe03119060200160405180910390a1505050565b600080806040805185516020808301919091528601511515818301529085015161ffff16606082015290915060009060800160405160208183030381529060405290507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f71c434787876105b9610629565b8787876040518763ffffffff1660e01b81526004016105dd96959493929190610a13565b60408051808303816000875af11580156105fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061f9190610ac4565b5050505050505050565b6000610633610253565b905060005460405160200161064a91815260200190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012060005590565b63ffffffff8116811461069857600080fd5b50565b803573ffffffffffffffffffffffffffffffffffffffff811681146106bf57600080fd5b919050565b61ffff8116811461069857600080fd5b6000806000606084860312156106e957600080fd5b83356106f481610686565b92506107026020850161069b565b91506040840135610712816106c4565b809150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156107935761079361071d565b604052919050565b600080600080600060a086880312156107b357600080fd5b85356107be81610686565b94506020868101356107cf81610686565b94506040870135935060608701359250608087013567ffffffffffffffff808211156107fa57600080fd5b818901915089601f83011261080e57600080fd5b8135818111156108205761082061071d565b610850847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160161074c565b91508082528a8482850101111561086657600080fd5b80848401858401376000848284010152508093505050509295509295909350565b6000806000806080858703121561089d57600080fd5b84356108a8816106c4565b935060208501356108b881610686565b92506108c66040860161069b565b915060608501356108d6816106c4565b939692955090935050565b600082610917577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b60006060828403121561092e57600080fd5b6040516060810181811067ffffffffffffffff821117156109515761095161071d565b604052825181526020830151801515811461096b57600080fd5b6020820152604083015161097e816106c4565b60408201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036109ea576109ea61098a565b5060010190565b61ffff828116828216039080821115610a0c57610a0c61098a565b5092915050565b600063ffffffff808916835260208881850152818816604085015286606085015273ffffffffffffffffffffffffffffffffffffffff8616608085015260c060a0850152845191508160c085015260005b82811015610a805785810182015185820160e001528101610a64565b5050600060e0828501015260e07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116840101915050979650505050505050565b60008060408385031215610ad757600080fd5b8251610ae281610686565b602093909301519294929350505056fea264697066735822122003af4cda988cbd26496a3e0f68fbe5cbdfc6fef37ded6d8c22535199a4ce5c9264736f6c63430008110033","runtime-code":"0x6080604052600436106100b15760003560e01c8063938b5f3211610069578063b269681d1161004e578063b269681d146101cd578063b475cba314610201578063e3ac3ca01461021757600080fd5b8063938b5f3214610154578063aa402039146101ad57600080fd5b806345a8b8ed1161009a57806345a8b8ed146101075780635ec01e4d1461012b5780638d3ea9e71461014157600080fd5b806308fe5e4e146100b65780632bd56025146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d13660046106d4565b61022d565b005b3480156100e457600080fd5b506100ed610253565b60405163ffffffff90911681526020015b60405180910390f35b34801561011357600080fd5b5061011d60035481565b6040519081526020016100fe565b34801561013757600080fd5b5061011d60005481565b6100d661014f36600461079b565b610269565b34801561016057600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100fe565b3480156101b957600080fd5b506100d66101c8366004610887565b6103ff565b3480156101d957600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b34801561020d57600080fd5b5061011d60015481565b34801561022357600080fd5b5061011d60025481565b61024e8373ffffffffffffffffffffffffffffffffffffffff841683610446565b505050565b6000603c60005461026491906108e1565b905090565b3373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461030c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f50696e67506f6e67436c69656e743a202164657374696e6174696f6e00000000604482015260640160405180910390fd5b600081806020019051810190610322919061091c565b90508060200151156103865760026000815461033d906109b9565b9091555080516040519081527f51c4f05cea43f3d4604f77fd5a656743088090aa726deb5e3a9f670d8da75d659060200160405180910390a16103818685836104c2565b6103f7565b600360008154610395906109b9565b9091555080516040519081527f08d46b5262cb13a84b9421fef5cfd01017e1cb48c879e3fc89acaadf34f2106e9060200160405180910390a1604081015161ffff16156103f7576103f78685600184604001516103f291906109f1565b610446565b505050505050565b60005b8461ffff1681101561043f5761042f8473ffffffffffffffffffffffffffffffffffffffff851684610446565b610438816109b9565b9050610402565b5050505050565b6001805460009182610457836109b9565b919050559050610489848460405180606001604052808581526020016001151581526020018661ffff16815250610530565b6040518181527f14089a5f67ef0667796ead5223612a15d24422be4bdaa19abc32fb26d4c8b3db9060200160405180910390a150505050565b6104f68383604051806060016040528085600001518152602001600015158152602001856040015161ffff16815250610530565b80516040519081527f0a72872b9cfe43d6c13b13553f28d4879e427f3b456545649fd0761fdcbe03119060200160405180910390a1505050565b600080806040805185516020808301919091528601511515818301529085015161ffff16606082015290915060009060800160405160208183030381529060405290507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f71c434787876105b9610629565b8787876040518763ffffffff1660e01b81526004016105dd96959493929190610a13565b60408051808303816000875af11580156105fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061f9190610ac4565b5050505050505050565b6000610633610253565b905060005460405160200161064a91815260200190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012060005590565b63ffffffff8116811461069857600080fd5b50565b803573ffffffffffffffffffffffffffffffffffffffff811681146106bf57600080fd5b919050565b61ffff8116811461069857600080fd5b6000806000606084860312156106e957600080fd5b83356106f481610686565b92506107026020850161069b565b91506040840135610712816106c4565b809150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156107935761079361071d565b604052919050565b600080600080600060a086880312156107b357600080fd5b85356107be81610686565b94506020868101356107cf81610686565b94506040870135935060608701359250608087013567ffffffffffffffff808211156107fa57600080fd5b818901915089601f83011261080e57600080fd5b8135818111156108205761082061071d565b610850847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160161074c565b91508082528a8482850101111561086657600080fd5b80848401858401376000848284010152508093505050509295509295909350565b6000806000806080858703121561089d57600080fd5b84356108a8816106c4565b935060208501356108b881610686565b92506108c66040860161069b565b915060608501356108d6816106c4565b939692955090935050565b600082610917577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b60006060828403121561092e57600080fd5b6040516060810181811067ffffffffffffffff821117156109515761095161071d565b604052825181526020830151801515811461096b57600080fd5b6020820152604083015161097e816106c4565b60408201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036109ea576109ea61098a565b5060010190565b61ffff828116828216039080821115610a0c57610a0c61098a565b5092915050565b600063ffffffff808916835260208881850152818816604085015286606085015273ffffffffffffffffffffffffffffffffffffffff8616608085015260c060a0850152845191508160c085015260005b82811015610a805785810182015185820160e001528101610a64565b5050600060e0828501015260e07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116840101915050979650505050505050565b60008060408385031215610ad757600080fd5b8251610ae281610686565b602093909301519294929350505056fea264697066735822122003af4cda988cbd26496a3e0f68fbe5cbdfc6fef37ded6d8c22535199a4ce5c9264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = tips.summitTip() + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedTips            Padded encoded paid tips information\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedTips,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        Tips tips = TipsLib.emptyTips();\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Tips.unwrap(tips), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"17657:7568:0:-:0;;;20463:218;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;20524:16:0;;;;;20550:26;;;20648:24;;;20659:12;20648:24;;;;640:25:1;;;;20648:24:0;;;;;;;;;613:18:1;;;20648:24:0;;;20638:35;;;;;20630:44;20621:53;17657:7568;;14:177:1;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;494:177::-;17657:7568:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"17657:7568:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22516:156;;;;;;;;;;-1:-1:-1;22516:156:0;;;;;:::i;:::-;;:::i;:::-;;23012:175;;;;;;;;;;;;;:::i;:::-;;;1100:10:1;1088:23;;;1070:42;;1058:2;1043:18;23012:175:0;;;;;;;;19123:28;;;;;;;;;;;;;;;;;;;1269:25:1;;;1257:2;1242:18;19123:28:0;1123:177:1;18713:21:0;;;;;;;;;;;;;;;;21043:818;;;;;;:::i;:::-;;:::i;18233:31::-;;;;;;;;;;;;;;;;;;3246:42:1;3234:55;;;3216:74;;3204:2;3189:18;18233:31:0;3070:226:1;21867:239:0;;;;;;;;;;-1:-1:-1;21867:239:0;;;;;:::i;:::-;;:::i;18340:36::-;;;;;;;;;;;;;;;18789:24;;;;;;;;;;;;;;;;18964:28;;;;;;;;;;;;;;;;22516:156;22607:58;22613:12;22627:26;;;22657:7;22607:5;:58::i;:::-;22516:156;;;:::o;23012:175::-;23065:13;23170:9;23161:6;;:18;;;;:::i;:::-;23147:33;;23012:175;:::o;21043:818::-;21197:10;:25;21211:11;21197:25;;21189:66;;;;;;;4377:2:1;21189:66:0;;;4359:21:1;4416:2;4396:18;;;4389:30;4455;4435:18;;;4428:58;4503:18;;21189:66:0;;;;;;;;21265:30;21309:7;21298:38;;;;;;;;;;;;:::i;:::-;21265:71;;21350:7;:14;;;21346:509;;;21414:13;;21412:15;;;;;:::i;:::-;;;;-1:-1:-1;21459:14:0;;21446:28;;1269:25:1;;;21446:28:0;;1257:2:1;1242:18;21446:28:0;;;;;;;21518:31;21524:7;21533:6;21541:7;21518:5;:31::i;:::-;21346:509;;;21614:13;;21612:15;;;;;:::i;:::-;;;;-1:-1:-1;21659:14:0;;21646:28;;1269:25:1;;;21646:28:0;;1257:2:1;1242:18;21646:28:0;;;;;;;21747:15;;;;:20;;;21743:102;;21787:43;21793:7;21802:6;21828:1;21810:7;:15;;;:19;;;;:::i;:::-;21787:5;:43::i;:::-;21179:682;21043:818;;;;;:::o;21867:239::-;21982:9;21977:123;22001:9;21997:13;;:1;:13;21977:123;;;22031:58;22037:12;22051:26;;;22081:7;22031:5;:58::i;:::-;22012:3;;;:::i;:::-;;;21977:123;;;;21867:239;;;;:::o;24613:270::-;24720:9;:11;;24703:14;;;24720:11;;;:::i;:::-;;;;;24703:28;;24741:104;24754:12;24768:9;24779:65;;;;;;;;24804:6;24779:65;;;;24820:4;24779:65;;;;;;24835:7;24779:65;;;;;24741:12;:104::i;:::-;24860:16;;1269:25:1;;;24860:16:0;;1257:2:1;1242:18;24860:16:0;;;;;;;24693:190;24613:270;;;:::o;24928:295::-;25034:143;25060:12;25074:9;25085:82;;;;;;;;25110:7;:14;;;25085:82;;;;25134:5;25085:82;;;;;;25150:7;:15;;;25085:82;;;;;25034:12;:143::i;:::-;25201:14;;25192:24;;1269:25:1;;;25192:24:0;;1257:2:1;1242:18;25192:24:0;;;;;;;24928:295;;;:::o;24073:489::-;24186:9;24286:15;;24367:19;;;6065:13:1;;24367:19:0;;;;6047:32:1;;;;6137:17;;6131:24;6124:32;6117:40;6095:20;;;6088:70;6206:17;;;6200:24;6226:6;6196:37;6174:20;;;6167:67;24286:48:0;;-1:-1:-1;24344:20:0;;6020:18:1;;24367:19:0;;;;;;;;;;;;24344:42;;24412:6;24396:39;;;24449:12;24463:9;24474:18;:16;:18::i;:::-;24506:4;24528:7;24538;24396:159;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;24176:386;;;24073:489;;;:::o;23585:256::-;23631:13;23722:22;:20;:22::i;:::-;23713:31;;23825:6;;23814:18;;;;;;1269:25:1;;1257:2;1242:18;;1123:177;23814:18:0;;;;;;;;;;;;;;23804:29;;23814:18;23804:29;;;;23796:38;23787:47;23585:256;:::o;14:121:1:-;99:10;92:5;88:22;81:5;78:33;68:61;;125:1;122;115:12;68:61;14:121;:::o;140:196::-;208:20;;268:42;257:54;;247:65;;237:93;;326:1;323;316:12;237:93;140:196;;;:::o;341:117::-;426:6;419:5;415:18;408:5;405:29;395:57;;448:1;445;438:12;463:458;538:6;546;554;607:2;595:9;586:7;582:23;578:32;575:52;;;623:1;620;613:12;575:52;662:9;649:23;681:30;705:5;681:30;:::i;:::-;730:5;-1:-1:-1;754:38:1;788:2;773:18;;754:38;:::i;:::-;744:48;;844:2;833:9;829:18;816:32;857;881:7;857:32;:::i;:::-;908:7;898:17;;;463:458;;;;;:::o;1305:184::-;1357:77;1354:1;1347:88;1454:4;1451:1;1444:15;1478:4;1475:1;1468:15;1494:334;1565:2;1559:9;1621:2;1611:13;;1626:66;1607:86;1595:99;;1724:18;1709:34;;1745:22;;;1706:62;1703:88;;;1771:18;;:::i;:::-;1807:2;1800:22;1494:334;;-1:-1:-1;1494:334:1:o;1833:1232::-;1935:6;1943;1951;1959;1967;2020:3;2008:9;1999:7;1995:23;1991:33;1988:53;;;2037:1;2034;2027:12;1988:53;2076:9;2063:23;2095:30;2119:5;2095:30;:::i;:::-;2144:5;-1:-1:-1;2168:2:1;2207:18;;;2194:32;2235;2194;2235;:::i;:::-;2286:7;-1:-1:-1;2340:2:1;2325:18;;2312:32;;-1:-1:-1;2391:2:1;2376:18;;2363:32;;-1:-1:-1;2446:3:1;2431:19;;2418:33;2470:18;2500:14;;;2497:34;;;2527:1;2524;2517:12;2497:34;2565:6;2554:9;2550:22;2540:32;;2610:7;2603:4;2599:2;2595:13;2591:27;2581:55;;2632:1;2629;2622:12;2581:55;2668:2;2655:16;2690:2;2686;2683:10;2680:36;;;2696:18;;:::i;:::-;2738:112;2846:2;2777:66;2770:4;2766:2;2762:13;2758:86;2754:95;2738:112;:::i;:::-;2725:125;;2873:2;2866:5;2859:17;2913:7;2908:2;2903;2899;2895:11;2891:20;2888:33;2885:53;;;2934:1;2931;2924:12;2885:53;2989:2;2984;2980;2976:11;2971:2;2964:5;2960:14;2947:45;3033:1;3028:2;3023;3016:5;3012:14;3008:23;3001:34;;3054:5;3044:15;;;;;1833:1232;;;;;;;;:::o;3301:598::-;3384:6;3392;3400;3408;3461:3;3449:9;3440:7;3436:23;3432:33;3429:53;;;3478:1;3475;3468:12;3429:53;3517:9;3504:23;3536:30;3560:5;3536:30;:::i;:::-;3585:5;-1:-1:-1;3642:2:1;3627:18;;3614:32;3655;3614;3655;:::i;:::-;3706:7;-1:-1:-1;3732:38:1;3766:2;3751:18;;3732:38;:::i;:::-;3722:48;;3822:2;3811:9;3807:18;3794:32;3835;3859:7;3835:32;:::i;:::-;3301:598;;;;-1:-1:-1;3301:598:1;;-1:-1:-1;;3301:598:1:o;3904:266::-;3936:1;3962;3952:189;;3997:77;3994:1;3987:88;4098:4;4095:1;4088:15;4126:4;4123:1;4116:15;3952:189;-1:-1:-1;4155:9:1;;3904:266::o;4532:735::-;4634:6;4687:2;4675:9;4666:7;4662:23;4658:32;4655:52;;;4703:1;4700;4693:12;4655:52;4736:2;4730:9;4778:2;4770:6;4766:15;4847:6;4835:10;4832:22;4811:18;4799:10;4796:34;4793:62;4790:88;;;4858:18;;:::i;:::-;4894:2;4887:22;4933:16;;4918:32;;4993:2;4978:18;;4972:25;5033:13;;5026:21;5016:32;;5006:60;;5062:1;5059;5052:12;5006:60;5094:2;5082:15;;5075:30;5150:2;5135:18;;5129:25;5163:32;5129:25;5163:32;:::i;:::-;5223:2;5211:15;;5204:32;5215:6;4532:735;-1:-1:-1;;;4532:735:1:o;5272:184::-;5324:77;5321:1;5314:88;5421:4;5418:1;5411:15;5445:4;5442:1;5435:15;5461:195;5500:3;5531:66;5524:5;5521:77;5518:103;;5601:18;;:::i;:::-;-1:-1:-1;5648:1:1;5637:13;;5461:195::o;5661:171::-;5729:6;5768:10;;;5756;;;5752:27;;5791:12;;;5788:38;;;5806:18;;:::i;:::-;5788:38;5661:171;;;;:::o;6245:1059::-;6491:4;6520:10;6569:2;6561:6;6557:15;6546:9;6539:34;6592:2;6630:6;6625:2;6614:9;6610:18;6603:34;6685:2;6677:6;6673:15;6668:2;6657:9;6653:18;6646:43;6725:6;6720:2;6709:9;6705:18;6698:34;6781:42;6773:6;6769:55;6763:3;6752:9;6748:19;6741:84;6862:3;6856;6845:9;6841:19;6834:32;6895:6;6889:13;6875:27;;6939:6;6933:3;6922:9;6918:19;6911:35;6964:1;6974:141;6988:6;6985:1;6982:13;6974:141;;;7084:14;;;7080:23;;7074:30;7049:17;;;7068:3;7045:27;7038:67;7003:10;;6974:141;;;6978:3;;7165:1;7159:3;7150:6;7139:9;7135:22;7131:32;7124:43;7294:3;7224:66;7219:2;7211:6;7207:15;7203:88;7192:9;7188:104;7184:114;7176:122;;;6245:1059;;;;;;;;;:::o;7309:310::-;7387:6;7395;7448:2;7436:9;7427:7;7423:23;7419:32;7416:52;;;7464:1;7461;7454:12;7416:52;7496:9;7490:16;7515:30;7539:5;7515:30;:::i;:::-;7609:2;7594:18;;;;7588:25;7564:5;;7588:25;;-1:-1:-1;;;7309:310:1:o","abiDefinition":[{"inputs":[{"internalType":"address","name":"origin_","type":"address"},{"internalType":"address","name":"destination_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PingReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PingSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PongReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PongSent","type":"event"},{"inputs":[],"name":"destination","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint16","name":"counter","type":"uint16"}],"name":"doPing","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"pingCount","type":"uint16"},{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint16","name":"counter","type":"uint16"}],"name":"doPings","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"nextOptimisticPeriod","outputs":[{"internalType":"uint32","name":"period","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"origin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pingsReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pingsSent","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pongsReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"random","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"origin_","type":"uint32"},{"internalType":"uint32","name":"","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"receiveBaseMessage","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"events":{"PingReceived(uint256)":{"notice":"Emitted when a Ping message is received. Will always send a Pong message back."},"PingSent(uint256)":{"notice":"Emitted when a Ping message is sent. Triggered externally, or by receveing a Pong message with instructions to do more pings."},"PongReceived(uint256)":{"notice":"Emitted when a Pong message is received. Will initiate a new Ping, if the counter in the message is non-zero."},"PongSent(uint256)":{"notice":"Emitted when a Pong message is sent. Triggered whenever a Ping message is received."}},"kind":"user","methods":{"destination()":{"notice":"Local chain Destination: used for receiving messages"},"doPing(uint32,address,uint16)":{"notice":"Send a Ping message to destination chain. Upon receiving a Ping, a Pong message will be sent back. If `counter \u003e 0`, this process will be repeated when the Pong message is received."},"origin()":{"notice":"Local chain Origin: used for sending messages"},"pingsReceived()":{"notice":"Amount of \"Ping\" messages received. Every received Ping message leads to sending a Pong message back to initial sender."},"pingsSent()":{"notice":"Amount of \"Ping\" messages sent."},"pongsReceived()":{"notice":"Amount of \"Pong\" messages received. When all messages are delivered, should be equal to `pingsSent`"},"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"notice":"Message recipient needs to implement this function in order to receive cross-chain messages."}},"version":1},"developerDoc":{"kind":"dev","methods":{"doPing(uint32,address,uint16)":{"params":{"counter":"Additional amount of Ping-Pong rounds to conclude","destination_":"Chain to send Ping message to","recipient":"Recipient of Ping message"}},"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"details":"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \"message optimistic period\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.","params":{"content":"Raw bytes content of message","nonce":"Message nonce on the origin domain","origin":"Domain where message originated","proofMaturity":"Message's merkle proof age in seconds","sender":"Sender address on origin chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PingReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PingSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PongReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PongSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"counter\",\"type\":\"uint16\"}],\"name\":\"doPing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"pingCount\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"counter\",\"type\":\"uint16\"}],\"name\":\"doPings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOptimisticPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pingsReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pingsSent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pongsReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"receiveBaseMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"doPing(uint32,address,uint16)\":{\"params\":{\"counter\":\"Additional amount of Ping-Pong rounds to conclude\",\"destination_\":\"Chain to send Ping message to\",\"recipient\":\"Recipient of Ping message\"}},\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"details\":\"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \\\"message optimistic period\\\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.\",\"params\":{\"content\":\"Raw bytes content of message\",\"nonce\":\"Message nonce on the origin domain\",\"origin\":\"Domain where message originated\",\"proofMaturity\":\"Message's merkle proof age in seconds\",\"sender\":\"Sender address on origin chain\"}}},\"version\":1},\"userdoc\":{\"events\":{\"PingReceived(uint256)\":{\"notice\":\"Emitted when a Ping message is received. Will always send a Pong message back.\"},\"PingSent(uint256)\":{\"notice\":\"Emitted when a Ping message is sent. Triggered externally, or by receveing a Pong message with instructions to do more pings.\"},\"PongReceived(uint256)\":{\"notice\":\"Emitted when a Pong message is received. Will initiate a new Ping, if the counter in the message is non-zero.\"},\"PongSent(uint256)\":{\"notice\":\"Emitted when a Pong message is sent. Triggered whenever a Ping message is received.\"}},\"kind\":\"user\",\"methods\":{\"destination()\":{\"notice\":\"Local chain Destination: used for receiving messages\"},\"doPing(uint32,address,uint16)\":{\"notice\":\"Send a Ping message to destination chain. Upon receiving a Ping, a Pong message will be sent back. If `counter \u003e 0`, this process will be repeated when the Pong message is received.\"},\"origin()\":{\"notice\":\"Local chain Origin: used for sending messages\"},\"pingsReceived()\":{\"notice\":\"Amount of \\\"Ping\\\" messages received. Every received Ping message leads to sending a Pong message back to initial sender.\"},\"pingsSent()\":{\"notice\":\"Amount of \\\"Ping\\\" messages sent.\"},\"pongsReceived()\":{\"notice\":\"Amount of \\\"Pong\\\" messages received. When all messages are delivered, should be equal to `pingsSent`\"},\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"notice\":\"Message recipient needs to implement this function in order to receive cross-chain messages.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"PingPongClient\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0x2dfe9f5d08ea139760992cf63728b6ea542fbd8eecbd74f6bfc213f5d6aeca1d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82941da48f3c3321475b9ddd229efd3bebf7cef132849ad2836a152f00373f0e\",\"dweb:/ipfs/QmQmQtKAEv2ujsq5VDLFHmDbxKFP1N9nLGtfgaFWx1eCeH\"]}},\"version\":1}"},"hashes":{"destination()":"b269681d","doPing(uint32,address,uint16)":"08fe5e4e","doPings(uint16,uint32,address,uint16)":"aa402039","nextOptimisticPeriod()":"2bd56025","origin()":"938b5f32","pingsReceived()":"e3ac3ca0","pingsSent()":"b475cba3","pongsReceived()":"45a8b8ed","random()":"5ec01e4d","receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":"8d3ea9e7"}},"solidity/PingPongClient.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122004943b43661932bbc253b4fbedded4a0f437ec8604d582d69061a459363be04664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122004943b43661932bbc253b4fbedded4a0f437ec8604d582d69061a459363be04664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = tips.summitTip() + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedTips            Padded encoded paid tips information\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedTips,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        Tips tips = TipsLib.emptyTips();\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Tips.unwrap(tips), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"1232:1772:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1232:1772:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1232:1772:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_GAS_DROP":{"details":"Amount of bits to shift to gasDrop field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_GAS_DROP\":{\"details\":\"Amount of bits to shift to gasDrop field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0x2dfe9f5d08ea139760992cf63728b6ea542fbd8eecbd74f6bfc213f5d6aeca1d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82941da48f3c3321475b9ddd229efd3bebf7cef132849ad2836a152f00373f0e\",\"dweb:/ipfs/QmQmQtKAEv2ujsq5VDLFHmDbxKFP1N9nLGtfgaFWx1eCeH\"]}},\"version\":1}"},"hashes":{}},"solidity/PingPongClient.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206f4a65acf0f1fe720ecdf5c37600706f19a4e4763a2593b2534ef6cfa65e5ec864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206f4a65acf0f1fe720ecdf5c37600706f19a4e4763a2593b2534ef6cfa65e5ec864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = tips.summitTip() + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedTips            Padded encoded paid tips information\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedTips,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        Tips tips = TipsLib.emptyTips();\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Tips.unwrap(tips), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"8992:4010:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8992:4010:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8992:4010:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"# Tips Library for formatting _the tips part_ of _the base messages_. ## How the tips are awarded Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible. ### Summit tips Split between:     - Guard posting a snapshot with state ST_G for the origin chain.     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.     - Notary posting a message receipt after it is executed on destination chain. ### Attestation tips Paid to:     - Notary posting attestation A to destination chain. ### Execution tips Paid to:     - First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not. ### Delivery tips. Paid to:     - Executor who successfully executed the message on destination chain. ## Tips encoding - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory. - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency. # Tips stack layout (from highest bits to lowest) | Position   | Field          | Type   | Bytes | Description                                                | | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- | | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            | | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract | | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       | | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_ATTESTATION_TIP":{"details":"Amount of bits to shift to attestationTip field"},"SHIFT_EXECUTION_TIP":{"details":"Amount of bits to shift to executionTip field"},"SHIFT_SUMMIT_TIP":{"details":"Amount of bits to shift to summitTip field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_ATTESTATION_TIP\":{\"details\":\"Amount of bits to shift to attestationTip field\"},\"SHIFT_EXECUTION_TIP\":{\"details\":\"Amount of bits to shift to executionTip field\"},\"SHIFT_SUMMIT_TIP\":{\"details\":\"Amount of bits to shift to summitTip field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"# Tips Library for formatting _the tips part_ of _the base messages_. ## How the tips are awarded Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible. ### Summit tips Split between:     - Guard posting a snapshot with state ST_G for the origin chain.     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.     - Notary posting a message receipt after it is executed on destination chain. ### Attestation tips Paid to:     - Notary posting attestation A to destination chain. ### Execution tips Paid to:     - First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not. ### Delivery tips. Paid to:     - Executor who successfully executed the message on destination chain. ## Tips encoding - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory. - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. \u003e The only downside is that the \\\"real tip values\\\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency. # Tips stack layout (from highest bits to lowest) | Position   | Field          | Type   | Bytes | Description                                                | | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- | | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            | | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract | | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       | | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0x2dfe9f5d08ea139760992cf63728b6ea542fbd8eecbd74f6bfc213f5d6aeca1d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82941da48f3c3321475b9ddd229efd3bebf7cef132849ad2836a152f00373f0e\",\"dweb:/ipfs/QmQmQtKAEv2ujsq5VDLFHmDbxKFP1N9nLGtfgaFWx1eCeH\"]}},\"version\":1}"},"hashes":{}},"solidity/PingPongClient.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a45afdf8a04952bde82a5f74044bd2e899e0c0ae369b830bfe10dc902b8e275a64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a45afdf8a04952bde82a5f74044bd2e899e0c0ae369b830bfe10dc902b8e275a64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64,uint96): 8+12\nuint256 constant REQUEST_LENGTH = 20;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n\n/// Tips is encoded data with \"tips paid for sending a base message\".\n/// Note: even though uint256 is also an underlying type for MemView, Tips is stored ON STACK.\ntype Tips is uint256;\n\nusing TipsLib for Tips global;\n\n/// # Tips\n/// Library for formatting _the tips part_ of _the base messages_.\n///\n/// ## How the tips are awarded\n/// Tips are paid for sending a base message, and are split across all the agents that\n/// made the message execution on destination chain possible.\n/// ### Summit tips\n/// Split between:\n///     - Guard posting a snapshot with state ST_G for the origin chain.\n///     - Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n///     - Notary posting a message receipt after it is executed on destination chain.\n/// ### Attestation tips\n/// Paid to:\n///     - Notary posting attestation A to destination chain.\n/// ### Execution tips\n/// Paid to:\n///     - First executor performing a valid execution attempt (correct proofs, optimistic period over),\n///      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n/// ### Delivery tips.\n/// Paid to:\n///     - Executor who successfully executed the message on destination chain.\n///\n/// ## Tips encoding\n/// - Tips occupy a single storage word, and thus are stored on stack instead of being stored in memory.\n/// - The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n/// - Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n/// \u003e The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n/// the chains with the most expensive gas currency.\n/// # Tips stack layout (from highest bits to lowest)\n///\n/// | Position   | Field          | Type   | Bytes | Description                                                |\n/// | ---------- | -------------- | ------ | ----- | ---------------------------------------------------------- |\n/// | (032..024] | summitTip      | uint64 | 8     | Tip for agents interacting with Summit contract            |\n/// | (024..016] | attestationTip | uint64 | 8     | Tip for Notary posting attestation to Destination contract |\n/// | (016..008] | executionTip   | uint64 | 8     | Tip for valid execution attempt on destination chain       |\n/// | (008..000] | deliveryTip    | uint64 | 8     | Tip for successful message delivery on destination chain   |\n\nlibrary TipsLib {\n    /// @dev Amount of bits to shift to summitTip field\n    uint256 private constant SHIFT_SUMMIT_TIP = 24 * 8;\n    /// @dev Amount of bits to shift to attestationTip field\n    uint256 private constant SHIFT_ATTESTATION_TIP = 16 * 8;\n    /// @dev Amount of bits to shift to executionTip field\n    uint256 private constant SHIFT_EXECUTION_TIP = 8 * 8;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /// @notice Returns encoded tips with the given fields\n    /// @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n    /// @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n    /// @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n    /// @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n    function encodeTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (Tips)\n    {\n        return Tips.wrap(\n            uint256(summitTip_) \u003c\u003c SHIFT_SUMMIT_TIP | uint256(attestationTip_) \u003c\u003c SHIFT_ATTESTATION_TIP\n                | uint256(executionTip_) \u003c\u003c SHIFT_EXECUTION_TIP | uint256(deliveryTip_)\n        );\n    }\n\n    /// @notice Wraps the padded encoded tips into a Tips-typed value.\n    /// @dev There is no actual padding here, as the underlying type is already uint256,\n    /// but we include this function for consistency and to be future-proof, if tips will eventually use anything\n    /// smaller than uint256.\n    function wrapPadded(uint256 paddedTips) internal pure returns (Tips) {\n        return Tips.wrap(paddedTips);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (Tips) {\n        return Tips.wrap(0);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_SUMMIT_TIP);\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_ATTESTATION_TIP);\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips) \u003e\u003e SHIFT_EXECUTION_TIP);\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Tips.unwrap(tips));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        value_ = tips.summitTip() + tips.attestationTip() + tips.executionTip() + tips.deliveryTip();\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedTips            Padded encoded paid tips information\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedTips,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        Tips tips = TipsLib.emptyTips();\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Tips.unwrap(tips), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"13004:350:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;13004:350:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"13004:350:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0x2dfe9f5d08ea139760992cf63728b6ea542fbd8eecbd74f6bfc213f5d6aeca1d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://82941da48f3c3321475b9ddd229efd3bebf7cef132849ad2836a152f00373f0e\",\"dweb:/ipfs/QmQmQtKAEv2ujsq5VDLFHmDbxKFP1N9nLGtfgaFWx1eCeH\"]}},\"version\":1}"},"hashes":{}}}