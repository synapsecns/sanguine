{"solidity/PingPongClient.sol:IMessageRecipient":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"origin","type":"uint32"},{"internalType":"uint32","name":"nonce","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"proofMaturity","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"receiveBaseMessage","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"notice":"Message recipient needs to implement this function in order to receive cross-chain messages."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"details":"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \"message optimistic period\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.","params":{"content":"Raw bytes content of message","nonce":"Message nonce on the origin domain","origin":"Domain where message originated","proofMaturity":"Message's merkle proof age in seconds","sender":"Sender address on origin chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"proofMaturity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"receiveBaseMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"details\":\"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \\\"message optimistic period\\\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.\",\"params\":{\"content\":\"Raw bytes content of message\",\"nonce\":\"Message nonce on the origin domain\",\"origin\":\"Domain where message originated\",\"proofMaturity\":\"Message's merkle proof age in seconds\",\"sender\":\"Sender address on origin chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"notice\":\"Message recipient needs to implement this function in order to receive cross-chain messages.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"IMessageRecipient\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0xab0f39f75b00c546b91651fc97b6527d861135ed1d9412c8f9b9635d92486f8f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eefd7f14222df92c239db30958782b81284d5079708925b646818d9c4ee697c8\",\"dweb:/ipfs/QmSjWAUv4gJVZSvrd1omgLnngos1iTwL6FGQgbVhLjnG7A\"]}},\"version\":1}"},"hashes":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":"8d3ea9e7"}},"solidity/PingPongClient.sol:InterfaceOrigin":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"uint256","name":"paddedRequest","type":"uint256"},{"internalType":"uint256","name":"contentLength","type":"uint256"}],"name":"getMinimumTipsValue","outputs":[{"internalType":"uint256","name":"tipsValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"uint32","name":"optimisticPeriod","type":"uint32"},{"internalType":"uint256","name":"paddedRequest","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"sendBaseMessage","outputs":[{"internalType":"uint32","name":"messageNonce","type":"uint32"},{"internalType":"bytes32","name":"messageHash","type":"bytes32"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"uint32","name":"optimisticPeriod","type":"uint32"},{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"sendManagerMessage","outputs":[{"internalType":"uint32","name":"messageNonce","type":"uint32"},{"internalType":"bytes32","name":"messageHash","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawTips","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getMinimumTipsValue(uint32,uint256,uint256)":{"notice":"Returns the minimum tips value for sending a message to a given destination."},"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)":{"notice":"Send a message to the recipient located on destination domain."},"sendManagerMessage(uint32,uint32,bytes)":{"notice":"Send a manager message to the destination domain."},"withdrawTips(address,uint256)":{"notice":"Withdraws locked base message tips to the recipient."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getMinimumTipsValue(uint32,uint256,uint256)":{"details":"Using at least `tipsValue` as `msg.value` for `sendBaseMessage()` will guarantee that the message will be accepted.","params":{"contentLength":"The length of the message content","destination":"Domain of destination chain","paddedRequest":"Padded encoded message execution request on destination chain"},"returns":{"tipsValue":"       Minimum tips value for a message to be accepted"}},"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)":{"details":"Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.","params":{"content":"Raw bytes content of message","destination":"Domain of destination chain","optimisticPeriod":"Optimistic period for message execution on destination chain","paddedRequest":"Padded encoded message execution request on destination chain","recipient":"Address of recipient on destination chain as bytes32"},"returns":{"messageHash":"         Hash of the sent message","messageNonce":"        Nonce of the sent message"}},"sendManagerMessage(uint32,uint32,bytes)":{"details":"This could only be called by AgentManager, which takes care of encoding the calldata payload. Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain so that the AgentManager could verify where the Manager Message came from and how mature is the proof. Note: function is not payable, as no tips are required for sending a manager message.","params":{"destination":"Domain of destination chain","optimisticPeriod":"Optimistic period for message execution on destination chain","payload":"Payload for calling AgentManager on destination chain (with extra security args)"}},"withdrawTips(address,uint256)":{"details":"Could only be called by a local AgentManager.","params":{"amount":"Tips value to withdraw","recipient":"Address to withdraw tips to"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"paddedRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contentLength\",\"type\":\"uint256\"}],\"name\":\"getMinimumTipsValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tipsValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"paddedRequest\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"sendBaseMessage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"messageNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sendManagerMessage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"messageNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getMinimumTipsValue(uint32,uint256,uint256)\":{\"details\":\"Using at least `tipsValue` as `msg.value` for `sendBaseMessage()` will guarantee that the message will be accepted.\",\"params\":{\"contentLength\":\"The length of the message content\",\"destination\":\"Domain of destination chain\",\"paddedRequest\":\"Padded encoded message execution request on destination chain\"},\"returns\":{\"tipsValue\":\"       Minimum tips value for a message to be accepted\"}},\"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)\":{\"details\":\"Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\",\"params\":{\"content\":\"Raw bytes content of message\",\"destination\":\"Domain of destination chain\",\"optimisticPeriod\":\"Optimistic period for message execution on destination chain\",\"paddedRequest\":\"Padded encoded message execution request on destination chain\",\"recipient\":\"Address of recipient on destination chain as bytes32\"},\"returns\":{\"messageHash\":\"         Hash of the sent message\",\"messageNonce\":\"        Nonce of the sent message\"}},\"sendManagerMessage(uint32,uint32,bytes)\":{\"details\":\"This could only be called by AgentManager, which takes care of encoding the calldata payload. Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain so that the AgentManager could verify where the Manager Message came from and how mature is the proof. Note: function is not payable, as no tips are required for sending a manager message.\",\"params\":{\"destination\":\"Domain of destination chain\",\"optimisticPeriod\":\"Optimistic period for message execution on destination chain\",\"payload\":\"Payload for calling AgentManager on destination chain (with extra security args)\"}},\"withdrawTips(address,uint256)\":{\"details\":\"Could only be called by a local AgentManager.\",\"params\":{\"amount\":\"Tips value to withdraw\",\"recipient\":\"Address to withdraw tips to\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getMinimumTipsValue(uint32,uint256,uint256)\":{\"notice\":\"Returns the minimum tips value for sending a message to a given destination.\"},\"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)\":{\"notice\":\"Send a message to the recipient located on destination domain.\"},\"sendManagerMessage(uint32,uint32,bytes)\":{\"notice\":\"Send a manager message to the destination domain.\"},\"withdrawTips(address,uint256)\":{\"notice\":\"Withdraws locked base message tips to the recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"InterfaceOrigin\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0xab0f39f75b00c546b91651fc97b6527d861135ed1d9412c8f9b9635d92486f8f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eefd7f14222df92c239db30958782b81284d5079708925b646818d9c4ee697c8\",\"dweb:/ipfs/QmSjWAUv4gJVZSvrd1omgLnngos1iTwL6FGQgbVhLjnG7A\"]}},\"version\":1}"},"hashes":{"getMinimumTipsValue(uint32,uint256,uint256)":"4fc6ad85","sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)":"873661bd","sendManagerMessage(uint32,uint32,bytes)":"a1c702a7","withdrawTips(address,uint256)":"4e04e7a7"}},"solidity/PingPongClient.sol:PingPongClient":{"code":"0x60c060405234801561001057600080fd5b50604051610c0a380380610c0a83398101604081905261002f91610087565b6001600160a01b039182166080521660a052604080514360208083019190915282518083038201815291830190925280519101206000556100ba565b80516001600160a01b038116811461008257600080fd5b919050565b6000806040838503121561009a57600080fd5b6100a38361006b565b91506100b16020840161006b565b90509250929050565b60805160a051610b1d6100ed600039600081816101df015261028101526000818161016601526105740152610b1d6000f3fe6080604052600436106100b15760003560e01c8063938b5f3211610069578063b269681d1161004e578063b269681d146101cd578063b475cba314610201578063e3ac3ca01461021757600080fd5b8063938b5f3214610154578063aa402039146101ad57600080fd5b806345a8b8ed1161009a57806345a8b8ed146101075780635ec01e4d1461012b5780638d3ea9e71461014157600080fd5b806308fe5e4e146100b65780632bd56025146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d13660046106d0565b61022d565b005b3480156100e457600080fd5b506100ed610253565b60405163ffffffff90911681526020015b60405180910390f35b34801561011357600080fd5b5061011d60035481565b6040519081526020016100fe565b34801561013757600080fd5b5061011d60005481565b6100d661014f366004610797565b610269565b34801561016057600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100fe565b3480156101b957600080fd5b506100d66101c8366004610883565b6103ff565b3480156101d957600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b34801561020d57600080fd5b5061011d60015481565b34801561022357600080fd5b5061011d60025481565b61024e8373ffffffffffffffffffffffffffffffffffffffff841683610446565b505050565b6000603c60005461026491906108dd565b905090565b3373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461030c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f50696e67506f6e67436c69656e743a202164657374696e6174696f6e00000000604482015260640160405180910390fd5b6000818060200190518101906103229190610918565b90508060200151156103865760026000815461033d906109b5565b9091555080516040519081527f51c4f05cea43f3d4604f77fd5a656743088090aa726deb5e3a9f670d8da75d659060200160405180910390a16103818685836104c2565b6103f7565b600360008154610395906109b5565b9091555080516040519081527f08d46b5262cb13a84b9421fef5cfd01017e1cb48c879e3fc89acaadf34f2106e9060200160405180910390a1604081015161ffff16156103f7576103f78685600184604001516103f291906109ed565b610446565b505050505050565b60005b8461ffff1681101561043f5761042f8473ffffffffffffffffffffffffffffffffffffffff851684610446565b610438816109b5565b9050610402565b5050505050565b6001805460009182610457836109b5565b919050559050610489848460405180606001604052808581526020016001151581526020018661ffff16815250610530565b6040518181527f14089a5f67ef0667796ead5223612a15d24422be4bdaa19abc32fb26d4c8b3db9060200160405180910390a150505050565b6104f68383604051806060016040528085600001518152602001600015158152602001856040015161ffff16815250610530565b80516040519081527f0a72872b9cfe43d6c13b13553f28d4879e427f3b456545649fd0761fdcbe03119060200160405180910390a1505050565b6000806040805184516020808301919091528501511515818301529084015161ffff16606082015290915060009060800160405160208183030381529060405290507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663873661bd86866105b8610625565b86866040518663ffffffff1660e01b81526004016105da959493929190610a0f565b60408051808303816000875af11580156105f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061c9190610ab9565b50505050505050565b600061062f610253565b905060005460405160200161064691815260200190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012060005590565b63ffffffff8116811461069457600080fd5b50565b803573ffffffffffffffffffffffffffffffffffffffff811681146106bb57600080fd5b919050565b61ffff8116811461069457600080fd5b6000806000606084860312156106e557600080fd5b83356106f081610682565b92506106fe60208501610697565b9150604084013561070e816106c0565b809150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561078f5761078f610719565b604052919050565b600080600080600060a086880312156107af57600080fd5b85356107ba81610682565b94506020868101356107cb81610682565b94506040870135935060608701359250608087013567ffffffffffffffff808211156107f657600080fd5b818901915089601f83011261080a57600080fd5b81358181111561081c5761081c610719565b61084c847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610748565b91508082528a8482850101111561086257600080fd5b80848401858401376000848284010152508093505050509295509295909350565b6000806000806080858703121561089957600080fd5b84356108a4816106c0565b935060208501356108b481610682565b92506108c260408601610697565b915060608501356108d2816106c0565b939692955090935050565b600082610913577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b60006060828403121561092a57600080fd5b6040516060810181811067ffffffffffffffff8211171561094d5761094d610719565b604052825181526020830151801515811461096757600080fd5b6020820152604083015161097a816106c0565b60408201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036109e6576109e6610986565b5060010190565b61ffff828116828216039080821115610a0857610a08610986565b5092915050565b600063ffffffff808816835260208781850152818716604085015273ffffffffffffffffffffffffffffffffffffffff8616606085015260a06080850152845191508160a085015260005b82811015610a765785810182015185820160c001528101610a5a565b5050600060c0828501015260c07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509695505050505050565b60008060408385031215610acc57600080fd5b8251610ad781610682565b602093909301519294929350505056fea2646970667358221220629d423ed60650c31bbd897d4a311158aa3135784adc75eaff66a7625b9fd14a64736f6c63430008110033","runtime-code":"0x6080604052600436106100b15760003560e01c8063938b5f3211610069578063b269681d1161004e578063b269681d146101cd578063b475cba314610201578063e3ac3ca01461021757600080fd5b8063938b5f3214610154578063aa402039146101ad57600080fd5b806345a8b8ed1161009a57806345a8b8ed146101075780635ec01e4d1461012b5780638d3ea9e71461014157600080fd5b806308fe5e4e146100b65780632bd56025146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d13660046106d0565b61022d565b005b3480156100e457600080fd5b506100ed610253565b60405163ffffffff90911681526020015b60405180910390f35b34801561011357600080fd5b5061011d60035481565b6040519081526020016100fe565b34801561013757600080fd5b5061011d60005481565b6100d661014f366004610797565b610269565b34801561016057600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100fe565b3480156101b957600080fd5b506100d66101c8366004610883565b6103ff565b3480156101d957600080fd5b506101887f000000000000000000000000000000000000000000000000000000000000000081565b34801561020d57600080fd5b5061011d60015481565b34801561022357600080fd5b5061011d60025481565b61024e8373ffffffffffffffffffffffffffffffffffffffff841683610446565b505050565b6000603c60005461026491906108dd565b905090565b3373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461030c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f50696e67506f6e67436c69656e743a202164657374696e6174696f6e00000000604482015260640160405180910390fd5b6000818060200190518101906103229190610918565b90508060200151156103865760026000815461033d906109b5565b9091555080516040519081527f51c4f05cea43f3d4604f77fd5a656743088090aa726deb5e3a9f670d8da75d659060200160405180910390a16103818685836104c2565b6103f7565b600360008154610395906109b5565b9091555080516040519081527f08d46b5262cb13a84b9421fef5cfd01017e1cb48c879e3fc89acaadf34f2106e9060200160405180910390a1604081015161ffff16156103f7576103f78685600184604001516103f291906109ed565b610446565b505050505050565b60005b8461ffff1681101561043f5761042f8473ffffffffffffffffffffffffffffffffffffffff851684610446565b610438816109b5565b9050610402565b5050505050565b6001805460009182610457836109b5565b919050559050610489848460405180606001604052808581526020016001151581526020018661ffff16815250610530565b6040518181527f14089a5f67ef0667796ead5223612a15d24422be4bdaa19abc32fb26d4c8b3db9060200160405180910390a150505050565b6104f68383604051806060016040528085600001518152602001600015158152602001856040015161ffff16815250610530565b80516040519081527f0a72872b9cfe43d6c13b13553f28d4879e427f3b456545649fd0761fdcbe03119060200160405180910390a1505050565b6000806040805184516020808301919091528501511515818301529084015161ffff16606082015290915060009060800160405160208183030381529060405290507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663873661bd86866105b8610625565b86866040518663ffffffff1660e01b81526004016105da959493929190610a0f565b60408051808303816000875af11580156105f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061c9190610ab9565b50505050505050565b600061062f610253565b905060005460405160200161064691815260200190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012060005590565b63ffffffff8116811461069457600080fd5b50565b803573ffffffffffffffffffffffffffffffffffffffff811681146106bb57600080fd5b919050565b61ffff8116811461069457600080fd5b6000806000606084860312156106e557600080fd5b83356106f081610682565b92506106fe60208501610697565b9150604084013561070e816106c0565b809150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561078f5761078f610719565b604052919050565b600080600080600060a086880312156107af57600080fd5b85356107ba81610682565b94506020868101356107cb81610682565b94506040870135935060608701359250608087013567ffffffffffffffff808211156107f657600080fd5b818901915089601f83011261080a57600080fd5b81358181111561081c5761081c610719565b61084c847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610748565b91508082528a8482850101111561086257600080fd5b80848401858401376000848284010152508093505050509295509295909350565b6000806000806080858703121561089957600080fd5b84356108a4816106c0565b935060208501356108b481610682565b92506108c260408601610697565b915060608501356108d2816106c0565b939692955090935050565b600082610913577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b60006060828403121561092a57600080fd5b6040516060810181811067ffffffffffffffff8211171561094d5761094d610719565b604052825181526020830151801515811461096757600080fd5b6020820152604083015161097a816106c0565b60408201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036109e6576109e6610986565b5060010190565b61ffff828116828216039080821115610a0857610a08610986565b5092915050565b600063ffffffff808816835260208781850152818716604085015273ffffffffffffffffffffffffffffffffffffffff8616606085015260a06080850152845191508160a085015260005b82811015610a765785810182015185820160c001528101610a5a565b5050600060c0828501015260c07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509695505050505050565b60008060408385031215610acc57600080fd5b8251610ad781610682565b602093909301519294929350505056fea2646970667358221220629d423ed60650c31bbd897d4a311158aa3135784adc75eaff66a7625b9fd14a64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"8602:7508:0:-:0;;;11408:218;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;11469:16:0;;;;;11495:26;;;11593:24;;;11604:12;11593:24;;;;640:25:1;;;;11593:24:0;;;;;;;;;613:18:1;;;11593:24:0;;;11583:35;;;;;11575:44;11566:53;8602:7508;;14:177:1;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;494:177::-;8602:7508:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"8602:7508:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13461:156;;;;;;;;;;-1:-1:-1;13461:156:0;;;;;:::i;:::-;;:::i;:::-;;13957:175;;;;;;;;;;;;;:::i;:::-;;;1100:10:1;1088:23;;;1070:42;;1058:2;1043:18;13957:175:0;;;;;;;;10068:28;;;;;;;;;;;;;;;;;;;1269:25:1;;;1257:2;1242:18;10068:28:0;1123:177:1;9658:21:0;;;;;;;;;;;;;;;;11988:818;;;;;;:::i;:::-;;:::i;9178:31::-;;;;;;;;;;;;;;;;;;3246:42:1;3234:55;;;3216:74;;3204:2;3189:18;9178:31:0;3070:226:1;12812:239:0;;;;;;;;;;-1:-1:-1;12812:239:0;;;;;:::i;:::-;;:::i;9285:36::-;;;;;;;;;;;;;;;9734:24;;;;;;;;;;;;;;;;9909:28;;;;;;;;;;;;;;;;13461:156;13552:58;13558:12;13572:26;;;13602:7;13552:5;:58::i;:::-;13461:156;;;:::o;13957:175::-;14010:13;14115:9;14106:6;;:18;;;;:::i;:::-;14092:33;;13957:175;:::o;11988:818::-;12142:10;:25;12156:11;12142:25;;12134:66;;;;;;;4377:2:1;12134:66:0;;;4359:21:1;4416:2;4396:18;;;4389:30;4455;4435:18;;;4428:58;4503:18;;12134:66:0;;;;;;;;12210:30;12254:7;12243:38;;;;;;;;;;;;:::i;:::-;12210:71;;12295:7;:14;;;12291:509;;;12359:13;;12357:15;;;;;:::i;:::-;;;;-1:-1:-1;12404:14:0;;12391:28;;1269:25:1;;;12391:28:0;;1257:2:1;1242:18;12391:28:0;;;;;;;12463:31;12469:7;12478:6;12486:7;12463:5;:31::i;:::-;12291:509;;;12559:13;;12557:15;;;;;:::i;:::-;;;;-1:-1:-1;12604:14:0;;12591:28;;1269:25:1;;;12591:28:0;;1257:2:1;1242:18;12591:28:0;;;;;;;12692:15;;;;:20;;;12688:102;;12732:43;12738:7;12747:6;12773:1;12755:7;:15;;;:19;;;;:::i;:::-;12732:5;:43::i;:::-;12124:682;11988:818;;;;;:::o;12812:239::-;12927:9;12922:123;12946:9;12942:13;;:1;:13;12922:123;;;12976:58;12982:12;12996:26;;;13026:7;12976:5;:58::i;:::-;12957:3;;;:::i;:::-;;;12922:123;;;;12812:239;;;;:::o;15498:270::-;15605:9;:11;;15588:14;;;15605:11;;;:::i;:::-;;;;;15588:28;;15626:104;15639:12;15653:9;15664:65;;;;;;;;15689:6;15664:65;;;;15705:4;15664:65;;;;;;15720:7;15664:65;;;;;15626:12;:104::i;:::-;15745:16;;1269:25:1;;;15745:16:0;;1257:2:1;1242:18;15745:16:0;;;;;;;15578:190;15498:270;;;:::o;15813:295::-;15919:143;15945:12;15959:9;15970:82;;;;;;;;15995:7;:14;;;15970:82;;;;16019:5;15970:82;;;;;;16035:7;:15;;;15970:82;;;;;15919:12;:143::i;:::-;16086:14;;16077:24;;1269:25:1;;;16077:24:0;;1257:2:1;1242:18;16077:24:0;;;;;;;15813:295;;;:::o;15018:429::-;15190:15;;15271:19;;;6065:13:1;;15271:19:0;;;;6047:32:1;;;;6137:17;;6131:24;6124:32;6117:40;6095:20;;;6088:70;6206:17;;;6200:24;6226:6;6196:37;6174:20;;;6167:67;15190:48:0;;-1:-1:-1;15248:20:0;;6020:18:1;;15271:19:0;;;;;;;;;;;;15248:42;;15316:6;15300:39;;;15353:12;15367:9;15378:18;:16;:18::i;:::-;15413:7;15423;15300:140;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;15121:326;;15018:429;;;:::o;14530:256::-;14576:13;14667:22;:20;:22::i;:::-;14658:31;;14770:6;;14759:18;;;;;;1269:25:1;;1257:2;1242:18;;1123:177;14759:18:0;;;;;;;;;;;;;;14749:29;;14759:18;14749:29;;;;14741:38;14732:47;14530:256;:::o;14:121:1:-;99:10;92:5;88:22;81:5;78:33;68:61;;125:1;122;115:12;68:61;14:121;:::o;140:196::-;208:20;;268:42;257:54;;247:65;;237:93;;326:1;323;316:12;237:93;140:196;;;:::o;341:117::-;426:6;419:5;415:18;408:5;405:29;395:57;;448:1;445;438:12;463:458;538:6;546;554;607:2;595:9;586:7;582:23;578:32;575:52;;;623:1;620;613:12;575:52;662:9;649:23;681:30;705:5;681:30;:::i;:::-;730:5;-1:-1:-1;754:38:1;788:2;773:18;;754:38;:::i;:::-;744:48;;844:2;833:9;829:18;816:32;857;881:7;857:32;:::i;:::-;908:7;898:17;;;463:458;;;;;:::o;1305:184::-;1357:77;1354:1;1347:88;1454:4;1451:1;1444:15;1478:4;1475:1;1468:15;1494:334;1565:2;1559:9;1621:2;1611:13;;1626:66;1607:86;1595:99;;1724:18;1709:34;;1745:22;;;1706:62;1703:88;;;1771:18;;:::i;:::-;1807:2;1800:22;1494:334;;-1:-1:-1;1494:334:1:o;1833:1232::-;1935:6;1943;1951;1959;1967;2020:3;2008:9;1999:7;1995:23;1991:33;1988:53;;;2037:1;2034;2027:12;1988:53;2076:9;2063:23;2095:30;2119:5;2095:30;:::i;:::-;2144:5;-1:-1:-1;2168:2:1;2207:18;;;2194:32;2235;2194;2235;:::i;:::-;2286:7;-1:-1:-1;2340:2:1;2325:18;;2312:32;;-1:-1:-1;2391:2:1;2376:18;;2363:32;;-1:-1:-1;2446:3:1;2431:19;;2418:33;2470:18;2500:14;;;2497:34;;;2527:1;2524;2517:12;2497:34;2565:6;2554:9;2550:22;2540:32;;2610:7;2603:4;2599:2;2595:13;2591:27;2581:55;;2632:1;2629;2622:12;2581:55;2668:2;2655:16;2690:2;2686;2683:10;2680:36;;;2696:18;;:::i;:::-;2738:112;2846:2;2777:66;2770:4;2766:2;2762:13;2758:86;2754:95;2738:112;:::i;:::-;2725:125;;2873:2;2866:5;2859:17;2913:7;2908:2;2903;2899;2895:11;2891:20;2888:33;2885:53;;;2934:1;2931;2924:12;2885:53;2989:2;2984;2980;2976:11;2971:2;2964:5;2960:14;2947:45;3033:1;3028:2;3023;3016:5;3012:14;3008:23;3001:34;;3054:5;3044:15;;;;;1833:1232;;;;;;;;:::o;3301:598::-;3384:6;3392;3400;3408;3461:3;3449:9;3440:7;3436:23;3432:33;3429:53;;;3478:1;3475;3468:12;3429:53;3517:9;3504:23;3536:30;3560:5;3536:30;:::i;:::-;3585:5;-1:-1:-1;3642:2:1;3627:18;;3614:32;3655;3614;3655;:::i;:::-;3706:7;-1:-1:-1;3732:38:1;3766:2;3751:18;;3732:38;:::i;:::-;3722:48;;3822:2;3811:9;3807:18;3794:32;3835;3859:7;3835:32;:::i;:::-;3301:598;;;;-1:-1:-1;3301:598:1;;-1:-1:-1;;3301:598:1:o;3904:266::-;3936:1;3962;3952:189;;3997:77;3994:1;3987:88;4098:4;4095:1;4088:15;4126:4;4123:1;4116:15;3952:189;-1:-1:-1;4155:9:1;;3904:266::o;4532:735::-;4634:6;4687:2;4675:9;4666:7;4662:23;4658:32;4655:52;;;4703:1;4700;4693:12;4655:52;4736:2;4730:9;4778:2;4770:6;4766:15;4847:6;4835:10;4832:22;4811:18;4799:10;4796:34;4793:62;4790:88;;;4858:18;;:::i;:::-;4894:2;4887:22;4933:16;;4918:32;;4993:2;4978:18;;4972:25;5033:13;;5026:21;5016:32;;5006:60;;5062:1;5059;5052:12;5006:60;5094:2;5082:15;;5075:30;5150:2;5135:18;;5129:25;5163:32;5129:25;5163:32;:::i;:::-;5223:2;5211:15;;5204:32;5215:6;4532:735;-1:-1:-1;;;4532:735:1:o;5272:184::-;5324:77;5321:1;5314:88;5421:4;5418:1;5411:15;5445:4;5442:1;5435:15;5461:195;5500:3;5531:66;5524:5;5521:77;5518:103;;5601:18;;:::i;:::-;-1:-1:-1;5648:1:1;5637:13;;5461:195::o;5661:171::-;5729:6;5768:10;;;5756;;;5752:27;;5791:12;;;5788:38;;;5806:18;;:::i;:::-;5788:38;5661:171;;;;:::o;6245:987::-;6463:4;6492:10;6541:2;6533:6;6529:15;6518:9;6511:34;6564:2;6602:6;6597:2;6586:9;6582:18;6575:34;6657:2;6649:6;6645:15;6640:2;6629:9;6625:18;6618:43;6709:42;6701:6;6697:55;6692:2;6681:9;6677:18;6670:83;6790:3;6784;6773:9;6769:19;6762:32;6823:6;6817:13;6803:27;;6867:6;6861:3;6850:9;6846:19;6839:35;6892:1;6902:141;6916:6;6913:1;6910:13;6902:141;;;7012:14;;;7008:23;;7002:30;6977:17;;;6996:3;6973:27;6966:67;6931:10;;6902:141;;;6906:3;;7093:1;7087:3;7078:6;7067:9;7063:22;7059:32;7052:43;7222:3;7152:66;7147:2;7139:6;7135:15;7131:88;7120:9;7116:104;7112:114;7104:122;;;6245:987;;;;;;;;:::o;7237:310::-;7315:6;7323;7376:2;7364:9;7355:7;7351:23;7347:32;7344:52;;;7392:1;7389;7382:12;7344:52;7424:9;7418:16;7443:30;7467:5;7443:30;:::i;:::-;7537:2;7522:18;;;;7516:25;7492:5;;7516:25;;-1:-1:-1;;;7237:310:1:o","abiDefinition":[{"inputs":[{"internalType":"address","name":"origin_","type":"address"},{"internalType":"address","name":"destination_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PingReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PingSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PongReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"pingId","type":"uint256"}],"name":"PongSent","type":"event"},{"inputs":[],"name":"destination","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint16","name":"counter","type":"uint16"}],"name":"doPing","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"pingCount","type":"uint16"},{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint16","name":"counter","type":"uint16"}],"name":"doPings","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"nextOptimisticPeriod","outputs":[{"internalType":"uint32","name":"period","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"origin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pingsReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pingsSent","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pongsReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"random","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"origin_","type":"uint32"},{"internalType":"uint32","name":"","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"receiveBaseMessage","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"events":{"PingReceived(uint256)":{"notice":"Emitted when a Ping message is received. Will always send a Pong message back."},"PingSent(uint256)":{"notice":"Emitted when a Ping message is sent. Triggered externally, or by receveing a Pong message with instructions to do more pings."},"PongReceived(uint256)":{"notice":"Emitted when a Pong message is received. Will initiate a new Ping, if the counter in the message is non-zero."},"PongSent(uint256)":{"notice":"Emitted when a Pong message is sent. Triggered whenever a Ping message is received."}},"kind":"user","methods":{"destination()":{"notice":"Local chain Destination: used for receiving messages"},"doPing(uint32,address,uint16)":{"notice":"Send a Ping message to destination chain. Upon receiving a Ping, a Pong message will be sent back. If `counter \u003e 0`, this process will be repeated when the Pong message is received."},"origin()":{"notice":"Local chain Origin: used for sending messages"},"pingsReceived()":{"notice":"Amount of \"Ping\" messages received. Every received Ping message leads to sending a Pong message back to initial sender."},"pingsSent()":{"notice":"Amount of \"Ping\" messages sent."},"pongsReceived()":{"notice":"Amount of \"Pong\" messages received. When all messages are delivered, should be equal to `pingsSent`"},"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"notice":"Message recipient needs to implement this function in order to receive cross-chain messages."}},"version":1},"developerDoc":{"kind":"dev","methods":{"doPing(uint32,address,uint16)":{"params":{"counter":"Additional amount of Ping-Pong rounds to conclude","destination_":"Chain to send Ping message to","recipient":"Recipient of Ping message"}},"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"details":"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \"message optimistic period\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.","params":{"content":"Raw bytes content of message","nonce":"Message nonce on the origin domain","origin":"Domain where message originated","proofMaturity":"Message's merkle proof age in seconds","sender":"Sender address on origin chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PingReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PingSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PongReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pingId\",\"type\":\"uint256\"}],\"name\":\"PongSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"counter\",\"type\":\"uint16\"}],\"name\":\"doPing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"pingCount\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"counter\",\"type\":\"uint16\"}],\"name\":\"doPings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOptimisticPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pingsReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pingsSent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pongsReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"receiveBaseMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"doPing(uint32,address,uint16)\":{\"params\":{\"counter\":\"Additional amount of Ping-Pong rounds to conclude\",\"destination_\":\"Chain to send Ping message to\",\"recipient\":\"Recipient of Ping message\"}},\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"details\":\"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \\\"message optimistic period\\\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.\",\"params\":{\"content\":\"Raw bytes content of message\",\"nonce\":\"Message nonce on the origin domain\",\"origin\":\"Domain where message originated\",\"proofMaturity\":\"Message's merkle proof age in seconds\",\"sender\":\"Sender address on origin chain\"}}},\"version\":1},\"userdoc\":{\"events\":{\"PingReceived(uint256)\":{\"notice\":\"Emitted when a Ping message is received. Will always send a Pong message back.\"},\"PingSent(uint256)\":{\"notice\":\"Emitted when a Ping message is sent. Triggered externally, or by receveing a Pong message with instructions to do more pings.\"},\"PongReceived(uint256)\":{\"notice\":\"Emitted when a Pong message is received. Will initiate a new Ping, if the counter in the message is non-zero.\"},\"PongSent(uint256)\":{\"notice\":\"Emitted when a Pong message is sent. Triggered whenever a Ping message is received.\"}},\"kind\":\"user\",\"methods\":{\"destination()\":{\"notice\":\"Local chain Destination: used for receiving messages\"},\"doPing(uint32,address,uint16)\":{\"notice\":\"Send a Ping message to destination chain. Upon receiving a Ping, a Pong message will be sent back. If `counter \u003e 0`, this process will be repeated when the Pong message is received.\"},\"origin()\":{\"notice\":\"Local chain Origin: used for sending messages\"},\"pingsReceived()\":{\"notice\":\"Amount of \\\"Ping\\\" messages received. Every received Ping message leads to sending a Pong message back to initial sender.\"},\"pingsSent()\":{\"notice\":\"Amount of \\\"Ping\\\" messages sent.\"},\"pongsReceived()\":{\"notice\":\"Amount of \\\"Pong\\\" messages received. When all messages are delivered, should be equal to `pingsSent`\"},\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"notice\":\"Message recipient needs to implement this function in order to receive cross-chain messages.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"PingPongClient\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0xab0f39f75b00c546b91651fc97b6527d861135ed1d9412c8f9b9635d92486f8f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eefd7f14222df92c239db30958782b81284d5079708925b646818d9c4ee697c8\",\"dweb:/ipfs/QmSjWAUv4gJVZSvrd1omgLnngos1iTwL6FGQgbVhLjnG7A\"]}},\"version\":1}"},"hashes":{"destination()":"b269681d","doPing(uint32,address,uint16)":"08fe5e4e","doPings(uint16,uint32,address,uint16)":"aa402039","nextOptimisticPeriod()":"2bd56025","origin()":"938b5f32","pingsReceived()":"e3ac3ca0","pingsSent()":"b475cba3","pongsReceived()":"45a8b8ed","random()":"5ec01e4d","receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":"8d3ea9e7"}},"solidity/PingPongClient.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220513910bfa8e4733d0643508015f3c3a63709737ac4f2b641ac0000ec20ea614d64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220513910bfa8e4733d0643508015f3c3a63709737ac4f2b641ac0000ec20ea614d64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"1232:1772:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1232:1772:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1232:1772:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_GAS_DROP":{"details":"Amount of bits to shift to gasDrop field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_GAS_DROP\":{\"details\":\"Amount of bits to shift to gasDrop field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0xab0f39f75b00c546b91651fc97b6527d861135ed1d9412c8f9b9635d92486f8f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eefd7f14222df92c239db30958782b81284d5079708925b646818d9c4ee697c8\",\"dweb:/ipfs/QmSjWAUv4gJVZSvrd1omgLnngos1iTwL6FGQgbVhLjnG7A\"]}},\"version\":1}"},"hashes":{}},"solidity/PingPongClient.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220734d8dc5cfddbe3c1ec50734457d38640b3b4274227e3d861a9fb3d7219d39b064736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220734d8dc5cfddbe3c1ec50734457d38640b3b4274227e3d861a9fb3d7219d39b064736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract PingPongClient is IMessageRecipient {\n    using TypeCasts for address;\n\n    struct PingPongMessage {\n        uint256 pingId;\n        bool isPing;\n        uint16 counter;\n    }\n\n    // ════════════════════════════════════════════════ IMMUTABLES ═════════════════════════════════════════════════════\n\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    uint256 public random;\n\n    /// @notice Amount of \"Ping\" messages sent.\n    uint256 public pingsSent;\n\n    /// @notice Amount of \"Ping\" messages received.\n    /// Every received Ping message leads to sending a Pong message back to initial sender.\n    uint256 public pingsReceived;\n\n    /// @notice Amount of \"Pong\" messages received.\n    /// When all messages are delivered, should be equal to `pingsSent`\n    uint256 public pongsReceived;\n\n    // ══════════════════════════════════════════════════ EVENTS ═══════════════════════════════════════════════════════\n\n    /// @notice Emitted when a Ping message is sent.\n    /// Triggered externally, or by receveing a Pong message with instructions to do more pings.\n    event PingSent(uint256 pingId);\n\n    /// @notice Emitted when a Ping message is received.\n    /// Will always send a Pong message back.\n    event PingReceived(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is sent.\n    /// Triggered whenever a Ping message is received.\n    event PongSent(uint256 pingId);\n\n    /// @notice Emitted when a Pong message is received.\n    /// Will initiate a new Ping, if the counter in the message is non-zero.\n    event PongReceived(uint256 pingId);\n\n    // ════════════════════════════════════════════════ CONSTRUCTOR ════════════════════════════════════════════════════\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n        // Initiate \"random\" value\n        random = uint256(keccak256(abi.encode(block.number)));\n    }\n\n    // ═══════════════════════════════════════════════ MESSAGE LOGIC ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(uint32 origin_, uint32, bytes32 sender, uint256, bytes memory content)\n        external\n        payable\n    {\n        require(msg.sender == destination, \"PingPongClient: !destination\");\n        PingPongMessage memory message = abi.decode(content, (PingPongMessage));\n        if (message.isPing) {\n            // Ping is received\n            ++pingsReceived;\n            emit PingReceived(message.pingId);\n            // Send Pong back\n            _pong(origin_, sender, message);\n        } else {\n            // Pong is received\n            ++pongsReceived;\n            emit PongReceived(message.pingId);\n            // Send extra ping, if initially requested\n            if (message.counter != 0) {\n                _ping(origin_, sender, message.counter - 1);\n            }\n        }\n    }\n\n    function doPings(uint16 pingCount, uint32 destination_, address recipient, uint16 counter) external {\n        for (uint256 i = 0; i \u003c pingCount; ++i) {\n            _ping(destination_, recipient.addressToBytes32(), counter);\n        }\n    }\n\n    /// @notice Send a Ping message to destination chain.\n    /// Upon receiving a Ping, a Pong message will be sent back.\n    /// If `counter \u003e 0`, this process will be repeated when the Pong message is received.\n    /// @param destination_ Chain to send Ping message to\n    /// @param recipient    Recipient of Ping message\n    /// @param counter      Additional amount of Ping-Pong rounds to conclude\n    function doPing(uint32 destination_, address recipient, uint16 counter) external {\n        _ping(destination_, recipient.addressToBytes32(), counter);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function nextOptimisticPeriod() public view returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        return uint32(random % 1 minutes);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Returns a random optimistic period value from 0 to 59 seconds.\n    function optimisticPeriod() internal returns (uint32 period) {\n        // Use random optimistic period up to one minute\n        period = nextOptimisticPeriod();\n        // Adjust \"random\" value\n        random = uint256(keccak256(abi.encode(random)));\n    }\n\n    /**\n     * @dev Send a \"Ping\" or \"Pong\" message.\n     * @param destination_  Domain of destination chain\n     * @param recipient     Message recipient on destination chain\n     * @param message   Ping-pong message\n     */\n    function _sendMessage(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        // TODO: figure out the logic for a ping-pong test\n        Request request = RequestLib.encodeRequest(0, 0);\n        bytes memory content = abi.encode(message);\n        InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticPeriod(), Request.unwrap(request), content\n        );\n    }\n\n    /// @dev Initiate a new Ping-Pong round.\n    function _ping(uint32 destination_, bytes32 recipient, uint16 counter) internal {\n        uint256 pingId = pingsSent++;\n        _sendMessage(destination_, recipient, PingPongMessage({pingId: pingId, isPing: true, counter: counter}));\n        emit PingSent(pingId);\n    }\n\n    /// @dev Send a Pong message back.\n    function _pong(uint32 destination_, bytes32 recipient, PingPongMessage memory message) internal {\n        _sendMessage(\n            destination_, recipient, PingPongMessage({pingId: message.pingId, isPing: false, counter: message.counter})\n        );\n        emit PongSent(message.pingId);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"3006:350:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3006:350:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3006:350:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/PingPongClient.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/PingPongClient.sol\":{\"keccak256\":\"0xab0f39f75b00c546b91651fc97b6527d861135ed1d9412c8f9b9635d92486f8f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eefd7f14222df92c239db30958782b81284d5079708925b646818d9c4ee697c8\",\"dweb:/ipfs/QmSjWAUv4gJVZSvrd1omgLnngos1iTwL6FGQgbVhLjnG7A\"]}},\"version\":1}"},"hashes":{}}}