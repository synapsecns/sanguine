{"solidity/TipsHarness.t.sol:MemViewLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220aa9b15194137a3c1cad3943d97e5b241edee168e4bfe2eea03927c77be82ea4d64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220aa9b15194137a3c1cad3943d97e5b241edee168e4bfe2eea03927c77be82ea4d64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns summitTip field\n    function summitTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().summitTip();\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().attestationTip();\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().executionTip();\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().deliveryTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function value(bytes memory payload) public pure returns (uint256) {\n        return payload.castToTips().value();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"5330:19307:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5330:19307:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5330:19307:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for operations with the memory views. Forked from https://github.com/summa-tx/memview-sol with several breaking changes: - The codebase is ported to Solidity 0.8 - Custom errors are added - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types - uint256 is used as the underlying type for the \\\"memory view\\\" instead of bytes29.   It is wrapped into MemView custom type in order not to be confused with actual integers. - Therefore the \\\"type\\\" field is discarded, allowing to allocate 16 bytes for both view location and length - The documentation is expanded - Library functions unused by the rest of the codebase are removed\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"MemViewLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xb9a954f5183d641853b90b40febdb1f614e517f892acfd61892417d75c147f9c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2260865d391083ec6baa85b05a678d8b80cc14fcdf4d7133f61df9e72620bb6c\",\"dweb:/ipfs/QmY9BRLSyoxSxntDui5BAdYBmed8J7hp4rr2iXBivquuv6\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.t.sol:TipsHarness":{"code":"0x608060405234801561001057600080fd5b5061092c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c80638071531f11610076578063a94afa731161005b578063a94afa731461014a578063ec6acad6146101bf578063fb2f718c146101e057600080fd5b80638071531f14610114578063993abc411461012757600080fd5b806335d1d816146100a85780634d76edf1146100d957806350190c31146100ec578063725bd4631461010c575b600080fd5b6100bb6100b6366004610710565b6101f3565b60405167ffffffffffffffff90911681526020015b60405180910390f35b6100bb6100e7366004610710565b61020c565b6100ff6100fa366004610710565b61021f565b6040516100d091906107df565b6100ff61023e565b6100bb610122366004610710565b61027f565b61013a610135366004610710565b610292565b60405190151581526020016100d0565b6100ff610158366004610868565b604080517fffffffffffffffff00000000000000000000000000000000000000000000000060c096871b811660208084019190915295871b8116602883015293861b841660308201529190941b909116603882015282518082039092018252820190915290565b6101d26101cd366004610710565b6102b8565b6040519081526020016100d0565b6100bb6101ee366004610710565b6102cb565b6000610206610201836102de565b6102f1565b92915050565b600061020661021a836102de565b6102fd565b6060600061022c836102de565b905061023781610309565b9392505050565b606061027a6040805160006020808301829052602883018290526030830182905260388301919091528251808303909101815290820190915290565b905090565b600061020661028d836102de565b610366565b60006102066102a083610372565b6fffffffffffffffffffffffffffffffff1660201490565b60006102066102c6836102de565b61038d565b60006102066102d9836102de565b6103dc565b60006102066102ec83610372565b6103e8565b6000816102378161046e565b6000816102378161047c565b6040518061031a836020830161048a565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60008161023781610539565b8051600090602083016103858183610548565b949350505050565b60008161039981610539565b6103a2826105ab565b6103ab8361047c565b6103b48461046e565b6103be91906108bc565b6103c891906108bc565b6103d291906108bc565b60201b9392505050565b600081610237816105ab565b600060206fffffffffffffffffffffffffffffffff83161461046a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e6f7420612074697073207061796c6f61640000000000000000000000000000604482015260640160405180910390fd5b5090565b6000610206828260086105b6565b6000610206826008806105b6565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c90808510156104e4576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610527576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061020682601860086105b6565b60008061055583856108bc565b9050604051811115610565575060005b8060000361059f576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b8317610385565b600061020682601060085b6000806105c48585856105d7565b602084900360031b1c9150509392505050565b6000816000036105e957506000610237565b6020821115610624576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661064183856108bc565b1115610679576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b600061068a8660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60006020828403121561072257600080fd5b813567ffffffffffffffff8082111561073a57600080fd5b818401915084601f83011261074e57600080fd5b813581811115610760576107606106e1565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156107a6576107a66106e1565b816040528281528760208487010111156107bf57600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208083528351808285015260005b8181101561080c578581018301518582016040015282016107f0565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b803567ffffffffffffffff8116811461086357600080fd5b919050565b6000806000806080858703121561087e57600080fd5b6108878561084b565b93506108956020860161084b565b92506108a36040860161084b565b91506108b16060860161084b565b905092959194509250565b80820180821115610206577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea264697066735822122001f354c5ca0209f2d3f35196201266289b564b322384904278bbb97cdf61111664736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100a35760003560e01c80638071531f11610076578063a94afa731161005b578063a94afa731461014a578063ec6acad6146101bf578063fb2f718c146101e057600080fd5b80638071531f14610114578063993abc411461012757600080fd5b806335d1d816146100a85780634d76edf1146100d957806350190c31146100ec578063725bd4631461010c575b600080fd5b6100bb6100b6366004610710565b6101f3565b60405167ffffffffffffffff90911681526020015b60405180910390f35b6100bb6100e7366004610710565b61020c565b6100ff6100fa366004610710565b61021f565b6040516100d091906107df565b6100ff61023e565b6100bb610122366004610710565b61027f565b61013a610135366004610710565b610292565b60405190151581526020016100d0565b6100ff610158366004610868565b604080517fffffffffffffffff00000000000000000000000000000000000000000000000060c096871b811660208084019190915295871b8116602883015293861b841660308201529190941b909116603882015282518082039092018252820190915290565b6101d26101cd366004610710565b6102b8565b6040519081526020016100d0565b6100bb6101ee366004610710565b6102cb565b6000610206610201836102de565b6102f1565b92915050565b600061020661021a836102de565b6102fd565b6060600061022c836102de565b905061023781610309565b9392505050565b606061027a6040805160006020808301829052602883018290526030830182905260388301919091528251808303909101815290820190915290565b905090565b600061020661028d836102de565b610366565b60006102066102a083610372565b6fffffffffffffffffffffffffffffffff1660201490565b60006102066102c6836102de565b61038d565b60006102066102d9836102de565b6103dc565b60006102066102ec83610372565b6103e8565b6000816102378161046e565b6000816102378161047c565b6040518061031a836020830161048a565b506fffffffffffffffffffffffffffffffff83166000601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168301602001604052509052919050565b60008161023781610539565b8051600090602083016103858183610548565b949350505050565b60008161039981610539565b6103a2826105ab565b6103ab8361047c565b6103b48461046e565b6103be91906108bc565b6103c891906108bc565b6103d291906108bc565b60201b9392505050565b600081610237816105ab565b600060206fffffffffffffffffffffffffffffffff83161461046a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e6f7420612074697073207061796c6f61640000000000000000000000000000604482015260640160405180910390fd5b5090565b6000610206828260086105b6565b6000610206826008806105b6565b6040516000906fffffffffffffffffffffffffffffffff841690608085901c90808510156104e4576040517f4b2a158c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008386858560045afa905080610527576040517f7c7d772f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608086901b8417979650505050505050565b600061020682601860086105b6565b60008061055583856108bc565b9050604051811115610565575060005b8060000361059f576040517f10bef38600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b608084901b8317610385565b600061020682601060085b6000806105c48585856105d7565b602084900360031b1c9150509392505050565b6000816000036105e957506000610237565b6020821115610624576040517f31d784a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6fffffffffffffffffffffffffffffffff841661064183856108bc565b1115610679576040517fa3b99ded00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600382901b600061068a8660801c90565b909401517f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092019190911d16949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60006020828403121561072257600080fd5b813567ffffffffffffffff8082111561073a57600080fd5b818401915084601f83011261074e57600080fd5b813581811115610760576107606106e1565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156107a6576107a66106e1565b816040528281528760208487010111156107bf57600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208083528351808285015260005b8181101561080c578581018301518582016040015282016107f0565b5060006040828601015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505092915050565b803567ffffffffffffffff8116811461086357600080fd5b919050565b6000806000806080858703121561087e57600080fd5b6108878561084b565b93506108956020860161084b565b92506108a36040860161084b565b91506108b16060860161084b565b905092959194509250565b80820180821115610206577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea264697066735822122001f354c5ca0209f2d3f35196201266289b564b322384904278bbb97cdf61111664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns summitTip field\n    function summitTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().summitTip();\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().attestationTip();\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().executionTip();\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().deliveryTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function value(bytes memory payload) public pure returns (uint256) {\n        return payload.castToTips().value();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"32309:2620:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"32309:2620:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;33267:126;;;;;;:::i;:::-;;:::i;:::-;;;1362:18:1;1350:31;;;1332:50;;1320:2;1305:18;33267:126:0;;;;;;;;33444:136;;;;;;:::i;:::-;;:::i;32893:328::-;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;34828:99::-;;;:::i;33809:130::-;;;;;;:::i;:::-;;:::i;34112:111::-;;;;;;:::i;:::-;;:::i;:::-;;;2168:14:1;;2161:22;2143:41;;2131:2;2116:18;34112:111:0;2003:187:1;34553:269:0;;;;;;:::i;:::-;28247:74;;;3174:66:1;3269:3;3265:16;;;3261:25;;28247:74:0;;;;3249:38:1;;;;3320:16;;;3316:25;;3303:11;;;3296:46;3376:16;;;3372:25;;3358:12;;;3351:47;3432:16;;;;3428:25;;;3414:12;;;3407:47;28247:74:0;;;;;;;;;;3470:12:1;;28247:74:0;;;;34553:269;33987:119;;;;;;:::i;:::-;;:::i;:::-;;;2923:25:1;;;2911:2;2896:18;33987:119:0;2777:177:1;33629:132:0;;;;;;:::i;:::-;;:::i;33267:126::-;33329:6;33354:32;:20;:7;:18;:20::i;:::-;:30;:32::i;:::-;33347:39;33267:126;-1:-1:-1;;33267:126:0:o;33444:136::-;33511:6;33536:37;:20;:7;:18;:20::i;:::-;:35;:37::i;32893:328::-;32956:12;33137:9;33149:27;33168:7;33149:18;:27::i;:::-;33137:39;-1:-1:-1;33193:21:0;33137:39;33193:19;:21::i;:::-;33186:28;32893:328;-1:-1:-1;;;32893:328:0:o;34828:99::-;34870:12;34901:19;28247:74;;;28537:1;28247:74;;;;3249:38:1;;;3303:11;;;3296:46;;;3358:12;;;3351:47;;;3414:12;;;3407:47;;;;28247:74:0;;;;;;;;;;3470:12:1;;;28247:74:0;;;34828:99;;34901:19;34894:26;;34828:99;:::o;33809:130::-;33873:6;33898:34;:20;:7;:18;:20::i;:::-;:32;:34::i;34112:111::-;34171:4;34194:22;:13;:7;:11;:13::i;:::-;11507:17;11481:43;2019:2;29298:28;;29219:114;33987:119;34045:7;34071:28;:20;:7;:18;:20::i;:::-;:26;:28::i;33629:132::-;33694:6;33719:35;:20;:7;:18;:20::i;:::-;:33;:35::i;28702:120::-;28767:4;28790:25;28801:13;:7;:11;:13::i;:::-;28790:10;:25::i;29879:153::-;29932:6;29968:4;30005:19;29968:4;30005:10;:19::i;30083:163::-;30141:6;30177:4;30214:24;30177:4;30214:15;:24::i;8321:1041::-;8567:4;8561:11;;8697:34;8711:7;8726:4;8720:10;;8697:13;:34::i;:::-;-1:-1:-1;11507:17:0;11481:43;;8943:12;12339:2;12323:18;;12707:20;;9239;;9261:4;9235:31;9229:4;9222:45;-1:-1:-1;9329:17:0;;8321:1041;;-1:-1:-1;8321:1041:0:o;30502:157::-;30557:6;30593:4;30630:21;30593:4;30630:12;:21::i;7214:569::-;7302:10;;7268:7;;7728:4;7719:14;;7759:17;7719:14;7302:10;7759:5;:17::i;:::-;7752:24;7214:569;-1:-1:-1;;;;7214:569:0:o;30798:264::-;30847:14;30891:4;30997:21;30891:4;30997:12;:21::i;:::-;30972:22;30986:7;30972:13;:22::i;:::-;30945:24;30961:7;30945:15;:24::i;:::-;30923:19;30934:7;30923:10;:19::i;:::-;:46;;;;:::i;:::-;:71;;;;:::i;:::-;:95;;;;:::i;:::-;2127:2;31028:27;;30798:264;-1:-1:-1;;;30798:264:0:o;30295:159::-;30351:6;30387:4;30424:22;30387:4;30424:13;:22::i;28966:180::-;29026:4;2019:2;11507:17;11481:43;;29298:28;29042:46;;;;;;;3979:2:1;29042:46:0;;;3961:21:1;4018:2;3998:18;;;3991:30;4057:20;4037:18;;;4030:48;4095:18;;29042:46:0;;;;;;;;-1:-1:-1;29130:7:0;28966:180::o;31433:150::-;31493:7;31519:57;:7;31493;31573:1;31519:17;:57::i;31645:160::-;31710:7;31736:62;:7;27032:1;;31736:17;:62::i;22255:842::-;22594:4;22588:11;22333:7;;11507:17;11481:43;;;11140:3;11113:30;;;;22676:12;;;22672:66;;;22711:16;;;;;;;;;;;;;;22672:66;22747:8;22963:4;22955:6;22949:4;22941:6;22935:4;22928:5;22917:51;22910:58;;22992:3;22987:37;;23004:20;;;;;;;;;;;;;;22987:37;21604:3;21596:11;;;21595:20;;23034:56;22255:842;-1:-1:-1;;;;;;;22255:842:0:o;32080:154::-;32142:7;32168:59;:7;27142:2;32224:1;32168:17;:59::i;6334:540::-;6400:7;;6434:11;6441:4;6434;:11;:::i;:::-;6419:26;;6713:4;6707:11;6701:4;6698:21;6695:38;;;-1:-1:-1;6730:1:0;6695:38;6756:4;6764:1;6756:9;6752:66;;6788:19;;;;;;;;;;;;;;6752:66;21604:3;21596:11;;;21595:20;;6834:33;21271:352;31865:156;31928:7;31954:60;:7;27087:2;32011:1;19794:538;19885:7;;19927:29;:7;19941:6;19949;19927:13;:29::i;:::-;20297:2;:11;;;20313:1;20296:18;20270:45;;-1:-1:-1;;19794:538:0;;;;;:::o;18102:1334::-;18189:14;18219:6;18229:1;18219:11;18215:59;;-1:-1:-1;18261:1:0;18246:17;;18215:59;18360:2;18351:6;:11;18347:65;;;18385:16;;;;;;;;;;;;;;18347:65;11507:17;11481:43;;18491:15;18500:6;18491;:15;:::i;:::-;:31;18487:82;;;18545:13;;;;;;;;;;;;;;18487:82;18608:1;18598:11;;;18578:17;18648:13;:7;11140:3;11113:30;;10954:196;18648:13;19395:17;;;19389:24;19106:66;19087:17;;;;;19083:90;;;;19385:35;;18102:1334;-1:-1:-1;;;;18102:1334:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:980;271:6;324:2;312:9;303:7;299:23;295:32;292:52;;;340:1;337;330:12;292:52;380:9;367:23;409:18;450:2;442:6;439:14;436:34;;;466:1;463;456:12;436:34;504:6;493:9;489:22;479:32;;549:7;542:4;538:2;534:13;530:27;520:55;;571:1;568;561:12;520:55;607:2;594:16;629:2;625;622:10;619:36;;;635:18;;:::i;:::-;769:2;763:9;831:4;823:13;;674:66;819:22;;;843:2;815:31;811:40;799:53;;;867:18;;;887:22;;;864:46;861:72;;;913:18;;:::i;:::-;953:10;949:2;942:22;988:2;980:6;973:18;1028:7;1023:2;1018;1014;1010:11;1006:20;1003:33;1000:53;;;1049:1;1046;1039:12;1000:53;1105:2;1100;1096;1092:11;1087:2;1079:6;1075:15;1062:46;1150:1;1128:15;;;1145:2;1124:24;1117:35;;;;-1:-1:-1;1132:6:1;203:980;-1:-1:-1;;;;;203:980:1:o;1393:605::-;1503:4;1532:2;1561;1550:9;1543:21;1593:6;1587:13;1636:6;1631:2;1620:9;1616:18;1609:34;1661:1;1671:140;1685:6;1682:1;1679:13;1671:140;;;1780:14;;;1776:23;;1770:30;1746:17;;;1765:2;1742:26;1735:66;1700:10;;1671:140;;;1675:3;1860:1;1855:2;1846:6;1835:9;1831:22;1827:31;1820:42;1989:2;1919:66;1914:2;1906:6;1902:15;1898:88;1887:9;1883:104;1879:113;1871:121;;;;1393:605;;;;:::o;2195:171::-;2262:20;;2322:18;2311:30;;2301:41;;2291:69;;2356:1;2353;2346:12;2291:69;2195:171;;;:::o;2371:401::-;2453:6;2461;2469;2477;2530:3;2518:9;2509:7;2505:23;2501:33;2498:53;;;2547:1;2544;2537:12;2498:53;2570:28;2588:9;2570:28;:::i;:::-;2560:38;;2617:37;2650:2;2639:9;2635:18;2617:37;:::i;:::-;2607:47;;2673:37;2706:2;2695:9;2691:18;2673:37;:::i;:::-;2663:47;;2729:37;2762:2;2751:9;2747:18;2729:37;:::i;:::-;2719:47;;2371:401;;;;;;;:::o;3493:279::-;3558:9;;;3579:10;;;3576:190;;;3622:77;3619:1;3612:88;3723:4;3720:1;3713:15;3751:4;3748:1;3741:15","abiDefinition":[{"inputs":[],"name":"IndexedTooMuch","type":"error"},{"inputs":[],"name":"OccupiedMemory","type":"error"},{"inputs":[],"name":"PrecompileOutOfGas","type":"error"},{"inputs":[],"name":"UnallocatedMemory","type":"error"},{"inputs":[],"name":"ViewOverrun","type":"error"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"attestationTip","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"deliveryTip","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"emptyTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"executionTip","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint64","name":"summitTip_","type":"uint64"},{"internalType":"uint64","name":"attestationTip_","type":"uint64"},{"internalType":"uint64","name":"executionTip_","type":"uint64"},{"internalType":"uint64","name":"deliveryTip_","type":"uint64"}],"name":"formatTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isTips","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"summitTip","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"value","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"attestationTip(bytes)":{"notice":"Returns attestationTip field"},"deliveryTip(bytes)":{"notice":"Returns deliveryTip field"},"executionTip(bytes)":{"notice":"Returns executionTip field"},"summitTip(bytes)":{"notice":"Returns summitTip field"},"value(bytes)":{"notice":"Returns total tip amount."}},"notice":"Exposes TipsLib methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IndexedTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OccupiedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrecompileOutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallocatedMemory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ViewOverrun\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"attestationTip\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"deliveryTip\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emptyTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"executionTip\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"summitTip_\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"attestationTip_\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"executionTip_\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"deliveryTip_\",\"type\":\"uint64\"}],\"name\":\"formatTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isTips\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"summitTip\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"value\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"attestationTip(bytes)\":{\"notice\":\"Returns attestationTip field\"},\"deliveryTip(bytes)\":{\"notice\":\"Returns deliveryTip field\"},\"executionTip(bytes)\":{\"notice\":\"Returns executionTip field\"},\"summitTip(bytes)\":{\"notice\":\"Returns summitTip field\"},\"value(bytes)\":{\"notice\":\"Returns total tip amount.\"}},\"notice\":\"Exposes TipsLib methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"TipsHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xb9a954f5183d641853b90b40febdb1f614e517f892acfd61892417d75c147f9c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2260865d391083ec6baa85b05a678d8b80cc14fcdf4d7133f61df9e72620bb6c\",\"dweb:/ipfs/QmY9BRLSyoxSxntDui5BAdYBmed8J7hp4rr2iXBivquuv6\"]}},\"version\":1}"},"hashes":{"attestationTip(bytes)":"4d76edf1","castToTips(bytes)":"50190c31","deliveryTip(bytes)":"8071531f","emptyTips()":"725bd463","executionTip(bytes)":"fb2f718c","formatTips(uint64,uint64,uint64,uint64)":"a94afa73","isTips(bytes)":"993abc41","summitTip(bytes)":"35d1d816","value(bytes)":"ec6acad6"}},"solidity/TipsHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122022bf2b0f55ae39b50240caf1e859631875c1201d95ba912666cb9fe179414ee664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122022bf2b0f55ae39b50240caf1e859631875c1201d95ba912666cb9fe179414ee664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See Receipt.sol: (uint32,uint32,bytes32,bytes32,uint8,address,address,address,tips): 4+4+32+32+1+20+20+20\nuint256 constant RECEIPT_BODY_LENGTH = 133;\n/// @dev See Receipt.sol: body + tips\nuint256 constant RECEIPT_LENGTH = RECEIPT_BODY_LENGTH + TIPS_LENGTH;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint64,uint64,uint64,uint64): 8+8+8+8\nuint256 constant TIPS_LENGTH = 32;\n/// @dev The amount of discarded last bits when encoding tip values\nuint256 constant TIPS_GRANULARITY = 32;\n/// @dev Tip values could be only the multiples of TIPS_MULTIPLIER\nuint256 constant TIPS_MULTIPLIER = 1 \u003c\u003c TIPS_GRANULARITY;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant RECEIPT_SALT = keccak256(\"RECEIPT_SALT\");\nbytes32 constant RECEIPT_REPORT_SALT = keccak256(\"RECEIPT_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev MemView is an untyped view over a portion of memory to be used instead of `bytes memory`\ntype MemView is uint256;\n\n/// @dev Attach library functions to MemView\nusing MemViewLib for MemView global;\n\n/// @notice Library for operations with the memory views.\n/// Forked from https://github.com/summa-tx/memview-sol with several breaking changes:\n/// - The codebase is ported to Solidity 0.8\n/// - Custom errors are added\n/// - The runtime type checking is replaced with compile-time check provided by User-Defined Value Types\n///   https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types\n/// - uint256 is used as the underlying type for the \"memory view\" instead of bytes29.\n///   It is wrapped into MemView custom type in order not to be confused with actual integers.\n/// - Therefore the \"type\" field is discarded, allowing to allocate 16 bytes for both view location and length\n/// - The documentation is expanded\n/// - Library functions unused by the rest of the codebase are removed\n//  - Very pretty code separators are added :)\nlibrary MemViewLib {\n    error IndexedTooMuch();\n    error ViewOverrun();\n    error OccupiedMemory();\n    error UnallocatedMemory();\n    error PrecompileOutOfGas();\n\n    /// @notice Stack layout for uint256 (from highest bits to lowest)\n    /// (32 .. 16]      loc     16 bytes    Memory address of underlying bytes\n    /// (16 .. 00]      len     16 bytes    Length of underlying bytes\n\n    // ═══════════════════════════════════════════ BUILDING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Instantiate a new untyped memory view. This should generally not be called directly.\n     * Prefer `ref` wherever possible.\n     * @param loc_          The memory address\n     * @param len_          The length\n     * @return The new view with the specified location and length\n     */\n    function build(uint256 loc_, uint256 len_) internal pure returns (MemView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            revert UnallocatedMemory();\n        }\n        return _unsafeBuildUnchecked(loc_, len_);\n    }\n\n    /**\n     * @notice Instantiate a memory view from a byte array.\n     * @dev Note that due to Solidity memory representation, it is not possible to\n     * implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr           The byte array\n     * @return The memory view over the provided byte array\n     */\n    function ref(bytes memory arr) internal pure returns (MemView) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n        return build(loc_, len_);\n    }\n\n    // ════════════════════════════════════════════ CLONING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to the new memory.\n     * @param memView       The memory view\n     * @return arr          The cloned byte array\n     */\n    function clone(MemView memView) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        unchecked {\n            _unsafeCopyTo(memView, ptr + 0x20);\n        }\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 len_ = memView.len();\n        uint256 footprint_ = memView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    /**\n     * @notice Copies all views, joins them into a new bytearray.\n     * @param memViews      The memory views\n     * @return arr          The new byte array with joined data behind the given views\n     */\n    function join(MemView[] memory memViews) internal view returns (bytes memory arr) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n            // This is where the byte array will be stored\n            arr := ptr\n        }\n        MemView newView;\n        unchecked {\n            newView = _unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 len_ = newView.len();\n        uint256 footprint_ = newView.footprint();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Write new unused pointer: the old value + array footprint + 32 bytes to store the length\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            // Write len of new array (in bytes)\n            mstore(ptr, len_)\n        }\n    }\n\n    // ══════════════════════════════════════════ INSPECTING MEMORY VIEW ═══════════════════════════════════════════════\n\n    /**\n     * @notice Returns the memory address of the underlying bytes.\n     * @param memView       The memory view\n     * @return loc_         The memory address\n     */\n    function loc(MemView memView) internal pure returns (uint256 loc_) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u003e\u003e 128;\n    }\n\n    /**\n     * @notice Returns the number of bytes of the view.\n     * @param memView       The memory view\n     * @return len_         The length of the view\n     */\n    function len(MemView memView) internal pure returns (uint256 len_) {\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        return MemView.unwrap(memView) \u0026 type(uint128).max;\n    }\n\n    /**\n     * @notice Returns the endpoint of `memView`.\n     * @param memView       The memory view\n     * @return end_         The endpoint of `memView`\n     */\n    function end(MemView memView) internal pure returns (uint256 end_) {\n        // The endpoint never overflows uint128, let alone uint256, so we could use unchecked math here\n        unchecked {\n            return memView.loc() + memView.len();\n        }\n    }\n\n    /**\n     * @notice Returns the number of memory words this memory view occupies, rounded up.\n     * @param memView       The memory view\n     * @return words_       The number of memory words\n     */\n    function words(MemView memView) internal pure returns (uint256 words_) {\n        // returning ceil(length / 32.0)\n        unchecked {\n            return (memView.len() + 31) \u003e\u003e 5;\n        }\n    }\n\n    /**\n     * @notice Returns the in-memory footprint of a fresh copy of the view.\n     * @param memView       The memory view\n     * @return footprint_   The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(MemView memView) internal pure returns (uint256 footprint_) {\n        // words() * 32\n        return memView.words() \u003c\u003c 5;\n    }\n\n    // ════════════════════════════════════════════ HASHING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the keccak256 hash of the underlying memory\n     * @param memView       The memory view\n     * @return digest       The keccak256 hash of the underlying memory\n     */\n    function keccak(MemView memView) internal pure returns (bytes32 digest) {\n        uint256 loc_ = memView.loc();\n        uint256 len_ = memView.len();\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice Adds a salt to the keccak256 hash of the underlying data and returns the keccak256 hash of the\n     * resulting data.\n     * @param memView       The memory view\n     * @return digestSalted keccak256(salt, keccak256(memView))\n     */\n    function keccakSalted(MemView memView, bytes32 salt) internal pure returns (bytes32 digestSalted) {\n        return keccak256(bytes.concat(salt, memView.keccak()));\n    }\n\n    // ════════════════════════════════════════════ SLICING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Safe slicing without memory modification.\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the given index\n     */\n    function slice(MemView memView, uint256 index_, uint256 len_) internal pure returns (MemView) {\n        uint256 loc_ = memView.loc();\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e memView.end()) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // loc_ + index_ \u003c= memView.end()\n            return build({loc_: loc_ + index_, len_: len_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing bytes from `index` to end(memView).\n     * @param memView       The memory view\n     * @param index_        The start index\n     * @return The new view for the slice starting from the given index until the initial view endpoint\n     */\n    function sliceFrom(MemView memView, uint256 index_) internal pure returns (MemView) {\n        uint256 len_ = memView.len();\n        // Ensure it doesn't overrun the view\n        if (index_ \u003e len_) {\n            revert ViewOverrun();\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // index_ \u003c= len_ =\u003e memView.loc() + index_ \u003c= memView.loc() + memView.len() == memView.end()\n            return build({loc_: memView.loc() + index_, len_: len_ - index_});\n        }\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length starting from the initial view beginning\n     */\n    function prefix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        return memView.slice({index_: 0, len_: len_});\n    }\n\n    /**\n     * @notice Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param memView       The memory view\n     * @param len_          The length\n     * @return The new view for the slice of the given length until the initial view endpoint\n     */\n    function postfix(MemView memView, uint256 len_) internal pure returns (MemView) {\n        uint256 viewLen = memView.len();\n        // Ensure it doesn't overrun the view\n        if (len_ \u003e viewLen) {\n            revert ViewOverrun();\n        }\n        // Could do the unchecked math due to the check above\n        uint256 index_;\n        unchecked {\n            index_ = viewLen - len_;\n        }\n        // Build a view starting from index with the given length\n        unchecked {\n            // len_ \u003c= memView.len() =\u003e memView.loc() \u003c= loc_ \u003c= memView.end()\n            return build({loc_: memView.loc() + viewLen - len_, len_: len_});\n        }\n    }\n\n    // ═══════════════════════════════════════════ INDEXING MEMORY VIEW ════════════════════════════════════════════════\n\n    /**\n     * @notice Load up to 32 bytes from the view onto the stack.\n     * @dev Returns a bytes32 with only the `bytes_` HIGHEST bytes set.\n     * This can be immediately cast to a smaller fixed-length byte array.\n     * To automatically cast to an integer, use `indexUint`.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return result       The 32 byte result having only `bytes_` highest bytes set\n     */\n    function index(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        // Can't load more than 32 bytes to the stack in one go\n        if (bytes_ \u003e 32) {\n            revert IndexedTooMuch();\n        }\n        // The last indexed byte should be within view boundaries\n        if (index_ + bytes_ \u003e memView.len()) {\n            revert ViewOverrun();\n        }\n        uint256 bitLength = bytes_ \u003c\u003c 3; // bytes_ * 8\n        uint256 loc_ = memView.loc();\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask;\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(bitLength, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice Parse an unsigned integer from the view at `index`.\n     * @dev Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @param bytes_        The amount of bytes to load onto the stack\n     * @return The unsigned integer\n     */\n    function indexUint(MemView memView, uint256 index_, uint256 bytes_) internal pure returns (uint256) {\n        bytes32 indexedBytes = memView.index(index_, bytes_);\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word: need to shift right `(32 - bytes_)` bytes\n        unchecked {\n            // memView.index() reverts when bytes_ \u003e 32, thus unchecked math\n            return uint256(indexedBytes) \u003e\u003e ((32 - bytes_) \u003c\u003c 3);\n        }\n    }\n\n    /**\n     * @notice Parse an address from the view at `index`.\n     * @dev Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView       The memory view\n     * @param index_        The index\n     * @return The address\n     */\n    function indexAddress(MemView memView, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(memView.indexUint(index_, 20)));\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Returns a memory view over the specified memory location\n    /// without checking if it points to unallocated memory.\n    function _unsafeBuildUnchecked(uint256 loc_, uint256 len_) private pure returns (MemView) {\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return MemView.wrap((loc_ \u003c\u003c 128) | len_);\n    }\n\n    /**\n     * @notice Copy the view to a location, return an unsafe memory reference\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memView       The memory view\n     * @param newLoc        The new location to copy the underlying view data\n     * @return The memory view over the unsafe memory with the copied underlying data\n     */\n    function _unsafeCopyTo(MemView memView, uint256 newLoc) private view returns (MemView) {\n        uint256 len_ = memView.len();\n        uint256 oldLoc = memView.loc();\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (newLoc \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        if (!res) revert PrecompileOutOfGas();\n        return _unsafeBuildUnchecked({loc_: newLoc, len_: len_});\n    }\n\n    /**\n     * @notice Join the views in memory, return an unsafe reference to the memory.\n     * @dev Super Dangerous direct memory access.\n     * This reference can be overwritten if anything else modifies memory (!!!).\n     * As such it MUST be consumed IMMEDIATELY. Update the free memory pointer to ensure the copied data\n     * is not overwritten. This function is private to prevent unsafe usage by callers.\n     * @param memViews      The memory views\n     * @return The conjoined view pointing to the new memory\n     */\n    function _unsafeJoin(MemView[] memory memViews, uint256 location) private view returns (MemView) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load unused memory pointer\n            ptr := mload(0x40)\n        }\n        // Revert if we're writing in occupied memory\n        if (location \u003c ptr) {\n            revert OccupiedMemory();\n        }\n        // Copy the views to the specified location one by one, by tracking the amount of copied bytes so far\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length;) {\n            MemView memView = memViews[i];\n            // We can use the unchecked math here as location + sum(view.length) will never overflow uint256\n            unchecked {\n                _unsafeCopyTo(memView, location + offset);\n                offset += memView.len();\n                ++i;\n            }\n        }\n        return _unsafeBuildUnchecked({loc_: location, len_: offset});\n    }\n}\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is uint256;\n\n/// @dev Attach library functions to Tips\nusing TipsLib for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using MemViewLib for bytes;\n\n    /**\n     * @dev Tips are paid for sending a base message, and are split across all the agents that\n     * made the message execution on destination chain possible.\n     *  1. Summit tips. Split between:\n     *      a. Guard posting a snapshot with state ST_G for the origin chain.\n     *      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.\n     *      c. Notary posting a message receipt after it is executed on destination chain.\n     *  2. Attestation tips. Paid to:\n     *      a. Notary posting attestation A to destination chain.\n     *  3. Execution tips. Paid to:\n     *      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),\n     *      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.\n     *  4. Delivery tips. Paid to:\n     *      a. Executor who successfully executed the message on destination chain.\n     * @dev The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32.\n     * Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category.\n     * The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for\n     * the chains with the most expensive gas currency.\n     * @dev Tips memory layout\n     * [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract\n     * [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract\n     * [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain\n     * [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain\n     *\n     * The variables below are not supposed to be used outside of the library directly.\n     */\n\n    uint256 private constant OFFSET_SUMMIT_TIP = 0;\n    uint256 private constant OFFSET_ATTESTATION_TIP = 8;\n    uint256 private constant OFFSET_EXECUTION_TIP = 16;\n    uint256 private constant OFFSET_DELIVERY_TIP = 24;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param summitTip_        Tip for agents interacting with Summit contract, divided by TIPS_MULTIPLIER\n     * @param attestationTip_   Tip for Notary posting attestation to Destination contract, divided by TIPS_MULTIPLIER\n     * @param executionTip_     Tip for valid execution attempt on destination chain, divided by TIPS_MULTIPLIER\n     * @param deliveryTip_      Tip for successful message delivery on destination chain, divided by TIPS_MULTIPLIER\n     * @return Formatted tips\n     */\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.ref());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(MemView memView) internal pure returns (Tips) {\n        require(isTips(memView), \"Not a tips payload\");\n        return Tips.wrap(MemView.unwrap(memView));\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(MemView memView) internal pure returns (bool) {\n        return memView.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (MemView) {\n        return MemView.wrap(Tips.unwrap(tips));\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field\n    function summitTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_summitTip(memView));\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_attestationTip(memView));\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_executionTip(memView));\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(Tips tips) internal pure returns (uint64) {\n        MemView memView = tips.unwrap();\n        return uint64(_deliveryTip(memView));\n    }\n\n    /// @notice Returns total value of the tips payload.\n    /// This is the sum of the encoded values, scaled up by TIPS_MULTIPLIER\n    function value(Tips tips) internal pure returns (uint256 value_) {\n        MemView memView = tips.unwrap();\n        value_ = _summitTip(memView) + _attestationTip(memView) + _executionTip(memView) + _deliveryTip(memView);\n        value_ \u003c\u003c= TIPS_GRANULARITY;\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @notice Returns summitTip field as uint256\n    function _summitTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_SUMMIT_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns attestationTip field as uint256\n    function _attestationTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_ATTESTATION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns executionTip field as uint256\n    function _executionTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_EXECUTION_TIP, bytes_: 8});\n    }\n\n    /// @notice Returns deliveryTip field as uint256\n    function _deliveryTip(MemView memView) internal pure returns (uint256) {\n        return memView.indexUint({index_: OFFSET_DELIVERY_TIP, bytes_: 8});\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for MemView;\n    using MemViewLib for bytes;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns summitTip field\n    function summitTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().summitTip();\n    }\n\n    /// @notice Returns attestationTip field\n    function attestationTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().attestationTip();\n    }\n\n    /// @notice Returns executionTip field\n    function executionTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().executionTip();\n    }\n\n    /// @notice Returns deliveryTip field\n    function deliveryTip(bytes memory payload) public pure returns (uint64) {\n        return payload.castToTips().deliveryTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function value(bytes memory payload) public pure returns (uint256) {\n        return payload.castToTips().value();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref().isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint64 summitTip_, uint64 attestationTip_, uint64 executionTip_, uint64 deliveryTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(summitTip_, attestationTip_, executionTip_, deliveryTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"24927:7309:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;24927:7309:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"24927:7309:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_SUMMIT_TIP":{"details":"Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible.  1. Summit tips. Split between:      a. Guard posting a snapshot with state ST_G for the origin chain.      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.      c. Notary posting a message receipt after it is executed on destination chain.  2. Attestation tips. Paid to:      a. Notary posting attestation A to destination chain.  3. Execution tips. Paid to:      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.  4. Delivery tips. Paid to:      a. Executor who successfully executed the message on destination chain.The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. The only downside is that the \"real tip values\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency.Tips memory layout [000 .. 008): summitTip          uint64\t 8 bytes    Tip for agents interacting with Summit contract [008 .. 016): attestationTip     uint64\t 8 bytes    Tip for Notary posting attestation to Destination contract [016 .. 024): executionTip       uint64\t 8 bytes    Tip for valid execution attempt on destination chain [024 .. 032): deliveryTip        uint64\t 8 bytes    Tip for successful message delivery on destination chain The variables below are not supposed to be used outside of the library directly."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_SUMMIT_TIP\":{\"details\":\"Tips are paid for sending a base message, and are split across all the agents that made the message execution on destination chain possible.  1. Summit tips. Split between:      a. Guard posting a snapshot with state ST_G for the origin chain.      b. Notary posting a snapshot SN_N using ST_G. This creates attestation A.      c. Notary posting a message receipt after it is executed on destination chain.  2. Attestation tips. Paid to:      a. Notary posting attestation A to destination chain.  3. Execution tips. Paid to:      a. First executor performing a valid execution attempt (correct proofs, optimistic period over),      using attestation A to prove message inclusion on origin chain, whether the recipient reverted or not.  4. Delivery tips. Paid to:      a. Executor who successfully executed the message on destination chain.The actual tip values should be determined by multiplying stored values by divided by TIPS_MULTIPLIER=2**32. Tips are packed into a single word of storage, while allowing real values up to ~8*10**28 for every tip category. The only downside is that the \\\"real tip values\\\" are now multiplies of ~4*10**9, which should be fine even for the chains with the most expensive gas currency.Tips memory layout [000 .. 008): summitTip          uint64\\t 8 bytes    Tip for agents interacting with Summit contract [008 .. 016): attestationTip     uint64\\t 8 bytes    Tip for Notary posting attestation to Destination contract [016 .. 024): executionTip       uint64\\t 8 bytes    Tip for valid execution attempt on destination chain [024 .. 032): deliveryTip        uint64\\t 8 bytes    Tip for successful message delivery on destination chain The variables below are not supposed to be used outside of the library directly.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xb9a954f5183d641853b90b40febdb1f614e517f892acfd61892417d75c147f9c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2260865d391083ec6baa85b05a678d8b80cc14fcdf4d7133f61df9e72620bb6c\",\"dweb:/ipfs/QmY9BRLSyoxSxntDui5BAdYBmed8J7hp4rr2iXBivquuv6\"]}},\"version\":1}"},"hashes":{}}}