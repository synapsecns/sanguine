{"solidity/TipsHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122034b4aa86595491febc6da62995214aa7ff8b4526e02e53a6e5114491f64a946164736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122034b4aa86595491febc6da62995214aa7ff8b4526e02e53a6e5114491f64a946164736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().notaryTip();\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().broadcasterTip();\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().proverTip();\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().executorTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().totalTips();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n\n    // ═════════════════════════════════════════════ CONSTANT GETTERS ══════════════════════════════════════════════════\n\n    function tipsLength() public pure returns (uint256) {\n        return TIPS_LENGTH;\n    }\n\n    function offsetNotary() public pure returns (uint256) {\n        return TipsLib.OFFSET_NOTARY;\n    }\n\n    function offsetBroadcaster() public pure returns (uint256) {\n        return TipsLib.OFFSET_BROADCASTER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return TipsLib.OFFSET_PROVER;\n    }\n\n    function offsetExecutor() public pure returns (uint256) {\n        return TipsLib.OFFSET_EXECUTOR;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35473:9174:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35473:9174:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35473:9174:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Calldata memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xfaeeee1334bec6f167abf2d8c094dee010dfba27e1264f37641beca4bc13cf91\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://471e0d7c4132066e7f11171b87ab8359782b90b36683a3a544f099df4e6ed05d\",\"dweb:/ipfs/QmPckfEhGiL5eFaqYnjWbAtPj6RqDZZf4N3mRZH8DCEBVU\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.t.sol:TipsHarness":{"code":"0x608060405234801561001057600080fd5b50610ff4806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c806398de85541161008c578063b4b4ccb211610066578063b4b4ccb2146101bb578063d024f867146101c2578063e6f9466e146101d5578063f86f2bdb146101e857600080fd5b806398de85541461018a578063993abc4114610191578063b440592e146101b457600080fd5b80635c197a18116100c85780635c197a181461012c5780635f4911671461015c57806369529e581461016f578063725bd4631461018257600080fd5b806315bb7d2b146100ef57806350190c311461010557806351970c3f14610125575b600080fd5b600c5b6040519081526020015b60405180910390f35b610118610113366004610d31565b6101fb565b6040516100fc9190610e64565b60246100f2565b61013f61013a366004610d31565b610220565b6040516bffffffffffffffffffffffff90911681526020016100fc565b61013f61016a366004610d31565b61023f565b61013f61017d366004610d31565b610258565b610118610271565b60186100f2565b6101a461019f366004610d31565b6102b0565b60405190151581526020016100fc565b60306100f2565b60006100f2565b6101186101d0366004610e98565b6102dc565b61013f6101e3366004610d31565b610349565b61013f6101f6366004610d31565b610362565b606060006102088361037b565b905061021962ffffff19821661038e565b9392505050565b600061023961022e8361037b565b62ffffff19166103e1565b92915050565b600061023961024d8361037b565b62ffffff1916610425565b60006102396102668361037b565b62ffffff191661043b565b60606102ab60408051600060208201819052602c820181905260388201819052604482015281518082036030018152605090910190915290565b905090565b60006102396102bf8383610450565b62ffffff191660181c6bffffffffffffffffffffffff1660301490565b604080517fffffffffffffffffffffffff000000000000000000000000000000000000000060a087811b8216602084015286811b8216602c84015285811b8216603884015284901b1660448201528151808203603001815260509091019091526060905b95945050505050565b60006102396103578361037b565b62ffffff191661046b565b60006102396103708361037b565b62ffffff1916610480565b600061023961038983610496565b6104a2565b60606000806103ab8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506103d0848360200161052e565b508181016020016040529052919050565b60006103ec82610480565b6103f583610425565b6103fe8461046b565b6104078561043b565b6104119190610f1b565b61041b9190610f1b565b6102399190610f1b565b600062ffffff198216610219816018600c610715565b600062ffffff1982166102198183600c610715565b81516000906020840161034064ffffffffff85168284610745565b600062ffffff19821661021981600c80610715565b600062ffffff198216610219816024600c610715565b60006102398282610450565b60006104bf8260181c6bffffffffffffffffffffffff1660301490565b61052a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e6f7420612074697073207061796c6f6164000000000000000000000000000060448201526064015b60405180910390fd5b5090565b600062ffffff198084160361059f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610521565b6105a88361078c565b61060e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610521565b60006106288460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610643856107c8565b6bffffffffffffffffffffffff1690506000806040519150858211156106695760206060fd5b8386858560045afa9050806106da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610521565b61070a6106e6886107ef565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b6000610722826020610f47565b61072d906008610f60565b60ff1661073b858585610813565b901c949350505050565b6000806107528385610f7c565b9050604051811115610762575060005b806000036107775762ffffff19915050610219565b5050606092831b9190911790911b1760181b90565b6000610797826107ef565b64ffffffffff1664ffffffffff036107b157506000919050565b60006107bc836109c1565b60405110199392505050565b6000806107d760606018610f7c565b9290921c6bffffffffffffffffffffffff1692915050565b60008060606107ff816018610f7c565b6108099190610f7c565b9290921c92915050565b60008160ff1660000361082857506000610219565b6108408460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661085b60ff841685610f7c565b11156108de576108ab61086d856107c8565b6bffffffffffffffffffffffff166108938660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff166109fa565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105219190610e64565b60208260ff16111561094c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610521565b60088202600061095b866107c8565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60006109db8260181c6bffffffffffffffffffffffff1690565b6109e4836107c8565b016bffffffffffffffffffffffff169050919050565b60606000610a0786610b8a565b9150506000610a1586610b8a565b9150506000610a2386610b8a565b9150506000610a3186610b8a565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600080601f5b600f8160ff161115610bfd576000610ba9826008610f60565b60ff1685901c9050610bba81610c74565b61ffff16841793508160ff16601014610bd557601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610b90565b50600f5b60ff8160ff161015610c6e576000610c1a826008610f60565b60ff1685901c9050610c2b81610c74565b61ffff16831792508160ff16600014610c4657601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610c01565b50915091565b6000610c8660048360ff16901c610ca6565b60ff1661ffff919091161760081b610c9d82610ca6565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f84169182908110610cf357610cf3610f8f565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d4357600080fd5b813567ffffffffffffffff80821115610d5b57600080fd5b818401915084601f830112610d6f57600080fd5b813581811115610d8157610d81610d02565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610dc757610dc7610d02565b81604052828152876020848701011115610de057600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000815180845260005b81811015610e2657602081850181015186830182015201610e0a565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b6020815260006102196020830184610e00565b80356bffffffffffffffffffffffff81168114610e9357600080fd5b919050565b60008060008060808587031215610eae57600080fd5b610eb785610e77565b9350610ec560208601610e77565b9250610ed360408601610e77565b9150610ee160608601610e77565b905092959194509250565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6bffffffffffffffffffffffff818116838216019080821115610f4057610f40610eec565b5092915050565b60ff828116828216039081111561023957610239610eec565b60ff8181168382160290811690818114610f4057610f40610eec565b8082018082111561023957610239610eec565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220f30ee573618b00fa975075e1fe527a6a1109ff9329cb34600a6142414d09105964736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c806398de85541161008c578063b4b4ccb211610066578063b4b4ccb2146101bb578063d024f867146101c2578063e6f9466e146101d5578063f86f2bdb146101e857600080fd5b806398de85541461018a578063993abc4114610191578063b440592e146101b457600080fd5b80635c197a18116100c85780635c197a181461012c5780635f4911671461015c57806369529e581461016f578063725bd4631461018257600080fd5b806315bb7d2b146100ef57806350190c311461010557806351970c3f14610125575b600080fd5b600c5b6040519081526020015b60405180910390f35b610118610113366004610d31565b6101fb565b6040516100fc9190610e64565b60246100f2565b61013f61013a366004610d31565b610220565b6040516bffffffffffffffffffffffff90911681526020016100fc565b61013f61016a366004610d31565b61023f565b61013f61017d366004610d31565b610258565b610118610271565b60186100f2565b6101a461019f366004610d31565b6102b0565b60405190151581526020016100fc565b60306100f2565b60006100f2565b6101186101d0366004610e98565b6102dc565b61013f6101e3366004610d31565b610349565b61013f6101f6366004610d31565b610362565b606060006102088361037b565b905061021962ffffff19821661038e565b9392505050565b600061023961022e8361037b565b62ffffff19166103e1565b92915050565b600061023961024d8361037b565b62ffffff1916610425565b60006102396102668361037b565b62ffffff191661043b565b60606102ab60408051600060208201819052602c820181905260388201819052604482015281518082036030018152605090910190915290565b905090565b60006102396102bf8383610450565b62ffffff191660181c6bffffffffffffffffffffffff1660301490565b604080517fffffffffffffffffffffffff000000000000000000000000000000000000000060a087811b8216602084015286811b8216602c84015285811b8216603884015284901b1660448201528151808203603001815260509091019091526060905b95945050505050565b60006102396103578361037b565b62ffffff191661046b565b60006102396103708361037b565b62ffffff1916610480565b600061023961038983610496565b6104a2565b60606000806103ab8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506103d0848360200161052e565b508181016020016040529052919050565b60006103ec82610480565b6103f583610425565b6103fe8461046b565b6104078561043b565b6104119190610f1b565b61041b9190610f1b565b6102399190610f1b565b600062ffffff198216610219816018600c610715565b600062ffffff1982166102198183600c610715565b81516000906020840161034064ffffffffff85168284610745565b600062ffffff19821661021981600c80610715565b600062ffffff198216610219816024600c610715565b60006102398282610450565b60006104bf8260181c6bffffffffffffffffffffffff1660301490565b61052a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e6f7420612074697073207061796c6f6164000000000000000000000000000060448201526064015b60405180910390fd5b5090565b600062ffffff198084160361059f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610521565b6105a88361078c565b61060e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610521565b60006106288460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610643856107c8565b6bffffffffffffffffffffffff1690506000806040519150858211156106695760206060fd5b8386858560045afa9050806106da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610521565b61070a6106e6886107ef565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b6000610722826020610f47565b61072d906008610f60565b60ff1661073b858585610813565b901c949350505050565b6000806107528385610f7c565b9050604051811115610762575060005b806000036107775762ffffff19915050610219565b5050606092831b9190911790911b1760181b90565b6000610797826107ef565b64ffffffffff1664ffffffffff036107b157506000919050565b60006107bc836109c1565b60405110199392505050565b6000806107d760606018610f7c565b9290921c6bffffffffffffffffffffffff1692915050565b60008060606107ff816018610f7c565b6108099190610f7c565b9290921c92915050565b60008160ff1660000361082857506000610219565b6108408460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661085b60ff841685610f7c565b11156108de576108ab61086d856107c8565b6bffffffffffffffffffffffff166108938660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff166109fa565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105219190610e64565b60208260ff16111561094c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610521565b60088202600061095b866107c8565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60006109db8260181c6bffffffffffffffffffffffff1690565b6109e4836107c8565b016bffffffffffffffffffffffff169050919050565b60606000610a0786610b8a565b9150506000610a1586610b8a565b9150506000610a2386610b8a565b9150506000610a3186610b8a565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600080601f5b600f8160ff161115610bfd576000610ba9826008610f60565b60ff1685901c9050610bba81610c74565b61ffff16841793508160ff16601014610bd557601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610b90565b50600f5b60ff8160ff161015610c6e576000610c1a826008610f60565b60ff1685901c9050610c2b81610c74565b61ffff16831792508160ff16600014610c4657601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610c01565b50915091565b6000610c8660048360ff16901c610ca6565b60ff1661ffff919091161760081b610c9d82610ca6565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f84169182908110610cf357610cf3610f8f565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d4357600080fd5b813567ffffffffffffffff80821115610d5b57600080fd5b818401915084601f830112610d6f57600080fd5b813581811115610d8157610d81610d02565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610dc757610dc7610d02565b81604052828152876020848701011115610de057600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000815180845260005b81811015610e2657602081850181015186830182015201610e0a565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b6020815260006102196020830184610e00565b80356bffffffffffffffffffffffff81168114610e9357600080fd5b919050565b60008060008060808587031215610eae57600080fd5b610eb785610e77565b9350610ec560208601610e77565b9250610ed360408601610e77565b9150610ee160608601610e77565b905092959194509250565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6bffffffffffffffffffffffff818116838216019080821115610f4057610f40610eec565b5092915050565b60ff828116828216039081111561023957610239610eec565b60ff8181168382160290811690818114610f4057610f40610eec565b8082018082111561023957610239610eec565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220f30ee573618b00fa975075e1fe527a6a1109ff9329cb34600a6142414d09105964736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().notaryTip();\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().broadcasterTip();\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().proverTip();\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().executorTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().totalTips();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n\n    // ═════════════════════════════════════════════ CONSTANT GETTERS ══════════════════════════════════════════════════\n\n    function tipsLength() public pure returns (uint256) {\n        return TIPS_LENGTH;\n    }\n\n    function offsetNotary() public pure returns (uint256) {\n        return TipsLib.OFFSET_NOTARY;\n    }\n\n    function offsetBroadcaster() public pure returns (uint256) {\n        return TipsLib.OFFSET_BROADCASTER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return TipsLib.OFFSET_PROVER;\n    }\n\n    function offsetExecutor() public pure returns (uint256) {\n        return TipsLib.OFFSET_EXECUTOR;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"53060:3490:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"53060:3490:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;56225:109;49227:2;56225:109;;;160:25:1;;;148:2;133:18;56225:109:0;;;;;;;;53682:328;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;56445:103::-;49329:2;56445:103;;54767:126;;;;;;:::i;:::-;;:::i;:::-;;;2252:26:1;2240:39;;;2222:58;;2210:2;2195:18;54767:126:0;2078:208:1;54415:126:0;;;;;;:::i;:::-;;:::i;54056:::-;;;;;;:::i;:::-;;:::i;55610:99::-;;;:::i;56340:::-;49277:2;56340:99;;54899:112;;;;;;:::i;:::-;;:::i;:::-;;;2456:14:1;;2449:22;2431:41;;2419:2;2404:18;54899:112:0;2291:187:1;56027:87:0;46349:2;56027:87;;56120:99;56165:7;56120:99;;55341:263;;;;;;:::i;:::-;;:::i;54233:136::-;;;;;;:::i;:::-;;:::i;54589:130::-;;;;;;:::i;:::-;;:::i;53682:328::-;53745:12;53926:9;53938:27;53957:7;53938:18;:27::i;:::-;53926:39;-1:-1:-1;53982:21:0;-1:-1:-1;;53982:11:0;;:19;:21::i;:::-;53975:28;53682:328;-1:-1:-1;;;53682:328:0:o;54767:126::-;54829:6;54854:32;:20;:7;:18;:20::i;:::-;-1:-1:-1;;54854:30:0;;:32::i;:::-;54847:39;54767:126;-1:-1:-1;;54767:126:0:o;54415:::-;54477:6;54502:32;:20;:7;:18;:20::i;:::-;-1:-1:-1;;54502:30:0;;:32::i;54056:126::-;54118:6;54143:32;:20;:7;:18;:20::i;:::-;-1:-1:-1;;54143:30:0;;:32::i;55610:99::-;55652:12;55683:19;50185:71;;;50472:1;50185:71;;;3745:38:1;;;3799:12;;;3792:47;;;3855:12;;;3848:47;;;3911:12;;;3904:47;50185:71:0;;;;;;;;;3967:12:1;;;;50185:71:0;;;55610:99;;55683:19;55676:26;;55610:99;:::o;54899:112::-;54958:4;54981:23;:14;:7;54958:4;54981:11;:14::i;:::-;-1:-1:-1;;54981:21:0;3309:2;18351:20;3702:16;18347:37;46349:2;51220:26;;51143:110;55341:263;50185:71;;;3670:66:1;3765:3;3761:16;;;3757:25;;50185:71:0;;;3745:38:1;3817:16;;;3813:25;;3799:12;;;3792:47;3873:16;;;3869:25;;3855:12;;;3848:47;3929:16;;;3925:25;3911:12;;;3904:47;50185:71:0;;;;;;;;;3967:12:1;;;;50185:71:0;;;55489:12;;55524:73;55517:80;55341:263;-1:-1:-1;;;;;55341:263:0:o;54233:136::-;54300:6;54325:37;:20;:7;:18;:20::i;:::-;-1:-1:-1;;54325:35:0;;:37::i;54589:130::-;54653:6;54678:34;:20;:7;:18;:20::i;:::-;-1:-1:-1;;54678:32:0;;:34::i;50637:131::-;50702:4;50725:36;50736:24;:7;:22;:24::i;:::-;50725:10;:36::i;30991:626::-;31044:16;31072:11;31093:12;31108:10;31112:5;3309:2;18351:20;3702:16;18347:37;;17835:565;31108:10;31093:25;;;;31228:4;31222:11;31215:18;;31283:3;31276:10;;31329:31;31342:5;31349:3;31355:4;31349:10;31329:12;:31::i;:::-;-1:-1:-1;31484:14:0;;;31500:4;31480:25;31474:4;31467:39;31547:17;;30991:626;;-1:-1:-1;30991:626:0:o;52656:329::-;52709:6;52961:17;52973:4;52961:11;:17::i;:::-;52943:15;52953:4;52943:9;:15::i;:::-;52920:20;52935:4;52920:14;:20::i;:::-;52902:15;52912:4;52902:9;:15::i;:::-;:38;;;;:::i;:::-;:56;;;;:::i;:::-;:76;;;;:::i;52224:166::-;52277:6;-1:-1:-1;;52311:11:0;;52348:34;52311:11;49277:2;52379;52348:15;:34::i;51785:166::-;51838:6;-1:-1:-1;;51872:11:0;;51909:34;51872:11;51838:6;51940:2;51909:15;:34::i;14468:595::-;14572:10;;14538:7;;14998:4;14989:14;;15030:26;;;;14989:14;14572:10;15030:5;:26::i;52002:176::-;52060:6;-1:-1:-1;;52094:11:0;;52131:39;52094:11;49227:2;;52131:15;:39::i;52438:170::-;52493:6;-1:-1:-1;;52527:11:0;;52564:36;52527:11;49329:2;52597;52564:15;:36::i;36638:127::-;36707:7;36733:25;:7;36707;36733:11;:25::i;50912:158::-;50970:4;50994:13;51001:5;3309:2;18351:20;3702:16;18347:37;46349:2;51220:26;;51143:110;50994:13;50986:44;;;;;;;4192:2:1;50986:44:0;;;4174:21:1;4231:2;4211:18;;;4204:30;4270:20;4250:18;;;4243:48;4308:18;;50986:44:0;;;;;;;;;-1:-1:-1;51057:5:0;50912:158::o;29774:846::-;29849:15;-1:-1:-1;;7984:13:0;;;;29876:53;;;;;;;4539:2:1;29876:53:0;;;4521:21:1;4578:2;4558:18;;;4551:30;4617:28;4597:18;;;4590:56;4663:18;;29876:53:0;4337:350:1;29876:53:0;29947:14;29955:5;29947:7;:14::i;:::-;29939:56;;;;;;;4894:2:1;29939:56:0;;;4876:21:1;4933:2;4913:18;;;4906:30;4972:31;4952:18;;;4945:59;5021:18;;29939:56:0;4692:353:1;29939:56:0;30005:12;30020:10;30024:5;3309:2;18351:20;3702:16;18347:37;;17835:565;30020:10;30005:25;;;;30040:14;30057:10;30061:5;30057:3;:10::i;:::-;30040:27;;;;30078:11;30099:8;30217:4;30211:11;30204:18;;30304:6;30299:3;30296:15;30293:41;;;30327:4;30321;30314:18;30293:41;30483:4;30475:6;30469:4;30461:6;30455:4;30448:5;30437:51;30430:58;;30515:3;30507:36;;;;;;;5252:2:1;30507:36:0;;;5234:21:1;5291:2;5271:18;;;5264:30;5330:22;5310:18;;;5303:50;5370:18;;30507:36:0;5050:344:1;30507:36:0;30564:49;30585:13;30592:5;30585:6;:13::i;:::-;12683:32;3221:2;12683:32;;;;12819:17;;12806:31;;12941:17;;3309:2;12926:33;;12075:900;30564:49;30554:59;29774:846;-1:-1:-1;;;;;;;29774:846:0:o;23410:340::-;23497:14;23726:11;23731:6;23726:2;:11;:::i;:::-;23725:17;;23741:1;23725:17;:::i;:::-;23683:60;;23691:28;23697:5;23704:6;23712;23691:5;:28::i;:::-;23683:60;;;23410:340;-1:-1:-1;;;;23410:340:0:o;13514:557::-;13595:15;;13637:11;13644:4;13637;:11;:::i;:::-;13622:26;;13916:4;13910:11;13904:4;13901:21;13898:38;;;-1:-1:-1;13933:1:0;13898:38;13959:4;13967:1;13959:9;13955:51;;-1:-1:-1;;13984:11:0;;;;;13955:51;-1:-1:-1;;3221:2:0;12683:32;;;12819:17;;;;12806:31;;;12941:17;3309:2;12926:33;;13514:557::o;8651:459::-;8706:8;8730:13;8737:5;8730:6;:13::i;:::-;:29;;8747:12;8730:29;8726:72;;-1:-1:-1;8782:5:0;;8651:459;-1:-1:-1;8651:459:0:o;8726:72::-;8807:12;8822:10;8826:5;8822:3;:10::i;:::-;9087:4;9081:11;-1:-1:-1;9068:26:0;;8651:459;-1:-1:-1;;;8651:459:0:o;16416:565::-;16467:11;;3493:20;3264:2;3309;3493:20;:::i;:::-;16932;;;;3702:16;16928:37;;16416:565;-1:-1:-1;;16416:565:0:o;15255:498::-;15309:12;;3221:2;3493:20;3221:2;3309;3493:20;:::i;:::-;3573;;;;:::i;:::-;15716:21;;;;;15255:498;-1:-1:-1;;15255:498:0:o;22217:848::-;22300:14;22330:6;:11;;22340:1;22330:11;22326:59;;-1:-1:-1;22372:1:0;22357:17;;22326:59;22416:10;22420:5;3309:2;18351:20;3702:16;18347:37;;17835:565;22416:10;22398:28;;:15;;;;:6;:15;:::i;:::-;:28;22394:131;;;22449:64;22465:10;22469:5;22465:3;:10::i;:::-;22449:64;;22477:10;22481:5;3309:2;18351:20;3702:16;18347:37;;17835:565;22477:10;22449:64;;22489:6;22505;22497:15;;22449;:64::i;:::-;22442:72;;;;;;;;;;;:::i;22394:131::-;22552:2;22542:6;:12;;;;22534:50;;;;;;;6341:2:1;22534:50:0;;;6323:21:1;6380:2;6360:18;;;6353:30;6419:27;6399:18;;;6392:55;6464:18;;22534:50:0;6139:349:1;22534:50:0;22665:1;22656:10;;22595:15;22701:10;22705:5;22701:3;:10::i;:::-;22686:25;;;-1:-1:-1;22777:12:0;7473:66;7459:12;;;7455:85;23024:17;;;;23018:24;23014:35;;;-1:-1:-1;;;;;22217:848:0:o;18568:141::-;18619:7;18682:10;18686:5;3309:2;18351:20;3702:16;18347:37;;17835:565;18682:10;18669;18673:5;18669:3;:10::i;:::-;:23;18662:30;;;;18568:141;;;:::o;20984:731::-;21116:17;21152:9;21165:15;21175:4;21165:9;:15::i;:::-;21149:31;;;21193:9;21206:15;21216:4;21206:9;:15::i;:::-;21190:31;;;21234:9;21247:17;21257:6;21247:9;:17::i;:::-;21231:33;;;21277:9;21290:17;21300:6;21290:9;:17::i;:::-;21343:355;;;7334:34:1;21343:355:0;;;7322:47:1;7399:23;7385:12;;;7378:45;7442:66;7546:3;7542:16;;;7538:25;;7524:12;;;7517:47;7583:17;7616:12;;;7609:24;;;7667:16;;;7663:25;;7649:12;;;7642:47;7719:34;7705:12;;;7698:56;7785:3;7770:13;;;7763:26;7824:16;;;7820:25;;7805:13;;;7798:48;7862:13;;;7855:25;;;;7915:16;;7911:25;;;7896:13;;;7889:48;-1:-1:-1;;6570:3:1;7983:13;;;6558:16;21343:355:0;;;;;;;;;6590:11:1;;;;21343:355:0;;;;;-1:-1:-1;;;;;20984:731:0:o;4905:662::-;4958:13;;5014:2;4999:256;5022:2;5018:1;:6;;;4999:256;;;5041:11;5067:5;:1;5071;5067:5;:::i;:::-;5061:12;;:1;:12;;5041:33;;5097:14;5105:5;5097:7;:14::i;:::-;5088:23;;;;;;5129:1;:7;;5134:2;5129:7;5125:58;;5166:2;5156:12;;;;;5125:58;-1:-1:-1;5224:6:0;;4999:256;;;-1:-1:-1;5318:2:0;5303:258;5326:3;5322:1;:7;;;5303:258;;;5346:11;5372:5;:1;5376;5372:5;:::i;:::-;5366:12;;:1;:12;;5346:33;;5403:14;5411:5;5403:7;:14::i;:::-;5393:24;;;;;;5435:1;:6;;5440:1;5435:6;5431:58;;5472:2;5461:13;;;;;5431:58;-1:-1:-1;5530:6:0;;5303:258;;;;4905:662;;;:::o;4385:196::-;4434:14;4471:17;4486:1;4481;:6;;;;4471:9;:17::i;:::-;4460:28;;4512:13;;;;;;4524:1;4512:13;4546:12;4556:1;4546:9;:12::i;:::-;4535:23;;;;4385:196;-1:-1:-1;4385:196:0:o;4014:199::-;4184:13;;;;;;;;;;;;;;;;;;4069:10;;4114:4;4106:12;;;;;4184:21;;;;;;:::i;:::-;;;;;;;;4014:199;-1:-1:-1;;;4014:199:0:o;196:184:1:-;248:77;245:1;238:88;345:4;342:1;335:15;369:4;366:1;359:15;385:980;453:6;506:2;494:9;485:7;481:23;477:32;474:52;;;522:1;519;512:12;474:52;562:9;549:23;591:18;632:2;624:6;621:14;618:34;;;648:1;645;638:12;618:34;686:6;675:9;671:22;661:32;;731:7;724:4;720:2;716:13;712:27;702:55;;753:1;750;743:12;702:55;789:2;776:16;811:2;807;804:10;801:36;;;817:18;;:::i;:::-;951:2;945:9;1013:4;1005:13;;856:66;1001:22;;;1025:2;997:31;993:40;981:53;;;1049:18;;;1069:22;;;1046:46;1043:72;;;1095:18;;:::i;:::-;1135:10;1131:2;1124:22;1170:2;1162:6;1155:18;1210:7;1205:2;1200;1196;1192:11;1188:20;1185:33;1182:53;;;1231:1;1228;1221:12;1182:53;1287:2;1282;1278;1274:11;1269:2;1261:6;1257:15;1244:46;1332:1;1310:15;;;1327:2;1306:24;1299:35;;;;-1:-1:-1;1314:6:1;385:980;-1:-1:-1;;;;;385:980:1:o;1370:481::-;1411:3;1449:5;1443:12;1476:6;1471:3;1464:19;1501:1;1511:162;1525:6;1522:1;1519:13;1511:162;;;1587:4;1643:13;;;1639:22;;1633:29;1615:11;;;1611:20;;1604:59;1540:12;1511:162;;;1515:3;1718:1;1711:4;1702:6;1697:3;1693:16;1689:27;1682:38;1840:4;1770:66;1765:2;1757:6;1753:15;1749:88;1744:3;1740:98;1736:109;1729:116;;;1370:481;;;;:::o;1856:217::-;2003:2;1992:9;1985:21;1966:4;2023:44;2063:2;2052:9;2048:18;2040:6;2023:44;:::i;2483:179::-;2550:20;;2610:26;2599:38;;2589:49;;2579:77;;2652:1;2649;2642:12;2579:77;2483:179;;;:::o;2667:401::-;2749:6;2757;2765;2773;2826:3;2814:9;2805:7;2801:23;2797:33;2794:53;;;2843:1;2840;2833:12;2794:53;2866:28;2884:9;2866:28;:::i;:::-;2856:38;;2913:37;2946:2;2935:9;2931:18;2913:37;:::i;:::-;2903:47;;2969:37;3002:2;2991:9;2987:18;2969:37;:::i;:::-;2959:47;;3025:37;3058:2;3047:9;3043:18;3025:37;:::i;:::-;3015:47;;2667:401;;;;;;;:::o;3073:184::-;3125:77;3122:1;3115:88;3222:4;3219:1;3212:15;3246:4;3243:1;3236:15;3262:188;3329:26;3375:10;;;3387;;;3371:27;;3410:11;;;3407:37;;;3424:18;;:::i;:::-;3407:37;3262:188;;;;:::o;5399:151::-;5489:4;5482:12;;;5468;;;5464:31;;5507:14;;5504:40;;;5524:18;;:::i;5555:225::-;5659:4;5638:12;;;5652;;;5634:31;5685:22;;;;5726:24;;;5716:58;;5754:18;;:::i;5785:125::-;5850:9;;;5871:10;;;5868:36;;;5884:18;;:::i;8008:184::-;8060:77;8057:1;8050:88;8157:4;8154:1;8147:15;8181:4;8178:1;8171:15","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"broadcasterTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"castToTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"emptyTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"executorTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint96","name":"notaryTip_","type":"uint96"},{"internalType":"uint96","name":"broadcasterTip_","type":"uint96"},{"internalType":"uint96","name":"proverTip_","type":"uint96"},{"internalType":"uint96","name":"executorTip_","type":"uint96"}],"name":"formatTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"isTips","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"notaryTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetBroadcaster","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetExecutor","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetNotary","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetProver","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"proverTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"tipsLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"totalTips","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"broadcasterTip(bytes)":{"notice":"Returns broadcasterTip field"},"executorTip(bytes)":{"notice":"Returns executorTip field"},"notaryTip(bytes)":{"notice":"Returns notaryTip field"},"proverTip(bytes)":{"notice":"Returns proverTip field"},"totalTips(bytes)":{"notice":"Returns total tip amount."}},"notice":"Exposes TipsLib methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"broadcasterTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"castToTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emptyTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"executorTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"notaryTip_\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"broadcasterTip_\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"proverTip_\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"executorTip_\",\"type\":\"uint96\"}],\"name\":\"formatTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"isTips\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"notaryTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetBroadcaster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetExecutor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetNotary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetProver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"proverTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tipsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"totalTips\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"broadcasterTip(bytes)\":{\"notice\":\"Returns broadcasterTip field\"},\"executorTip(bytes)\":{\"notice\":\"Returns executorTip field\"},\"notaryTip(bytes)\":{\"notice\":\"Returns notaryTip field\"},\"proverTip(bytes)\":{\"notice\":\"Returns proverTip field\"},\"totalTips(bytes)\":{\"notice\":\"Returns total tip amount.\"}},\"notice\":\"Exposes TipsLib methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"TipsHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xfaeeee1334bec6f167abf2d8c094dee010dfba27e1264f37641beca4bc13cf91\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://471e0d7c4132066e7f11171b87ab8359782b90b36683a3a544f099df4e6ed05d\",\"dweb:/ipfs/QmPckfEhGiL5eFaqYnjWbAtPj6RqDZZf4N3mRZH8DCEBVU\"]}},\"version\":1}"},"hashes":{"broadcasterTip(bytes)":"e6f9466e","castToTips(bytes)":"50190c31","emptyTips()":"725bd463","executorTip(bytes)":"f86f2bdb","formatTips(uint96,uint96,uint96,uint96)":"d024f867","isTips(bytes)":"993abc41","notaryTip(bytes)":"69529e58","offsetBroadcaster()":"15bb7d2b","offsetExecutor()":"51970c3f","offsetNotary()":"b4b4ccb2","offsetProver()":"98de8554","proverTip(bytes)":"5f491167","tipsLength()":"b440592e","totalTips(bytes)":"5c197a18"}},"solidity/TipsHarness.t.sol:TipsLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d87b52cf291e739806f821539343bd6e3d0e5e7bddf2f0f12e3f5407f372ee9f64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d87b52cf291e739806f821539343bd6e3d0e5e7bddf2f0f12e3f5407f372ee9f64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().notaryTip();\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().broadcasterTip();\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().proverTip();\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().executorTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().totalTips();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n\n    // ═════════════════════════════════════════════ CONSTANT GETTERS ══════════════════════════════════════════════════\n\n    function tipsLength() public pure returns (uint256) {\n        return TIPS_LENGTH;\n    }\n\n    function offsetNotary() public pure returns (uint256) {\n        return TipsLib.OFFSET_NOTARY;\n    }\n\n    function offsetBroadcaster() public pure returns (uint256) {\n        return TipsLib.OFFSET_BROADCASTER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return TipsLib.OFFSET_PROVER;\n    }\n\n    function offsetExecutor() public pure returns (uint256) {\n        return TipsLib.OFFSET_EXECUTOR;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"48659:4328:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;48659:4328:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"48659:4328:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_NOTARY":{"details":"Tips memory layout [000 .. 012): notaryTip          uint96\t12 bytes [012 .. 024): broadcasterTip     uint96\t12 bytes [024 .. 036): proverTip          uint96\t12 bytes [036 .. 048): executorTip        uint96\t12 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_NOTARY\":{\"details\":\"Tips memory layout [000 .. 012): notaryTip          uint96\\t12 bytes [012 .. 024): broadcasterTip     uint96\\t12 bytes [024 .. 036): proverTip          uint96\\t12 bytes [036 .. 048): executorTip        uint96\\t12 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for versioned formatting [the tips part] of [the messages used by Origin and Destination].\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"TipsLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xfaeeee1334bec6f167abf2d8c094dee010dfba27e1264f37641beca4bc13cf91\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://471e0d7c4132066e7f11171b87ab8359782b90b36683a3a544f099df4e6ed05d\",\"dweb:/ipfs/QmPckfEhGiL5eFaqYnjWbAtPj6RqDZZf4N3mRZH8DCEBVU\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea264697066735822122095026945a2567700fbc65c1e3bb5b0cf36083a1047d009b3ec0c7d6f932e892c64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea264697066735822122095026945a2567700fbc65c1e3bb5b0cf36083a1047d009b3ec0c7d6f932e892c64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * TODO (Chi): with the user defined types storing type is no longer necessary.\n     * Update the library, transforming bytes29 to bytes24 in the process.\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param byte_     The byte\n     * @return char     The encoded hex character\n     */\n    function nibbleHex(uint8 byte_) internal pure returns (uint8 char) {\n        uint8 nibble = byte_ \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        char = uint8(NIBBLE_LOOKUP[nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param b     The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param b     The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            first |= byteHex(byte_);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255;) {\n            uint8 byte_ = uint8(b \u003e\u003e (i * 8));\n            second |= byteHex(byte_);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param b         The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 b) internal pure returns (uint256 v) {\n        v = b;\n\n        // swap bytes\n        v = ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF)\n            | ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v = ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\n            | ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v = ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\n            | ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v = ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\n            | ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `len_` bits set.\n     * @param len_  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 len_) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(sub(len_, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 view_) internal pure returns (bool) {\n        return view_ == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 view_) internal pure returns (bool) {\n        return !isNull(view_);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param view_     The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 view_) internal pure returns (bool ret) {\n        if (typeOf(view_) == 0xffffffffff) {\n            return false;\n        }\n        uint256 end_ = end(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(end_, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 view_) internal pure returns (bytes29) {\n        require(isValid(view_), \"Validity assertion failed\");\n        return view_;\n    }\n\n    /**\n     * @notice          Return true if the view_ is of the expected type. Otherwise false.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bool - True if the view_ is of the expected type\n     */\n    function isType(bytes29 view_, uint40 expected) internal pure returns (bool) {\n        return typeOf(view_) == expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param view_     The view\n     * @param expected  The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 view_, uint40 expected) internal pure returns (bytes29) {\n        if (!isType(view_, expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(view_)));\n            (, uint256 e) = encodeHex(uint256(expected));\n            string memory err =\n                string(abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e)));\n            revert(err);\n        }\n        return view_;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param view_     The view\n     * @param newType   The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 view_, uint40 newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(bitsType, shl(bitsType, view_)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(shiftType, newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(uint256 type_, uint256 loc_, uint256 len_) private pure returns (bytes29 newView) {\n        uint256 bitsLoc = BITS_LOC;\n        uint256 bitsLen = BITS_LEN;\n        uint256 bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(bitsLoc, or(newView, type_))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(bitsLen, or(newView, loc_))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(bitsEmpty, or(newView, len_))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param type_     The type\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(uint256 type_, uint256 loc_, uint256 len_) internal pure returns (bytes29 newView) {\n        uint256 end_ = loc_ + len_;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(end_, mload(0x40)) { end_ := 0 }\n        }\n        if (end_ == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(type_, loc_, len_);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 len_ = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc_;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            loc_ := add(arr, 0x20)\n        }\n\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param view_     The memory view\n     * @return          type_ - The type associated with the view\n     */\n    function typeOf(bytes29 view_) internal pure returns (uint40 type_) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            type_ := shr(shiftType, view_)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param view_     The view\n     * @return          loc_ - The memory address\n     */\n    function loc(bytes29 view_) internal pure returns (uint96 loc_) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            loc_ := and(shr(shiftLoc, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param view_     The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 view_) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(view_)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param view_   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 view_) internal pure returns (uint256) {\n        return words(view_) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param view_     The view\n     * @return          len_ - The length of the view\n     */\n    function len(bytes29 view_) internal pure returns (uint96 len_) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            len_ := and(shr(shiftLen, view_), uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `view_`.\n     * @param view_   The view\n     * @return          uint256 - The endpoint of `view_`\n     */\n    function end(bytes29 view_) internal pure returns (uint256) {\n        unchecked {\n            return loc(view_) + len(view_);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param view_     The view\n     * @param index_    The start index\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(bytes29 view_, uint256 index_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        uint256 loc_ = loc(view_);\n\n        // Ensure it doesn't overrun the view\n        if (loc_ + index_ + len_ \u003e end(view_)) {\n            return NULL;\n        }\n\n        loc_ = loc_ + index_;\n        return build(newType, loc_, len_);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `index` to end(view_).\n     * @param view_     The view\n     * @param index_    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(bytes29 view_, uint256 index_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, index_, len(view_) - index_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `len` bytes.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, 0, len_, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `len` byte.\n     * @param view_     The view\n     * @param len_      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(bytes29 view_, uint256 len_, uint40 newType) internal pure returns (bytes29) {\n        return slice(view_, uint256(len(view_)) - len_, len_, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param loc_      The memory address\n     * @param len_      The length\n     * @param index_    The index\n     * @param slice_    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(uint256 loc_, uint256 len_, uint256 index_, uint256 slice_)\n        internal\n        pure\n        returns (string memory err)\n    {\n        (, uint256 a) = encodeHex(loc_);\n        (, uint256 b) = encodeHex(len_);\n        (, uint256 c) = encodeHex(index_);\n        (, uint256 d) = encodeHex(slice_);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `bytes_` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (bytes32 result) {\n        if (bytes_ == 0) {\n            return bytes32(0);\n        }\n        if (index_ + bytes_ \u003e len(view_)) {\n            revert(indexErrOverrun(loc(view_), len(view_), index_, uint256(bytes_)));\n        }\n        require(bytes_ \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = bytes_ * 8;\n        }\n        uint256 loc_ = loc(view_);\n        // Get a mask with `bitLength` highest bits set\n        uint256 mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(loc_, index_)), mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `index`.\n     * @dev             Requires that the view have \u003e= `bytes_` bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `bytes_`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(view_, index_, bytes_)) \u003e\u003e ((32 - bytes_) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param view_     The view\n     * @param index_    The index\n     * @param bytes_    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(bytes29 view_, uint256 index_, uint8 bytes_) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(view_, index_, bytes_)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param view_     The view\n     * @param index_    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 view_, uint256 index_) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(view_, index_, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param view_     The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 view_) internal pure returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(loc_, len_)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param view_     The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param view_     The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 view_) internal view returns (bytes20 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param view_     A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 view_) internal view returns (bytes32 digest) {\n        uint256 loc_ = loc(view_);\n        uint256 len_ = len(view_);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, loc_, len_, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param view_     The view\n     * @param newLoc    The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 view_, uint256 newLoc) private view returns (bytes29 written) {\n        require(notNull(view_), \"copyTo: Null pointer deref\");\n        require(isValid(view_), \"copyTo: Invalid pointer deref\");\n        uint256 len_ = len(view_);\n        uint256 oldLoc = loc(view_);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, newLoc) { revert(0x60, 0x20) } // empty revert message\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, oldLoc, len_, newLoc, len_)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(view_), newLoc, len_);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param view_     The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 view_) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 len_ = len(view_);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(view_, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, len_), 0x20)) // write new unused pointer\n            mstore(ptr, len_) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 location) private view returns (bytes29 unsafeView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, location) { revert(0x60, 0x20) } // empty revert message\n        }\n\n        uint256 offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 view_ = memViews[i];\n            unchecked {\n                unsafeCopyTo(view_, location + offset);\n                offset += len(view_);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, location, offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 newView;\n        unchecked {\n            newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 written = len(newView);\n        uint256 footprint_ = footprint(newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, footprint_), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/// @dev CallData is a memory view over the payload to be used for an external call, i.e.\n/// recipient.call(callData). Its length is always (4 + 32 * N) bytes:\n/// - First 4 bytes represent the function selector.\n/// - 32 * N bytes represent N words that function arguments occupy.\ntype CallData is bytes29;\n\n/// @dev Attach library functions to CallData\nusing ByteString for CallData global;\n\n/// @dev Signature is a memory view over a \"65 bytes\" array representing a ECDSA signature.\ntype Signature is bytes29;\n\n/// @dev Attach library functions to Signature\nusing ByteString for Signature global;\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Calldata memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /**\n     * @notice Returns a memory view over the given payload, treating it as raw bytes.\n     * @dev Shortcut for .ref(0) - to be deprecated once \"uint40 type\" is removed from bytes29.\n     */\n    function castToRawBytes(bytes memory payload) internal pure returns (bytes29) {\n        return payload.ref({newType: 0});\n    }\n\n    // ═════════════════════════════════════════════════ SIGNATURE ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(bytes32 r, bytes32 s, uint8 v) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a Signature view over for the given payload.\n     * @dev Will revert if the payload is not a signature.\n     */\n    function castToSignature(bytes memory payload) internal pure returns (Signature) {\n        return castToSignature(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a Signature view.\n     * @dev Will revert if the memory view is not over a signature.\n     */\n    function castToSignature(bytes29 view_) internal pure returns (Signature) {\n        require(isSignature(view_), \"Not a signature\");\n        return Signature.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == SIGNATURE_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Signature signature) internal pure returns (bytes29) {\n        return Signature.unwrap(signature);\n    }\n\n    // ═════════════════════════════════════════════ SIGNATURE SLICING ═════════════════════════════════════════════════\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(Signature signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(signature);\n        r = view_.index({index_: OFFSET_R, bytes_: 32});\n        s = view_.index({index_: OFFSET_S, bytes_: 32});\n        v = uint8(view_.indexUint({index_: OFFSET_V, bytes_: 1}));\n    }\n\n    // ═════════════════════════════════════════════════ CALLDATA ══════════════════════════════════════════════════════\n\n    /**\n     * @notice Constructs the calldata with the modified arguments:\n     * the existing arguments are prepended with the arguments from the prefix.\n     * @dev Given:\n     *  - `calldata = abi.encodeWithSelector(foo.selector, d, e);`\n     *  - `prefix = abi.encode(a, b, c);`\n     *  - `a`, `b`, `c` are arguments of static type (i.e. not dynamically sized ones)\n     *      Then:\n     *  - Function will return abi.encodeWithSelector(foo.selector, a, c, c, d, e)\n     *  - Returned calldata will trigger `foo(a, b, c, d, e)` when used for a contract call.\n     * Note: for clarification as to what types are considered static, see\n     * https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding\n     * @param callData  Calldata that needs to be modified\n     * @param prefix    ABI-encoded arguments to use as the first arguments in the new calldata\n     * @return Modified calldata having prefix as the first arguments.\n     */\n    function addPrefix(CallData callData, bytes memory prefix) internal view returns (bytes memory) {\n        // Prefix should occupy a whole amount of words in memory\n        require(_fullWords(prefix.length), \"Incorrect prefix\");\n        bytes29[] memory views = new bytes29[](3);\n        // Use payload's function selector\n        views[0] = callData.callSelector();\n        // Use prefix as the first arguments\n        views[1] = castToRawBytes(prefix);\n        // Use payload's remaining arguments\n        views[2] = callData.arguments();\n        return TypedMemView.join(views);\n    }\n\n    /**\n     * @notice Returns a CallData view over for the given payload.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes memory payload) internal pure returns (CallData) {\n        return castToCallData(castToRawBytes(payload));\n    }\n\n    /**\n     * @notice Casts a memory view to a CallData view.\n     * @dev Will revert if the memory view is not over a calldata.\n     */\n    function castToCallData(bytes29 view_) internal pure returns (CallData) {\n        require(isCallData(view_), \"Not a calldata\");\n        return CallData.wrap(view_);\n    }\n\n    /**\n     * @notice Checks that a byte string is a valid calldata, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallData(bytes29 view_) internal pure returns (bool) {\n        uint256 length = view_.len();\n        // Calldata should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the calldata should be exactly N memory words (N \u003e= 0)\n        return _fullWords(length - SELECTOR_LENGTH);\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(CallData callData) internal pure returns (bytes29) {\n        return CallData.unwrap(callData);\n    }\n\n    // ═════════════════════════════════════════════ CALLDATA SLICING ══════════════════════════════════════════════════\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the calldata.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(CallData callData) internal pure returns (uint256) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (view_.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided calldata.\n    function callSelector(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.slice({index_: OFFSET_SELECTOR, len_: SELECTOR_LENGTH, newType: 0});\n    }\n\n    /// @notice Returns abi encoded arguments for the provided calldata.\n    function arguments(CallData callData) internal pure returns (bytes29) {\n        // Get the underlying memory view\n        bytes29 view_ = unwrap(callData);\n        return view_.sliceFrom({index_: OFFSET_ARGUMENTS, newType: 0});\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    /// @dev Checks if length is full amount of memory words (32 bytes).\n    function _fullWords(uint256 length) internal pure returns (bool) {\n        // The equivalent of length % 32 == 0\n        return length \u0026 31 == 0;\n    }\n}\n\n// Here we define common constants to enable their easier reusing later.\n\n// ══════════════════════════════════ MERKLE ═══════════════════════════════════\n/// @dev Height of the Agent Merkle Tree\nuint256 constant AGENT_TREE_HEIGHT = 32;\n/// @dev Height of the Origin Merkle Tree\nuint256 constant ORIGIN_TREE_HEIGHT = 32;\n/// @dev Height of the Snapshot Merkle Tree. Allows up to 64 leafs, e.g. up to 32 states\nuint256 constant SNAPSHOT_TREE_HEIGHT = 6;\n// ══════════════════════════════════ STRUCTS ══════════════════════════════════\n/// @dev See Attestation.sol: (bytes32,bytes32, uint32,uint40,uint40): 32+4+5+5\nuint256 constant ATTESTATION_LENGTH = 78;\n/// @dev See State.sol: (bytes32,uint32,uint32,uint40,uint40): 32+4+4+5+5\nuint256 constant STATE_LENGTH = 50;\n/// @dev Maximum amount of states in a single snapshot. Each state produces two leafs in the tree\nuint256 constant SNAPSHOT_MAX_STATES = 1 \u003c\u003c (SNAPSHOT_TREE_HEIGHT - 1);\n// ══════════════════════════════════ MESSAGE ══════════════════════════════════\n/// @dev See Header.sol: (uint32,uint32,uint32,uint32): 4+4+4+4\nuint256 constant HEADER_LENGTH = 16;\n/// @dev See Request.sol: (uint64): 8\nuint256 constant REQUEST_LENGTH = 8;\n/// @dev See Tips.sol: (uint96,uint96,uint96,uint96): 12+12+12+12\nuint256 constant TIPS_LENGTH = 48;\n// ══════════════════════════════ STATEMENT SALTS ══════════════════════════════\n/// @dev Salts for signing various statements\nbytes32 constant ATTESTATION_SALT = keccak256(\"ATTESTATION_SALT\");\nbytes32 constant ATTESTATION_REPORT_SALT = keccak256(\"ATTESTATION_REPORT_SALT\");\nbytes32 constant SNAPSHOT_SALT = keccak256(\"SNAPSHOT_SALT\");\nbytes32 constant STATE_REPORT_SALT = keccak256(\"STATE_REPORT_SALT\");\n// ════════════════════════════════ DESTINATION ════════════════════════════════\nuint256 constant AGENT_ROOT_OPTIMISTIC_PERIOD = 1 days;\n// ══════════════════════════════════ ORIGIN ═══════════════════════════════════\n/// @dev Maximum bytes per message = 2 KiB (somewhat arbitrarily set to begin)\nuint256 constant MAX_CONTENT_BYTES = 2 * 2 ** 10;\n// ═══════════════════════════════ SYSTEM ROUTER ═══════════════════════════════\n/// @dev Custom address used for sending and receiving system messages.\n/// - Origin will dispatch messages from SystemRouter as if they were \"sent by this sender\".\n/// - Destination will reroute messages \"sent to this recipient\" to SystemRouter.\n/// - As a result: only SystemRouter messages will have this value as both sender and recipient.\n/// Note: all bits except for lower 20 bytes are set to 1.\n/// Note: TypeCasts.bytes32ToAddress(SYSTEM_ROUTER) == address(0)\nbytes32 constant SYSTEM_ROUTER = bytes32(type(uint256).max \u003c\u003c 160);\n\n/// @dev Tips is a memory over over a formatted message tips payload.\ntype Tips is bytes29;\n\n/// @dev Attach library functions to Tips\nusing {\n    TipsLib.unwrap,\n    TipsLib.notaryTip,\n    TipsLib.broadcasterTip,\n    TipsLib.proverTip,\n    TipsLib.executorTip,\n    TipsLib.totalTips\n} for Tips global;\n\n/**\n * @notice Library for versioned formatting [the tips part]\n * of [the messages used by Origin and Destination].\n */\nlibrary TipsLib {\n    using ByteString for bytes;\n    using TypedMemView for bytes29;\n\n    // TODO: determine if we need to pack the tips values,\n    // or if using uint256 instead will suffice.\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 012): notaryTip          uint96\t12 bytes\n     * [012 .. 024): broadcasterTip     uint96\t12 bytes\n     * [024 .. 036): proverTip          uint96\t12 bytes\n     * [036 .. 048): executorTip        uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_NOTARY = 0;\n    uint256 internal constant OFFSET_BROADCASTER = 12;\n    uint256 internal constant OFFSET_PROVER = 24;\n    uint256 internal constant OFFSET_EXECUTOR = 36;\n\n    // ═══════════════════════════════════════════════════ TIPS ════════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns a formatted Tips payload with provided fields\n     * @param notaryTip_        Tip for the Notary\n     * @param broadcasterTip_   Tip for the Broadcaster\n     * @param proverTip_        Tip for the Prover\n     * @param executorTip_      Tip for the Executor\n     * @return Formatted tips\n     */\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    /**\n     * @notice Returns a formatted Tips payload specifying empty tips.\n     * @return Formatted tips\n     */\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /**\n     * @notice Returns a Tips view over for the given payload.\n     * @dev Will revert if the payload is not a tips payload.\n     */\n    function castToTips(bytes memory payload) internal pure returns (Tips) {\n        return castToTips(payload.castToRawBytes());\n    }\n\n    /**\n     * @notice Casts a memory view to a Tips view.\n     * @dev Will revert if the memory view is not over a tips payload.\n     */\n    function castToTips(bytes29 view_) internal pure returns (Tips) {\n        require(isTips(view_), \"Not a tips payload\");\n        return Tips.wrap(view_);\n    }\n\n    /// @notice Checks that a payload is a formatted Tips payload.\n    function isTips(bytes29 view_) internal pure returns (bool) {\n        return view_.len() == TIPS_LENGTH;\n    }\n\n    /// @notice Convenience shortcut for unwrapping a view.\n    function unwrap(Tips tips) internal pure returns (bytes29) {\n        return Tips.unwrap(tips);\n    }\n\n    // ═══════════════════════════════════════════════ TIPS SLICING ════════════════════════════════════════════════════\n\n    /// @notice Returns notaryTip field\n    function notaryTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_NOTARY, 12));\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_BROADCASTER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(Tips tips) internal pure returns (uint96) {\n        bytes29 view_ = tips.unwrap();\n        return uint96(view_.indexUint(OFFSET_EXECUTOR, 12));\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(Tips tips) internal pure returns (uint96) {\n        // In practice there's no chance that the total tips value would not fit into uint96.\n        // TODO: determine if we want to use uint256 here instead anyway.\n        return notaryTip(tips) + broadcasterTip(tips) + proverTip(tips) + executorTip(tips);\n    }\n}\n\n/**\n * @notice Exposes TipsLib methods for testing against golang.\n */\ncontract TipsHarness {\n    using TipsLib for bytes;\n    using TipsLib for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Note: we don't add an empty test() function here, as it currently leads\n    // to zero coverage on the corresponding library.\n\n    // ══════════════════════════════════════════════════ GETTERS ══════════════════════════════════════════════════════\n\n    function castToTips(bytes memory payload) public view returns (bytes memory) {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        Tips tips = TipsLib.castToTips(payload);\n        return tips.unwrap().clone();\n    }\n\n    /// @notice Returns notaryTip field\n    function notaryTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().notaryTip();\n    }\n\n    /// @notice Returns broadcasterTip field\n    function broadcasterTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().broadcasterTip();\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().proverTip();\n    }\n\n    /// @notice Returns executorTip field\n    function executorTip(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().executorTip();\n    }\n\n    /// @notice Returns total tip amount.\n    function totalTips(bytes memory payload) public pure returns (uint96) {\n        return payload.castToTips().totalTips();\n    }\n\n    function isTips(bytes memory payload) public pure returns (bool) {\n        return payload.ref(0).isTips();\n    }\n\n    // ════════════════════════════════════════════════ FORMATTERS ═════════════════════════════════════════════════════\n\n    function formatTips(uint96 notaryTip_, uint96 broadcasterTip_, uint96 proverTip_, uint96 executorTip_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return TipsLib.formatTips(notaryTip_, broadcasterTip_, proverTip_, executorTip_);\n    }\n\n    function emptyTips() public pure returns (bytes memory) {\n        return TipsLib.emptyTips();\n    }\n\n    // ═════════════════════════════════════════════ CONSTANT GETTERS ══════════════════════════════════════════════════\n\n    function tipsLength() public pure returns (uint256) {\n        return TIPS_LENGTH;\n    }\n\n    function offsetNotary() public pure returns (uint256) {\n        return TipsLib.OFFSET_NOTARY;\n    }\n\n    function offsetBroadcaster() public pure returns (uint256) {\n        return TipsLib.OFFSET_BROADCASTER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return TipsLib.OFFSET_PROVER;\n    }\n\n    function offsetExecutor() public pure returns (uint256) {\n        return TipsLib.OFFSET_EXECUTOR;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"57:34812:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;57:34812:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"57:34812:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3142:38;;3178:2;3142:38;;;;;168:25:1;;;156:2;141:18;3142:38:0;;;;;;;;3399:46;;3309:2;3399:46;;3536:57;;;:::i;3457:56::-;;;:::i;3659:59::-;;3702:16;3659:59;;3229:37;;3264:2;3229:37;;2571:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2571:94:0;204:258:1;3536:57:0;3221:2;3493:20;3221:2;3309;3493:20;:::i;:::-;3573;;;;:::i;:::-;3536:57;:::o;3457:56::-;3493:20;3264:2;3309;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 TODO (Chi): with the user defined types storing type is no longer necessary. Update the library, transforming bytes29 to bytes24 in the process. [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 TODO (Chi): with the user defined types storing type is no longer necessary. Update the library, transforming bytes29 to bytes24 in the process. [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.t.sol\":{\"keccak256\":\"0xfaeeee1334bec6f167abf2d8c094dee010dfba27e1264f37641beca4bc13cf91\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://471e0d7c4132066e7f11171b87ab8359782b90b36683a3a544f099df4e6ed05d\",\"dweb:/ipfs/QmPckfEhGiL5eFaqYnjWbAtPj6RqDZZf4N3mRZH8DCEBVU\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}