{"solidity/TestClient.sol:IMessageRecipient":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract TestClient is IMessageRecipient {\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    event MessageReceived(uint32 origin, uint32 nonce, bytes32 sender, uint256 proofMaturity, bytes content);\n\n    event MessageSent(uint32 destination, uint32 nonce, bytes32 sender, bytes32 recipient, bytes content);\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n    }\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(\n        uint32 origin_,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable {\n        require(msg.sender == destination, \"TestClient: !destination\");\n        emit MessageReceived(origin_, nonce, sender, proofMaturity, content);\n    }\n\n    function sendMessage(uint32 destination_, address recipientAddress, uint32 optimisticSeconds, bytes memory content)\n        external\n    {\n        bytes32 recipient = TypeCasts.addressToBytes32(recipientAddress);\n        // TODO: figure out the logic for a message test\n        Request request = RequestLib.encodeRequest(0, 0);\n        (uint32 nonce,) = InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticSeconds, Request.unwrap(request), content\n        );\n        emit MessageSent(destination_, nonce, TypeCasts.addressToBytes32(address(this)), recipient, content);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"origin","type":"uint32"},{"internalType":"uint32","name":"nonce","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"proofMaturity","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"receiveBaseMessage","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"notice":"Message recipient needs to implement this function in order to receive cross-chain messages."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"details":"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \"message optimistic period\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.","params":{"content":"Raw bytes content of message","nonce":"Message nonce on the origin domain","origin":"Domain where message originated","proofMaturity":"Message's merkle proof age in seconds","sender":"Sender address on origin chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"proofMaturity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"receiveBaseMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"details\":\"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \\\"message optimistic period\\\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.\",\"params\":{\"content\":\"Raw bytes content of message\",\"nonce\":\"Message nonce on the origin domain\",\"origin\":\"Domain where message originated\",\"proofMaturity\":\"Message's merkle proof age in seconds\",\"sender\":\"Sender address on origin chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"notice\":\"Message recipient needs to implement this function in order to receive cross-chain messages.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TestClient.sol\":\"IMessageRecipient\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TestClient.sol\":{\"keccak256\":\"0x2662ccc7afc57eb5dc92068e12ca6e1d45e19dd0ce7edb810144a1e82d890018\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ddc7fff7e270b547c6831d476764c244c9750fae6b3938794bd313578368978b\",\"dweb:/ipfs/QmQaRsj5vQHEqQDGLVjkX3uv6bRVupSt2Jb1B3WMeBTdpY\"]}},\"version\":1}"},"hashes":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":"8d3ea9e7"}},"solidity/TestClient.sol:InterfaceOrigin":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract TestClient is IMessageRecipient {\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    event MessageReceived(uint32 origin, uint32 nonce, bytes32 sender, uint256 proofMaturity, bytes content);\n\n    event MessageSent(uint32 destination, uint32 nonce, bytes32 sender, bytes32 recipient, bytes content);\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n    }\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(\n        uint32 origin_,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable {\n        require(msg.sender == destination, \"TestClient: !destination\");\n        emit MessageReceived(origin_, nonce, sender, proofMaturity, content);\n    }\n\n    function sendMessage(uint32 destination_, address recipientAddress, uint32 optimisticSeconds, bytes memory content)\n        external\n    {\n        bytes32 recipient = TypeCasts.addressToBytes32(recipientAddress);\n        // TODO: figure out the logic for a message test\n        Request request = RequestLib.encodeRequest(0, 0);\n        (uint32 nonce,) = InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticSeconds, Request.unwrap(request), content\n        );\n        emit MessageSent(destination_, nonce, TypeCasts.addressToBytes32(address(this)), recipient, content);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"uint256","name":"paddedRequest","type":"uint256"},{"internalType":"uint256","name":"contentLength","type":"uint256"}],"name":"getMinimumTipsValue","outputs":[{"internalType":"uint256","name":"tipsValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"uint32","name":"optimisticPeriod","type":"uint32"},{"internalType":"uint256","name":"paddedRequest","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"sendBaseMessage","outputs":[{"internalType":"uint32","name":"messageNonce","type":"uint32"},{"internalType":"bytes32","name":"messageHash","type":"bytes32"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination","type":"uint32"},{"internalType":"uint32","name":"optimisticPeriod","type":"uint32"},{"internalType":"bytes","name":"payload","type":"bytes"}],"name":"sendManagerMessage","outputs":[{"internalType":"uint32","name":"messageNonce","type":"uint32"},{"internalType":"bytes32","name":"messageHash","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawTips","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"getMinimumTipsValue(uint32,uint256,uint256)":{"notice":"Returns the minimum tips value for sending a message to a given destination."},"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)":{"notice":"Send a message to the recipient located on destination domain."},"sendManagerMessage(uint32,uint32,bytes)":{"notice":"Send a manager message to the destination domain."},"withdrawTips(address,uint256)":{"notice":"Withdraws locked base message tips to the recipient."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getMinimumTipsValue(uint32,uint256,uint256)":{"details":"Using at least `tipsValue` as `msg.value` for `sendBaseMessage()` will guarantee that the message will be accepted.","params":{"contentLength":"The length of the message content","destination":"Domain of destination chain","paddedRequest":"Padded encoded message execution request on destination chain"},"returns":{"tipsValue":"       Minimum tips value for a message to be accepted"}},"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)":{"details":"Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.","params":{"content":"Raw bytes content of message","destination":"Domain of destination chain","optimisticPeriod":"Optimistic period for message execution on destination chain","paddedRequest":"Padded encoded message execution request on destination chain","recipient":"Address of recipient on destination chain as bytes32"},"returns":{"messageHash":"         Hash of the sent message","messageNonce":"        Nonce of the sent message"}},"sendManagerMessage(uint32,uint32,bytes)":{"details":"This could only be called by AgentManager, which takes care of encoding the calldata payload. Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain so that the AgentManager could verify where the Manager Message came from and how mature is the proof. Note: function is not payable, as no tips are required for sending a manager message.","params":{"destination":"Domain of destination chain","optimisticPeriod":"Optimistic period for message execution on destination chain","payload":"Payload for calling AgentManager on destination chain (with extra security args)"}},"withdrawTips(address,uint256)":{"details":"Could only be called by a local AgentManager.","params":{"amount":"Tips value to withdraw","recipient":"Address to withdraw tips to"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"paddedRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contentLength\",\"type\":\"uint256\"}],\"name\":\"getMinimumTipsValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tipsValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"paddedRequest\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"sendBaseMessage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"messageNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"optimisticPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sendManagerMessage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"messageNonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getMinimumTipsValue(uint32,uint256,uint256)\":{\"details\":\"Using at least `tipsValue` as `msg.value` for `sendBaseMessage()` will guarantee that the message will be accepted.\",\"params\":{\"contentLength\":\"The length of the message content\",\"destination\":\"Domain of destination chain\",\"paddedRequest\":\"Padded encoded message execution request on destination chain\"},\"returns\":{\"tipsValue\":\"       Minimum tips value for a message to be accepted\"}},\"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)\":{\"details\":\"Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\",\"params\":{\"content\":\"Raw bytes content of message\",\"destination\":\"Domain of destination chain\",\"optimisticPeriod\":\"Optimistic period for message execution on destination chain\",\"paddedRequest\":\"Padded encoded message execution request on destination chain\",\"recipient\":\"Address of recipient on destination chain as bytes32\"},\"returns\":{\"messageHash\":\"         Hash of the sent message\",\"messageNonce\":\"        Nonce of the sent message\"}},\"sendManagerMessage(uint32,uint32,bytes)\":{\"details\":\"This could only be called by AgentManager, which takes care of encoding the calldata payload. Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain so that the AgentManager could verify where the Manager Message came from and how mature is the proof. Note: function is not payable, as no tips are required for sending a manager message.\",\"params\":{\"destination\":\"Domain of destination chain\",\"optimisticPeriod\":\"Optimistic period for message execution on destination chain\",\"payload\":\"Payload for calling AgentManager on destination chain (with extra security args)\"}},\"withdrawTips(address,uint256)\":{\"details\":\"Could only be called by a local AgentManager.\",\"params\":{\"amount\":\"Tips value to withdraw\",\"recipient\":\"Address to withdraw tips to\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getMinimumTipsValue(uint32,uint256,uint256)\":{\"notice\":\"Returns the minimum tips value for sending a message to a given destination.\"},\"sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)\":{\"notice\":\"Send a message to the recipient located on destination domain.\"},\"sendManagerMessage(uint32,uint32,bytes)\":{\"notice\":\"Send a manager message to the destination domain.\"},\"withdrawTips(address,uint256)\":{\"notice\":\"Withdraws locked base message tips to the recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TestClient.sol\":\"InterfaceOrigin\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TestClient.sol\":{\"keccak256\":\"0x2662ccc7afc57eb5dc92068e12ca6e1d45e19dd0ce7edb810144a1e82d890018\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ddc7fff7e270b547c6831d476764c244c9750fae6b3938794bd313578368978b\",\"dweb:/ipfs/QmQaRsj5vQHEqQDGLVjkX3uv6bRVupSt2Jb1B3WMeBTdpY\"]}},\"version\":1}"},"hashes":{"getMinimumTipsValue(uint32,uint256,uint256)":"4fc6ad85","sendBaseMessage(uint32,bytes32,uint32,uint256,bytes)":"873661bd","sendManagerMessage(uint32,uint32,bytes)":"a1c702a7","withdrawTips(address,uint256)":"4e04e7a7"}},"solidity/TestClient.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a58c20a57880ba4740e94611d7ed619840953bdd53ad4bad33d79c50f5b61d6864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a58c20a57880ba4740e94611d7ed619840953bdd53ad4bad33d79c50f5b61d6864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract TestClient is IMessageRecipient {\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    event MessageReceived(uint32 origin, uint32 nonce, bytes32 sender, uint256 proofMaturity, bytes content);\n\n    event MessageSent(uint32 destination, uint32 nonce, bytes32 sender, bytes32 recipient, bytes content);\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n    }\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(\n        uint32 origin_,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable {\n        require(msg.sender == destination, \"TestClient: !destination\");\n        emit MessageReceived(origin_, nonce, sender, proofMaturity, content);\n    }\n\n    function sendMessage(uint32 destination_, address recipientAddress, uint32 optimisticSeconds, bytes memory content)\n        external\n    {\n        bytes32 recipient = TypeCasts.addressToBytes32(recipientAddress);\n        // TODO: figure out the logic for a message test\n        Request request = RequestLib.encodeRequest(0, 0);\n        (uint32 nonce,) = InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticSeconds, Request.unwrap(request), content\n        );\n        emit MessageSent(destination_, nonce, TypeCasts.addressToBytes32(address(this)), recipient, content);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"1232:1772:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1232:1772:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1232:1772:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |","version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SHIFT_GAS_DROP":{"details":"Amount of bits to shift to gasDrop field"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SHIFT_GAS_DROP\":{\"details\":\"Amount of bits to shift to gasDrop field\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for formatting _the request part_ of _the base messages_. - Request represents a message sender requirements for the message execution on the destination chain. - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory. \u003e gasDrop field is included for future compatibility and is ignored at the moment. # Request stack layout (from highest bits to lowest) | Position   | Field    | Type   | Bytes | Description                                          | | ---------- | -------- | ------ | ----- | ---------------------------------------------------- | | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient | | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TestClient.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TestClient.sol\":{\"keccak256\":\"0x2662ccc7afc57eb5dc92068e12ca6e1d45e19dd0ce7edb810144a1e82d890018\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ddc7fff7e270b547c6831d476764c244c9750fae6b3938794bd313578368978b\",\"dweb:/ipfs/QmQaRsj5vQHEqQDGLVjkX3uv6bRVupSt2Jb1B3WMeBTdpY\"]}},\"version\":1}"},"hashes":{}},"solidity/TestClient.sol:TestClient":{"code":"0x60c060405234801561001057600080fd5b5060405161070738038061070783398101604081905261002f91610062565b6001600160a01b039182166080521660a052610095565b80516001600160a01b038116811461005d57600080fd5b919050565b6000806040838503121561007557600080fd5b61007e83610046565b915061008c60208401610046565b90509250929050565b60805160a0516106416100c66000396000818160e8015261022a015260008181608b015261012601526106416000f3fe60806040526004361061003f5760003560e01c80631d0a1d47146100445780638d3ea9e714610066578063938b5f3214610079578063b269681d146100d6575b600080fd5b34801561005057600080fd5b5061006461005f3660046103ea565b61010a565b005b610064610074366004610478565b610212565b34801561008557600080fd5b506100ad7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b3480156100e257600080fd5b506100ad7f000000000000000000000000000000000000000000000000000000000000000081565b73ffffffffffffffffffffffffffffffffffffffff83166000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663873661bd88858886896040518663ffffffff1660e01b8152600401610185959493929190610552565b60408051808303816000875af11580156101a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101c791906105a8565b5090507ff17c656698e3361e14b0a2402b83112a3d8ffcc011ce6bae5e8368685d14327687823086886040516102019594939291906105d6565b60405180910390a150505050505050565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146102b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f54657374436c69656e743a202164657374696e6174696f6e0000000000000000604482015260640160405180910390fd5b7ff69cea362bb12e70e5e44dd4c00e85e1ac2efa32715ae0ee130b209393b1509085858585856040516102ec9594939291906105d6565b60405180910390a15050505050565b63ffffffff8116811461030d57600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261035057600080fd5b813567ffffffffffffffff8082111561036b5761036b610310565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156103b1576103b1610310565b816040528381528660208588010111156103ca57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806000806080858703121561040057600080fd5b843561040b816102fb565b9350602085013573ffffffffffffffffffffffffffffffffffffffff8116811461043457600080fd5b92506040850135610444816102fb565b9150606085013567ffffffffffffffff81111561046057600080fd5b61046c8782880161033f565b91505092959194509250565b600080600080600060a0868803121561049057600080fd5b853561049b816102fb565b945060208601356104ab816102fb565b93506040860135925060608601359150608086013567ffffffffffffffff8111156104d557600080fd5b6104e18882890161033f565b9150509295509295909350565b6000815180845260005b81811015610514576020818501810151868301820152016104f8565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600063ffffffff808816835286602084015280861660408401525073ffffffffffffffffffffffffffffffffffffffff8416606083015260a0608083015261059d60a08301846104ee565b979650505050505050565b600080604083850312156105bb57600080fd5b82516105c6816102fb565b6020939093015192949293505050565b600063ffffffff808816835280871660208401525084604083015283606083015260a0608083015261059d60a08301846104ee56fea26469706673582212204e4f3db791f4bbb0c672255d280ab21ce00bee5dd6cd4fabcee08dc040d993f564736f6c63430008110033","runtime-code":"0x60806040526004361061003f5760003560e01c80631d0a1d47146100445780638d3ea9e714610066578063938b5f3214610079578063b269681d146100d6575b600080fd5b34801561005057600080fd5b5061006461005f3660046103ea565b61010a565b005b610064610074366004610478565b610212565b34801561008557600080fd5b506100ad7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b3480156100e257600080fd5b506100ad7f000000000000000000000000000000000000000000000000000000000000000081565b73ffffffffffffffffffffffffffffffffffffffff83166000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663873661bd88858886896040518663ffffffff1660e01b8152600401610185959493929190610552565b60408051808303816000875af11580156101a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101c791906105a8565b5090507ff17c656698e3361e14b0a2402b83112a3d8ffcc011ce6bae5e8368685d14327687823086886040516102019594939291906105d6565b60405180910390a150505050505050565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146102b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f54657374436c69656e743a202164657374696e6174696f6e0000000000000000604482015260640160405180910390fd5b7ff69cea362bb12e70e5e44dd4c00e85e1ac2efa32715ae0ee130b209393b1509085858585856040516102ec9594939291906105d6565b60405180910390a15050505050565b63ffffffff8116811461030d57600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f83011261035057600080fd5b813567ffffffffffffffff8082111561036b5761036b610310565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156103b1576103b1610310565b816040528381528660208588010111156103ca57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806000806080858703121561040057600080fd5b843561040b816102fb565b9350602085013573ffffffffffffffffffffffffffffffffffffffff8116811461043457600080fd5b92506040850135610444816102fb565b9150606085013567ffffffffffffffff81111561046057600080fd5b61046c8782880161033f565b91505092959194509250565b600080600080600060a0868803121561049057600080fd5b853561049b816102fb565b945060208601356104ab816102fb565b93506040860135925060608601359150608086013567ffffffffffffffff8111156104d557600080fd5b6104e18882890161033f565b9150509295509295909350565b6000815180845260005b81811015610514576020818501810151868301820152016104f8565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600063ffffffff808816835286602084015280861660408401525073ffffffffffffffffffffffffffffffffffffffff8416606083015260a0608083015261059d60a08301846104ee565b979650505050505050565b600080604083850312156105bb57600080fd5b82516105c6816102fb565b6020939093015192949293505050565b600063ffffffff808816835280871660208401525084604083015283606083015260a0608083015261059d60a08301846104ee56fea26469706673582212204e4f3db791f4bbb0c672255d280ab21ce00bee5dd6cd4fabcee08dc040d993f564736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract TestClient is IMessageRecipient {\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    event MessageReceived(uint32 origin, uint32 nonce, bytes32 sender, uint256 proofMaturity, bytes content);\n\n    event MessageSent(uint32 destination, uint32 nonce, bytes32 sender, bytes32 recipient, bytes content);\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n    }\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(\n        uint32 origin_,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable {\n        require(msg.sender == destination, \"TestClient: !destination\");\n        emit MessageReceived(origin_, nonce, sender, proofMaturity, content);\n    }\n\n    function sendMessage(uint32 destination_, address recipientAddress, uint32 optimisticSeconds, bytes memory content)\n        external\n    {\n        bytes32 recipient = TypeCasts.addressToBytes32(recipientAddress);\n        // TODO: figure out the logic for a message test\n        Request request = RequestLib.encodeRequest(0, 0);\n        (uint32 nonce,) = InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticSeconds, Request.unwrap(request), content\n        );\n        emit MessageSent(destination_, nonce, TypeCasts.addressToBytes32(address(this)), recipient, content);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"8602:1599:0:-:0;;;9080:120;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;9141:16:0;;;;;9167:26;;;8602:1599;;14:177:1;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;:::-;8602:1599:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"8602:1599:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;9589:610;;;;;;;;;;-1:-1:-1;9589:610:0;;;;;:::i;:::-;;:::i;:::-;;9244:339;;;;;;:::i;:::-;;:::i;8711:31::-;;;;;;;;;;;;;;;;;;2825:42:1;2813:55;;;2795:74;;2783:2;2768:18;8711:31:0;;;;;;;8818:36;;;;;;;;;;;;;;;9589:610;3160:22;;;9736:17;9926:12;9959:6;9943:39;;;9996:12;10010:9;10021:17;10055:7;10065;9943:139;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;9925:157:0;-1:-1:-1;10097:95:0;10109:12;9925:157;10165:4;10173:9;10184:7;10097:95;;;;;;;;;;:::i;:::-;;;;;;;;9726:473;;;9589:610;;;;:::o;9244:339::-;9444:10;:25;9458:11;9444:25;;9436:62;;;;;;;5036:2:1;9436:62:0;;;5018:21:1;5075:2;5055:18;;;5048:30;5114:26;5094:18;;;5087:54;5158:18;;9436:62:0;;;;;;;;9513:63;9529:7;9538:5;9545:6;9553:13;9568:7;9513:63;;;;;;;;;;:::i;:::-;;;;;;;;9244:339;;;;;:::o;14:121:1:-;99:10;92:5;88:22;81:5;78:33;68:61;;125:1;122;115:12;68:61;14:121;:::o;140:184::-;192:77;189:1;182:88;289:4;286:1;279:15;313:4;310:1;303:15;329:777;371:5;424:3;417:4;409:6;405:17;401:27;391:55;;442:1;439;432:12;391:55;478:6;465:20;504:18;541:2;537;534:10;531:36;;;547:18;;:::i;:::-;681:2;675:9;743:4;735:13;;586:66;731:22;;;755:2;727:31;723:40;711:53;;;779:18;;;799:22;;;776:46;773:72;;;825:18;;:::i;:::-;865:10;861:2;854:22;900:2;892:6;885:18;946:3;939:4;934:2;926:6;922:15;918:26;915:35;912:55;;;963:1;960;953:12;912:55;1027:2;1020:4;1012:6;1008:17;1001:4;993:6;989:17;976:54;1074:1;1067:4;1062:2;1054:6;1050:15;1046:26;1039:37;1094:6;1085:15;;;;;;329:777;;;;:::o;1111:798::-;1204:6;1212;1220;1228;1281:3;1269:9;1260:7;1256:23;1252:33;1249:53;;;1298:1;1295;1288:12;1249:53;1337:9;1324:23;1356:30;1380:5;1356:30;:::i;:::-;1405:5;-1:-1:-1;1462:2:1;1447:18;;1434:32;1510:42;1497:56;;1485:69;;1475:97;;1568:1;1565;1558:12;1475:97;1591:7;-1:-1:-1;1650:2:1;1635:18;;1622:32;1663;1622;1663;:::i;:::-;1714:7;-1:-1:-1;1772:2:1;1757:18;;1744:32;1799:18;1788:30;;1785:50;;;1831:1;1828;1821:12;1785:50;1854:49;1895:7;1886:6;1875:9;1871:22;1854:49;:::i;:::-;1844:59;;;1111:798;;;;;;;:::o;1914:730::-;2016:6;2024;2032;2040;2048;2101:3;2089:9;2080:7;2076:23;2072:33;2069:53;;;2118:1;2115;2108:12;2069:53;2157:9;2144:23;2176:30;2200:5;2176:30;:::i;:::-;2225:5;-1:-1:-1;2282:2:1;2267:18;;2254:32;2295;2254;2295;:::i;:::-;2346:7;-1:-1:-1;2400:2:1;2385:18;;2372:32;;-1:-1:-1;2451:2:1;2436:18;;2423:32;;-1:-1:-1;2506:3:1;2491:19;;2478:33;2534:18;2523:30;;2520:50;;;2566:1;2563;2556:12;2520:50;2589:49;2630:7;2621:6;2610:9;2606:22;2589:49;:::i;:::-;2579:59;;;1914:730;;;;;;;;:::o;2880:481::-;2921:3;2959:5;2953:12;2986:6;2981:3;2974:19;3011:1;3021:162;3035:6;3032:1;3029:13;3021:162;;;3097:4;3153:13;;;3149:22;;3143:29;3125:11;;;3121:20;;3114:59;3050:12;3021:162;;;3025:3;3228:1;3221:4;3212:6;3207:3;3203:16;3199:27;3192:38;3350:4;3280:66;3275:2;3267:6;3263:15;3259:88;3254:3;3250:98;3246:109;3239:116;;;2880:481;;;;:::o;3366:596::-;3584:4;3613:10;3662:2;3654:6;3650:15;3639:9;3632:34;3702:6;3697:2;3686:9;3682:18;3675:34;3757:2;3749:6;3745:15;3740:2;3729:9;3725:18;3718:43;;3809:42;3801:6;3797:55;3792:2;3781:9;3777:18;3770:83;3890:3;3884;3873:9;3869:19;3862:32;3911:45;3951:3;3940:9;3936:19;3928:6;3911:45;:::i;:::-;3903:53;3366:596;-1:-1:-1;;;;;;;3366:596:1:o;3967:310::-;4045:6;4053;4106:2;4094:9;4085:7;4081:23;4077:32;4074:52;;;4122:1;4119;4112:12;4074:52;4154:9;4148:16;4173:30;4197:5;4173:30;:::i;:::-;4267:2;4252:18;;;;4246:25;4222:5;;4246:25;;-1:-1:-1;;;3967:310:1:o;4282:547::-;4500:4;4529:10;4578:2;4570:6;4566:15;4555:9;4548:34;4630:2;4622:6;4618:15;4613:2;4602:9;4598:18;4591:43;;4670:6;4665:2;4654:9;4650:18;4643:34;4713:6;4708:2;4697:9;4693:18;4686:34;4757:3;4751;4740:9;4736:19;4729:32;4778:45;4818:3;4807:9;4803:19;4795:6;4778:45;:::i","abiDefinition":[{"inputs":[{"internalType":"address","name":"origin_","type":"address"},{"internalType":"address","name":"destination_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint32","name":"origin","type":"uint32"},{"indexed":false,"internalType":"uint32","name":"nonce","type":"uint32"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"proofMaturity","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"content","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint32","name":"destination","type":"uint32"},{"indexed":false,"internalType":"uint32","name":"nonce","type":"uint32"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"recipient","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"content","type":"bytes"}],"name":"MessageSent","type":"event"},{"inputs":[],"name":"destination","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"origin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"origin_","type":"uint32"},{"internalType":"uint32","name":"nonce","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"uint256","name":"proofMaturity","type":"uint256"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"receiveBaseMessage","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destination_","type":"uint32"},{"internalType":"address","name":"recipientAddress","type":"address"},{"internalType":"uint32","name":"optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"content","type":"bytes"}],"name":"sendMessage","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"destination()":{"notice":"Local chain Destination: used for receiving messages"},"origin()":{"notice":"Local chain Origin: used for sending messages"},"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"notice":"Message recipient needs to implement this function in order to receive cross-chain messages."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":{"details":"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \"message optimistic period\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.","params":{"content":"Raw bytes content of message","nonce":"Message nonce on the origin domain","origin":"Domain where message originated","proofMaturity":"Message's merkle proof age in seconds","sender":"Sender address on origin chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"origin\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proofMaturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destination\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"proofMaturity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"receiveBaseMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destination_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"details\":\"Message recipient needs to ensure that merkle proof for the message is at least as old as the optimistic period that the recipient is using. Note: as this point it is checked that the \\\"message optimistic period\\\" has passed, however the period value itself could be anything, and thus could differ from the one that the recipient would like to enforce.\",\"params\":{\"content\":\"Raw bytes content of message\",\"nonce\":\"Message nonce on the origin domain\",\"origin\":\"Domain where message originated\",\"proofMaturity\":\"Message's merkle proof age in seconds\",\"sender\":\"Sender address on origin chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"destination()\":{\"notice\":\"Local chain Destination: used for receiving messages\"},\"origin()\":{\"notice\":\"Local chain Origin: used for sending messages\"},\"receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)\":{\"notice\":\"Message recipient needs to implement this function in order to receive cross-chain messages.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TestClient.sol\":\"TestClient\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TestClient.sol\":{\"keccak256\":\"0x2662ccc7afc57eb5dc92068e12ca6e1d45e19dd0ce7edb810144a1e82d890018\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ddc7fff7e270b547c6831d476764c244c9750fae6b3938794bd313578368978b\",\"dweb:/ipfs/QmQaRsj5vQHEqQDGLVjkX3uv6bRVupSt2Jb1B3WMeBTdpY\"]}},\"version\":1}"},"hashes":{"destination()":"b269681d","origin()":"938b5f32","receiveBaseMessage(uint32,uint32,bytes32,uint256,bytes)":"8d3ea9e7","sendMessage(uint32,address,uint32,bytes)":"1d0a1d47"}},"solidity/TestClient.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c374d21cfbee8cc4f3614064e58408c103bcd9a4c8ddf691b9964a0abb6543af64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c374d21cfbee8cc4f3614064e58408c103bcd9a4c8ddf691b9964a0abb6543af64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// ══════════════════════════════ LIBRARY IMPORTS ══════════════════════════════\n\n/// Request is encoded data with \"message execution request\".\ntype Request is uint160;\n\nusing RequestLib for Request global;\n\n/// Library for formatting _the request part_ of _the base messages_.\n/// - Request represents a message sender requirements for the message execution on the destination chain.\n/// - Request occupies a single storage word, and thus is stored on stack instead of being stored in memory.\n/// \u003e gasDrop field is included for future compatibility and is ignored at the moment.\n///\n/// # Request stack layout (from highest bits to lowest)\n///\n/// | Position   | Field    | Type   | Bytes | Description                                          |\n/// | ---------- | -------- | ------ | ----- | ---------------------------------------------------- |\n/// | (020..008] | gasDrop  | uint96 | 12    | Minimum amount of gas token to drop to the recipient |\n/// | (008..000] | gasLimit | uint64 | 8     | Minimum amount of gas units to supply for execution  |\n\nlibrary RequestLib {\n    /// @dev Amount of bits to shift to gasDrop field\n    uint160 private constant SHIFT_GAS_DROP = 8 * 8;\n\n    /// @notice Returns an encoded request with the given fields\n    /// @param gasDrop_     Minimum amount of gas token to drop to the recipient (ignored at the moment)\n    /// @param gasLimit_    Minimum amount of gas units to supply for execution\n    function encodeRequest(uint96 gasDrop_, uint64 gasLimit_) internal pure returns (Request) {\n        return Request.wrap(uint160(gasDrop_) \u003c\u003c SHIFT_GAS_DROP | gasLimit_);\n    }\n\n    /// @notice Wraps the padded encoded request into a Request-typed value.\n    /// @dev The \"padded\" request is simply an encoded request casted to uint256 (highest bits are set to zero).\n    /// Casting to uint256 is done automatically in Solidity, so no extra actions from consumers are needed.\n    /// The highest bits are discarded, so that the contracts dealing with encoded requests\n    /// don't need to be updated, if a new field is added.\n    function wrapPadded(uint256 paddedRequest) internal pure returns (Request) {\n        return Request.wrap(uint160(paddedRequest));\n    }\n\n    /// @notice Returns the requested minimum amount of gas units to supply for execution.\n    function gasLimit(Request request) internal pure returns (uint64) {\n        // Casting to uint64 will truncate the highest bits, which is the behavior we want\n        return uint64(Request.unwrap(request));\n    }\n\n    /// @notice Returns the requested of gas token to drop to the recipient.\n    function gasDrop(Request request) internal pure returns (uint96) {\n        // Casting to uint96 will truncate the highest bits, which is the behavior we want\n        return uint96(Request.unwrap(request) \u003e\u003e SHIFT_GAS_DROP);\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// ═════════════════════════════ INTERNAL IMPORTS ══════════════════════════════\n\ninterface IMessageRecipient {\n    /**\n     * @notice Message recipient needs to implement this function in order to\n     * receive cross-chain messages.\n     * @dev Message recipient needs to ensure that merkle proof for the message\n     * is at least as old as the optimistic period that the recipient is using.\n     * Note: as this point it is checked that the \"message optimistic period\" has passed,\n     * however the period value itself could be anything, and thus could differ from the one\n     * that the recipient would like to enforce.\n     * @param origin            Domain where message originated\n     * @param nonce             Message nonce on the origin domain\n     * @param sender            Sender address on origin chain\n     * @param proofMaturity     Message's merkle proof age in seconds\n     * @param content           Raw bytes content of message\n     */\n    function receiveBaseMessage(\n        uint32 origin,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable;\n}\n\ninterface InterfaceOrigin {\n    // ═══════════════════════════════════════════════ SEND MESSAGES ═══════════════════════════════════════════════════\n\n    /**\n     * @notice Send a message to the recipient located on destination domain.\n     * @dev Recipient has to conform to IMessageRecipient interface, otherwise message won't be delivered.\n     * @param destination           Domain of destination chain\n     * @param recipient             Address of recipient on destination chain as bytes32\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param paddedRequest         Padded encoded message execution request on destination chain\n     * @param content               Raw bytes content of message\n     * @return messageNonce         Nonce of the sent message\n     * @return messageHash          Hash of the sent message\n     */\n    function sendBaseMessage(\n        uint32 destination,\n        bytes32 recipient,\n        uint32 optimisticPeriod,\n        uint256 paddedRequest,\n        bytes memory content\n    ) external payable returns (uint32 messageNonce, bytes32 messageHash);\n\n    /**\n     * @notice Send a manager message to the destination domain.\n     * @dev This could only be called by AgentManager, which takes care of encoding the calldata payload.\n     * Note: (msgOrigin, proofMaturity) security args will be added to payload on the destination chain\n     * so that the AgentManager could verify where the Manager Message came from and how mature is the proof.\n     * Note: function is not payable, as no tips are required for sending a manager message.\n     * @param destination           Domain of destination chain\n     * @param optimisticPeriod      Optimistic period for message execution on destination chain\n     * @param payload               Payload for calling AgentManager on destination chain (with extra security args)\n     */\n    function sendManagerMessage(uint32 destination, uint32 optimisticPeriod, bytes memory payload)\n        external\n        returns (uint32 messageNonce, bytes32 messageHash);\n\n    // ════════════════════════════════════════════════ TIPS LOGIC ═════════════════════════════════════════════════════\n\n    /**\n     * @notice Withdraws locked base message tips to the recipient.\n     * @dev Could only be called by a local AgentManager.\n     * @param recipient     Address to withdraw tips to\n     * @param amount        Tips value to withdraw\n     */\n    function withdrawTips(address recipient, uint256 amount) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /**\n     * @notice Returns the minimum tips value for sending a message to a given destination.\n     * @dev Using at least `tipsValue` as `msg.value` for `sendBaseMessage()`\n     * will guarantee that the message will be accepted.\n     * @param destination       Domain of destination chain\n     * @param paddedRequest     Padded encoded message execution request on destination chain\n     * @param contentLength     The length of the message content\n     * @return tipsValue        Minimum tips value for a message to be accepted\n     */\n    function getMinimumTipsValue(uint32 destination, uint256 paddedRequest, uint256 contentLength)\n        external\n        view\n        returns (uint256 tipsValue);\n}\n\ncontract TestClient is IMessageRecipient {\n    /// @notice Local chain Origin: used for sending messages\n    address public immutable origin;\n\n    /// @notice Local chain Destination: used for receiving messages\n    address public immutable destination;\n\n    event MessageReceived(uint32 origin, uint32 nonce, bytes32 sender, uint256 proofMaturity, bytes content);\n\n    event MessageSent(uint32 destination, uint32 nonce, bytes32 sender, bytes32 recipient, bytes content);\n\n    constructor(address origin_, address destination_) {\n        origin = origin_;\n        destination = destination_;\n    }\n\n    /// @inheritdoc IMessageRecipient\n    function receiveBaseMessage(\n        uint32 origin_,\n        uint32 nonce,\n        bytes32 sender,\n        uint256 proofMaturity,\n        bytes memory content\n    ) external payable {\n        require(msg.sender == destination, \"TestClient: !destination\");\n        emit MessageReceived(origin_, nonce, sender, proofMaturity, content);\n    }\n\n    function sendMessage(uint32 destination_, address recipientAddress, uint32 optimisticSeconds, bytes memory content)\n        external\n    {\n        bytes32 recipient = TypeCasts.addressToBytes32(recipientAddress);\n        // TODO: figure out the logic for a message test\n        Request request = RequestLib.encodeRequest(0, 0);\n        (uint32 nonce,) = InterfaceOrigin(origin).sendBaseMessage(\n            destination_, recipient, optimisticSeconds, Request.unwrap(request), content\n        );\n        emit MessageSent(destination_, nonce, TypeCasts.addressToBytes32(address(this)), recipient, content);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"3006:350:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3006:350:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3006:350:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TestClient.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TestClient.sol\":{\"keccak256\":\"0x2662ccc7afc57eb5dc92068e12ca6e1d45e19dd0ce7edb810144a1e82d890018\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ddc7fff7e270b547c6831d476764c244c9750fae6b3938794bd313578368978b\",\"dweb:/ipfs/QmQaRsj5vQHEqQDGLVjkX3uv6bRVupSt2Jb1B3WMeBTdpY\"]}},\"version\":1}"},"hashes":{}}}