{"solidity/AttestationHarness.t.sol:Attestation":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220bcc85e029dd4d1bca2480d411ba280a68c7e88807a6773a6ce976182da1b0c3564736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220bcc85e029dd4d1bca2480d411ba280a68c7e88807a6773a6ce976182da1b0c3564736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/**\n * @dev The goal of this library is to assign a type for every bytes29 memory pointer\n * and enforce strict type checking for every bytes29 operation. This will prevent\n * a misuse of libraries, i.e. using Attestation functions on a Report pointer.\n */\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"47437:14212:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;47437:14212:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"47437:14212:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"AttestationData memory layout [000 .. 004): origin         uint32   4 bytes [004 .. 008): destination    uint32   4 bytes [008 .. 012): nonce          uint32   4 bytes [012 .. 044): root           bytes32 32 bytes      Attestation memory layout [000 .. 044): attData        bytes   44 bytes (see above) [044 .. 045): G = guardSigs  uint8    1 byte [045 .. 046): N = notarySigs uint8    1 byte [046 .. 111): guardSig[0]    bytes   65 bytes      .. [AAA .. BBB): guardSig[G-1]  bytes   65 bytes [BBB .. CCC): notarySig[0]   bytes   65 bytes      .. [DDD .. END): notarySig[N-1] bytes   65 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"AttestationData memory layout [000 .. 004): origin         uint32   4 bytes [004 .. 008): destination    uint32   4 bytes [008 .. 012): nonce          uint32   4 bytes [012 .. 044): root           bytes32 32 bytes      Attestation memory layout [000 .. 044): attData        bytes   44 bytes (see above) [044 .. 045): G = guardSigs  uint8    1 byte [045 .. 046): N = notarySigs uint8    1 byte [046 .. 111): guardSig[0]    bytes   65 bytes      .. [AAA .. BBB): guardSig[G-1]  bytes   65 bytes [BBB .. CCC): notarySig[0]   bytes   65 bytes      .. [DDD .. END): notarySig[N-1] bytes   65 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"Attestation\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0xc2ab2be19882fab6ed5fa1d1248163ddd7c9abaecbc54b83014aa2fbbfe57314\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2749989ad204420aee57301fb6fedfb2e29204459b29725f7562ddc8386f680d\",\"dweb:/ipfs/Qma6TQMtxEUu1uvbaeX6PP1ZPcpLiPEwr9cDYyzPPhxXWa\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:AttestationHarness":{"code":"0x608060405234801561001057600080fd5b50611eeb806100206000396000f3fe608060405234801561001057600080fd5b50600436106101cf5760003560e01c80638b445f5111610104578063badad7db116100a2578063ce53359211610071578063ce533592146103db578063d2c4428a14610453578063dc1e976d1461045a578063f24caf611461046d57600080fd5b8063badad7db146103f5578063c231bd8f14610408578063c2e19ed21461041b578063cbe9d7841461042e57600080fd5b80639f668e20116100de5780639f668e20146103b55780639ffb971e146103c8578063a104a5e5146103db578063a43aa286146103e257600080fd5b80638b445f511461038757806391eedc1d1461039a57806397d91f1a146103ad57600080fd5b80634a0cfe0e1161017157806365dfb4281161014b57806365dfb428146102e85780637214101b14610314578063794dd2141461034457806379ce92a91461035757600080fd5b80634a0cfe0e146102b9578063569e1eaf146102da5780635b42242d146102e157600080fd5b8063320bfc44116101ad578063320bfc44146102485780633ae7034d146102595780633b830f3b1461027c57806340a5737f146102a457600080fd5b8063036227a2146101d45780632951eae3146101fd578063308514be14610210575b600080fd5b6101e76101e2366004611a8c565b61049a565b6040516101f49190611b78565b60405180910390f35b6101e761020b366004611ba4565b6104b1565b61022361021e366004611bef565b610518565b6040805167ffffffffffffffff909316835263ffffffff9091166020830152016101f4565b60005b6040519081526020016101f4565b61026c610267366004611c1d565b61053b565b60405190151581526020016101f4565b61028f61028a366004611c52565b61055a565b60405163ffffffff90911681526020016101f4565b6102b76102b2366004611cac565b600055565b005b6102cc6102c7366004611c52565b610574565b6040516101f4929190611cc5565b600861024b565b600c61024b565b6102fb6102f6366004611ce5565b6105cb565b60405167ffffffffffffffff90911681526020016101f4565b610327610322366004611d18565b6105e9565b6040805163ffffffff9384168152929091166020830152016101f4565b6101e7610352366004611a8c565b610600565b61036a610365366004611c52565b61062b565b6040516bffffffffffffffffffffffff90911681526020016101f4565b61028f610395366004611c52565b610645565b61024b6103a8366004611c52565b61065f565b61024b610679565b61036a6103c3366004611d42565b61068c565b6102cc6103d6366004611c52565b6106be565b602c61024b565b6102cc6103f0366004611c52565b6106db565b61028f610403366004611c52565b610706565b6102fb610416366004611c52565b610720565b6102cc610429366004611c52565b61073a565b61044161043c366004611c52565b610749565b60405160ff90911681526020016101f4565b600461024b565b610441610468366004611c52565b610763565b61048061047b366004611c52565b61077d565b6040805160ff9384168152929091166020830152016101f4565b60606104a78484846107a3565b90505b9392505050565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e087811b8216602084015286811b8216602484015285901b166028820152602c80820184905282518083039091018152604c9091019091525b949350505050565b600080602083901c67ffffffffffffffff1663ffffffff84165b91509150915091565b6000610554610549836107c3565b62ffffff19166107d4565b92915050565b60006104aa610569838561086a565b62ffffff191661088e565b60006060600061059f600054610593878761086a90919063ffffffff16565b62ffffff1916906108b9565b90506105b062ffffff198216610990565b6105bf62ffffff1983166109b4565b92509250509250929050565b600067ffffffff00000000602084901b1663ffffffff8316176104aa565b60008063ffffffff602084901c8116908416610532565b60606104a761061085600061086a565b61061b85600061086a565b61062685600061086a565b610a07565b60006104aa61063a838561086a565b62ffffff1916610b69565b60006104aa610654838561086a565b62ffffff1916610b95565b60006104aa61066e838561086a565b62ffffff1916610bc1565b6000610687602c6002611db4565b905090565b600063ffffffff8216602084901b67ffffffff0000000016604086901b6bffffffff00000000000000001617176104a7565b600060608161059f6106d0858761086a565b62ffffff1916610bed565b60006060600061059f6000546106fa878761086a90919063ffffffff16565b62ffffff191690610c1f565b60006104aa610715838561086a565b62ffffff1916610d04565b60006104aa61072f838561086a565b62ffffff1916610d30565b60006060600061059f846107c3565b60006104aa610758838561086a565b62ffffff1916610d5c565b60006104aa610772838561086a565b62ffffff1916610d7e565b60008061079861078d848661086a565b62ffffff1916610da8565b915091509250929050565b60606104a76107b185610dd6565b6107ba85610dd6565b61062685610dd6565b60006105548264010100000061086a565b6000601882901c6bffffffffffffffffffffffff166107f5602c6002611db4565b8110156108055750600092915050565b60008061081185610de2565b60ff918216935016905060006108278284611db4565b90508060000361083d5750600095945050505050565b610848604182611dc7565b610854602c6002611db4565b61085e9190611db4565b90931495945050505050565b81516000906020840161088564ffffffffff85168284610e0d565b95945050505050565b6000816108a662ffffff198216640101000000610e54565b506104aa62ffffff198416600480610f6e565b6000826108d162ffffff198216640101000000610e54565b5060006108dd85610de2565b5090508060ff168410610951576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e6765000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61088561095f604186611dc7565b61096b602c6002611db4565b6109759190611db4565b62ffffff1987169060416301000000610f9e565b5092915050565b60008060606109a0816018611db4565b6109aa9190611db4565b9290921c92915050565b60606000806109d18460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506109f68483602001611009565b508181016020016040529052919050565b60606000610a14846111f0565b90506000610a21846111f0565b60408051600480825260a0820190925291925061ff00600885901b1660ff84161791600091602082016080803683370190505090508781600081518110610a6a57610a6a611dde565b62ffffff19909216602092830291909101820152604051610ad091610abc9185910160f09190911b7fffff00000000000000000000000000000000000000000000000000000000000016815260020190565b604051602081830303815290604052610dd6565b81600181518110610ae357610ae3611dde565b602002602001019062ffffff1916908162ffffff1916815250508681600281518110610b1157610b11611dde565b602002602001019062ffffff1916908162ffffff1916815250508581600381518110610b3f57610b3f611dde565b62ffffff1990921660209283029190910190910152610b5d816112f0565b98975050505050505050565b600081610b8162ffffff198216640101000000610e54565b506104aa62ffffff1984166000600c610f6e565b600081610bad62ffffff198216640101000000610e54565b506104aa62ffffff19841660086004610f6e565b600081610bd962ffffff198216640101000000610e54565b506104aa62ffffff198416600c602061134f565b600081610c0562ffffff198216640101000000610e54565b506104aa62ffffff1984166000602c640101010000610f9e565b600082610c3762ffffff198216640101000000610e54565b50600080610c4486610de2565b915091508060ff168510610cb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e676500000000000000000000000000000000000000006044820152606401610948565b610cfa6041610cc660ff851688611db4565b610cd09190611dc7565b610cdc602c6002611db4565b610ce69190611db4565b62ffffff1988169060416301000000610f9e565b9695505050505050565b600081610d1c62ffffff198216640101000000610e54565b506104aa62ffffff19841660006004610f6e565b600081610d4862ffffff198216640101000000610e54565b506104aa62ffffff19841660006008610f6e565b600081610d7462ffffff198216640101000000610e54565b5061051083610de2565b600081610d9662ffffff198216640101000000610e54565b50610da083610de2565b509392505050565b60008082610dc162ffffff198216640101000000610e54565b50610dcb84610de2565b909590945092505050565b6000610554828261086a565b60008080610df962ffffff198516602c6002610f6e565b60ff600882901c8116969116945092505050565b600080610e1a8385611db4565b9050604051811115610e2a575060005b80600003610e3f5762ffffff199150506104aa565b5050606092831b9190911790911b1760181b90565b6000610e6083836114fd565b610f67576000610e7e610e7285610990565b64ffffffffff1661151f565b9150506000610e938464ffffffffff1661151f565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b5090919050565b6000610f7b826020611e0d565b610f86906008611e26565b60ff16610f9485858561134f565b901c949350505050565b600080610faa86611609565b6bffffffffffffffffffffffff169050610fc386611630565b84610fce8784611db4565b610fd89190611db4565b1115610feb5762ffffff19915050610510565b610ff58582611db4565b9050610cfa8364ffffffffff168286610e0d565b600062ffffff198084160361107a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610948565b61108383611669565b6110e9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610948565b60006111038460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061111e85611609565b6bffffffffffffffffffffffff1690506000806040519150858211156111445760206060fd5b8386858560045afa9050806111b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610948565b6111e56111c188610990565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b6000601882901c6bffffffffffffffffffffffff1681611211604183611e42565b90508161121f604183611dc7565b14611286576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f217369676e6174757265734c656e6774680000000000000000000000000000006044820152606401610948565b60ff81106104aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f546f6f206d616e79207369676e617475726573000000000000000000000000006044820152606401610948565b604051606090600061130584602084016116a5565b905060006113218260181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061133c8361173f565b9184525082016020016040525092915050565b60008160ff16600003611364575060006104aa565b61137c8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661139760ff841685611db4565b111561141a576113e76113a985611609565b6bffffffffffffffffffffffff166113cf8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611755565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b60208260ff161115611488576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610948565b60088202600061149786611609565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008164ffffffffff1661151084610990565b64ffffffffff16149392505050565b600080601f5b600f8160ff16111561159257600061153e826008611e26565b60ff1685901c905061154f816118e5565b61ffff16841793508160ff1660101461156a57601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611525565b50600f5b60ff8160ff1610156116035760006115af826008611e26565b60ff1685901c90506115c0816118e5565b61ffff16831792508160ff166000146115db57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611596565b50915091565b60008061161860606018611db4565b9290921c6bffffffffffffffffffffffff1692915050565b600061164a8260181c6bffffffffffffffffffffffff1690565b61165383611609565b016bffffffffffffffffffffffff169050919050565b600061167482610990565b64ffffffffff1664ffffffffff0361168e57506000919050565b600061169983611630565b60405110199392505050565b6000604051828111156116b85760206060fd5b506000805b845181101561172f5760008582815181106116da576116da611dde565b602002602001015190506116f081848701611009565b506117098160181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff168301925050808061172790611e7d565b9150506116bd565b50606083901b811760181b610510565b600061174a82611917565b610554906020611dc7565b606060006117628661151f565b91505060006117708661151f565b915050600061177e8661151f565b915050600061178c8661151f565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b60006118f760048360ff16901c611956565b60ff1661ffff919091161760081b61190e82611956565b60ff1617919050565b600060206119338360181c6bffffffffffffffffffffffff1690565b61194c906bffffffffffffffffffffffff16601f611db4565b6105549190611e42565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f841691829081106119a3576119a3611dde565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126119f257600080fd5b813567ffffffffffffffff80821115611a0d57611a0d6119b2565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611a5357611a536119b2565b81604052838152866020858801011115611a6c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215611aa157600080fd5b833567ffffffffffffffff80821115611ab957600080fd5b611ac5878388016119e1565b94506020860135915080821115611adb57600080fd5b611ae7878388016119e1565b93506040860135915080821115611afd57600080fd5b50611b0a868287016119e1565b9150509250925092565b6000815180845260005b81811015611b3a57602081850181015186830182015201611b1e565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b6020815260006104aa6020830184611b14565b803563ffffffff81168114611b9f57600080fd5b919050565b60008060008060808587031215611bba57600080fd5b611bc385611b8b565b9350611bd160208601611b8b565b9250611bdf60408601611b8b565b9396929550929360600135925050565b600060208284031215611c0157600080fd5b81356bffffffffffffffffffffffff811681146104aa57600080fd5b600060208284031215611c2f57600080fd5b813567ffffffffffffffff811115611c4657600080fd5b610510848285016119e1565b60008060408385031215611c6557600080fd5b823564ffffffffff81168114611c7a57600080fd5b9150602083013567ffffffffffffffff811115611c9657600080fd5b611ca2858286016119e1565b9150509250929050565b600060208284031215611cbe57600080fd5b5035919050565b64ffffffffff831681526040602082015260006104a76040830184611b14565b60008060408385031215611cf857600080fd5b611d0183611b8b565b9150611d0f60208401611b8b565b90509250929050565b600060208284031215611d2a57600080fd5b813567ffffffffffffffff811681146104aa57600080fd5b600080600060608486031215611d5757600080fd5b611d6084611b8b565b9250611d6e60208501611b8b565b9150611d7c60408501611b8b565b90509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561055457610554611d85565b808202811582820484141761055457610554611d85565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60ff828116828216039081111561055457610554611d85565b60ff818116838216029081169081811461098957610989611d85565b600082611e78577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611eae57611eae611d85565b506001019056fea26469706673582212204485c0e451e93a24acd24b92b89a1caca671b441f66f5f18f590f74141ba331364736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106101cf5760003560e01c80638b445f5111610104578063badad7db116100a2578063ce53359211610071578063ce533592146103db578063d2c4428a14610453578063dc1e976d1461045a578063f24caf611461046d57600080fd5b8063badad7db146103f5578063c231bd8f14610408578063c2e19ed21461041b578063cbe9d7841461042e57600080fd5b80639f668e20116100de5780639f668e20146103b55780639ffb971e146103c8578063a104a5e5146103db578063a43aa286146103e257600080fd5b80638b445f511461038757806391eedc1d1461039a57806397d91f1a146103ad57600080fd5b80634a0cfe0e1161017157806365dfb4281161014b57806365dfb428146102e85780637214101b14610314578063794dd2141461034457806379ce92a91461035757600080fd5b80634a0cfe0e146102b9578063569e1eaf146102da5780635b42242d146102e157600080fd5b8063320bfc44116101ad578063320bfc44146102485780633ae7034d146102595780633b830f3b1461027c57806340a5737f146102a457600080fd5b8063036227a2146101d45780632951eae3146101fd578063308514be14610210575b600080fd5b6101e76101e2366004611a8c565b61049a565b6040516101f49190611b78565b60405180910390f35b6101e761020b366004611ba4565b6104b1565b61022361021e366004611bef565b610518565b6040805167ffffffffffffffff909316835263ffffffff9091166020830152016101f4565b60005b6040519081526020016101f4565b61026c610267366004611c1d565b61053b565b60405190151581526020016101f4565b61028f61028a366004611c52565b61055a565b60405163ffffffff90911681526020016101f4565b6102b76102b2366004611cac565b600055565b005b6102cc6102c7366004611c52565b610574565b6040516101f4929190611cc5565b600861024b565b600c61024b565b6102fb6102f6366004611ce5565b6105cb565b60405167ffffffffffffffff90911681526020016101f4565b610327610322366004611d18565b6105e9565b6040805163ffffffff9384168152929091166020830152016101f4565b6101e7610352366004611a8c565b610600565b61036a610365366004611c52565b61062b565b6040516bffffffffffffffffffffffff90911681526020016101f4565b61028f610395366004611c52565b610645565b61024b6103a8366004611c52565b61065f565b61024b610679565b61036a6103c3366004611d42565b61068c565b6102cc6103d6366004611c52565b6106be565b602c61024b565b6102cc6103f0366004611c52565b6106db565b61028f610403366004611c52565b610706565b6102fb610416366004611c52565b610720565b6102cc610429366004611c52565b61073a565b61044161043c366004611c52565b610749565b60405160ff90911681526020016101f4565b600461024b565b610441610468366004611c52565b610763565b61048061047b366004611c52565b61077d565b6040805160ff9384168152929091166020830152016101f4565b60606104a78484846107a3565b90505b9392505050565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e087811b8216602084015286811b8216602484015285901b166028820152602c80820184905282518083039091018152604c9091019091525b949350505050565b600080602083901c67ffffffffffffffff1663ffffffff84165b91509150915091565b6000610554610549836107c3565b62ffffff19166107d4565b92915050565b60006104aa610569838561086a565b62ffffff191661088e565b60006060600061059f600054610593878761086a90919063ffffffff16565b62ffffff1916906108b9565b90506105b062ffffff198216610990565b6105bf62ffffff1983166109b4565b92509250509250929050565b600067ffffffff00000000602084901b1663ffffffff8316176104aa565b60008063ffffffff602084901c8116908416610532565b60606104a761061085600061086a565b61061b85600061086a565b61062685600061086a565b610a07565b60006104aa61063a838561086a565b62ffffff1916610b69565b60006104aa610654838561086a565b62ffffff1916610b95565b60006104aa61066e838561086a565b62ffffff1916610bc1565b6000610687602c6002611db4565b905090565b600063ffffffff8216602084901b67ffffffff0000000016604086901b6bffffffff00000000000000001617176104a7565b600060608161059f6106d0858761086a565b62ffffff1916610bed565b60006060600061059f6000546106fa878761086a90919063ffffffff16565b62ffffff191690610c1f565b60006104aa610715838561086a565b62ffffff1916610d04565b60006104aa61072f838561086a565b62ffffff1916610d30565b60006060600061059f846107c3565b60006104aa610758838561086a565b62ffffff1916610d5c565b60006104aa610772838561086a565b62ffffff1916610d7e565b60008061079861078d848661086a565b62ffffff1916610da8565b915091509250929050565b60606104a76107b185610dd6565b6107ba85610dd6565b61062685610dd6565b60006105548264010100000061086a565b6000601882901c6bffffffffffffffffffffffff166107f5602c6002611db4565b8110156108055750600092915050565b60008061081185610de2565b60ff918216935016905060006108278284611db4565b90508060000361083d5750600095945050505050565b610848604182611dc7565b610854602c6002611db4565b61085e9190611db4565b90931495945050505050565b81516000906020840161088564ffffffffff85168284610e0d565b95945050505050565b6000816108a662ffffff198216640101000000610e54565b506104aa62ffffff198416600480610f6e565b6000826108d162ffffff198216640101000000610e54565b5060006108dd85610de2565b5090508060ff168410610951576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e6765000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61088561095f604186611dc7565b61096b602c6002611db4565b6109759190611db4565b62ffffff1987169060416301000000610f9e565b5092915050565b60008060606109a0816018611db4565b6109aa9190611db4565b9290921c92915050565b60606000806109d18460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506109f68483602001611009565b508181016020016040529052919050565b60606000610a14846111f0565b90506000610a21846111f0565b60408051600480825260a0820190925291925061ff00600885901b1660ff84161791600091602082016080803683370190505090508781600081518110610a6a57610a6a611dde565b62ffffff19909216602092830291909101820152604051610ad091610abc9185910160f09190911b7fffff00000000000000000000000000000000000000000000000000000000000016815260020190565b604051602081830303815290604052610dd6565b81600181518110610ae357610ae3611dde565b602002602001019062ffffff1916908162ffffff1916815250508681600281518110610b1157610b11611dde565b602002602001019062ffffff1916908162ffffff1916815250508581600381518110610b3f57610b3f611dde565b62ffffff1990921660209283029190910190910152610b5d816112f0565b98975050505050505050565b600081610b8162ffffff198216640101000000610e54565b506104aa62ffffff1984166000600c610f6e565b600081610bad62ffffff198216640101000000610e54565b506104aa62ffffff19841660086004610f6e565b600081610bd962ffffff198216640101000000610e54565b506104aa62ffffff198416600c602061134f565b600081610c0562ffffff198216640101000000610e54565b506104aa62ffffff1984166000602c640101010000610f9e565b600082610c3762ffffff198216640101000000610e54565b50600080610c4486610de2565b915091508060ff168510610cb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e676500000000000000000000000000000000000000006044820152606401610948565b610cfa6041610cc660ff851688611db4565b610cd09190611dc7565b610cdc602c6002611db4565b610ce69190611db4565b62ffffff1988169060416301000000610f9e565b9695505050505050565b600081610d1c62ffffff198216640101000000610e54565b506104aa62ffffff19841660006004610f6e565b600081610d4862ffffff198216640101000000610e54565b506104aa62ffffff19841660006008610f6e565b600081610d7462ffffff198216640101000000610e54565b5061051083610de2565b600081610d9662ffffff198216640101000000610e54565b50610da083610de2565b509392505050565b60008082610dc162ffffff198216640101000000610e54565b50610dcb84610de2565b909590945092505050565b6000610554828261086a565b60008080610df962ffffff198516602c6002610f6e565b60ff600882901c8116969116945092505050565b600080610e1a8385611db4565b9050604051811115610e2a575060005b80600003610e3f5762ffffff199150506104aa565b5050606092831b9190911790911b1760181b90565b6000610e6083836114fd565b610f67576000610e7e610e7285610990565b64ffffffffff1661151f565b9150506000610e938464ffffffffff1661151f565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b5090919050565b6000610f7b826020611e0d565b610f86906008611e26565b60ff16610f9485858561134f565b901c949350505050565b600080610faa86611609565b6bffffffffffffffffffffffff169050610fc386611630565b84610fce8784611db4565b610fd89190611db4565b1115610feb5762ffffff19915050610510565b610ff58582611db4565b9050610cfa8364ffffffffff168286610e0d565b600062ffffff198084160361107a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610948565b61108383611669565b6110e9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610948565b60006111038460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061111e85611609565b6bffffffffffffffffffffffff1690506000806040519150858211156111445760206060fd5b8386858560045afa9050806111b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610948565b6111e56111c188610990565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b6000601882901c6bffffffffffffffffffffffff1681611211604183611e42565b90508161121f604183611dc7565b14611286576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f217369676e6174757265734c656e6774680000000000000000000000000000006044820152606401610948565b60ff81106104aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f546f6f206d616e79207369676e617475726573000000000000000000000000006044820152606401610948565b604051606090600061130584602084016116a5565b905060006113218260181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061133c8361173f565b9184525082016020016040525092915050565b60008160ff16600003611364575060006104aa565b61137c8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661139760ff841685611db4565b111561141a576113e76113a985611609565b6bffffffffffffffffffffffff166113cf8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611755565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b60208260ff161115611488576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610948565b60088202600061149786611609565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008164ffffffffff1661151084610990565b64ffffffffff16149392505050565b600080601f5b600f8160ff16111561159257600061153e826008611e26565b60ff1685901c905061154f816118e5565b61ffff16841793508160ff1660101461156a57601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611525565b50600f5b60ff8160ff1610156116035760006115af826008611e26565b60ff1685901c90506115c0816118e5565b61ffff16831792508160ff166000146115db57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611596565b50915091565b60008061161860606018611db4565b9290921c6bffffffffffffffffffffffff1692915050565b600061164a8260181c6bffffffffffffffffffffffff1690565b61165383611609565b016bffffffffffffffffffffffff169050919050565b600061167482610990565b64ffffffffff1664ffffffffff0361168e57506000919050565b600061169983611630565b60405110199392505050565b6000604051828111156116b85760206060fd5b506000805b845181101561172f5760008582815181106116da576116da611dde565b602002602001015190506116f081848701611009565b506117098160181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff168301925050808061172790611e7d565b9150506116bd565b50606083901b811760181b610510565b600061174a82611917565b610554906020611dc7565b606060006117628661151f565b91505060006117708661151f565b915050600061177e8661151f565b915050600061178c8661151f565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b60006118f760048360ff16901c611956565b60ff1661ffff919091161760081b61190e82611956565b60ff1617919050565b600060206119338360181c6bffffffffffffffffffffffff1690565b61194c906bffffffffffffffffffffffff16601f611db4565b6105549190611e42565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f841691829081106119a3576119a3611dde565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126119f257600080fd5b813567ffffffffffffffff80821115611a0d57611a0d6119b2565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611a5357611a536119b2565b81604052838152866020858801011115611a6c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215611aa157600080fd5b833567ffffffffffffffff80821115611ab957600080fd5b611ac5878388016119e1565b94506020860135915080821115611adb57600080fd5b611ae7878388016119e1565b93506040860135915080821115611afd57600080fd5b50611b0a868287016119e1565b9150509250925092565b6000815180845260005b81811015611b3a57602081850181015186830182015201611b1e565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b6020815260006104aa6020830184611b14565b803563ffffffff81168114611b9f57600080fd5b919050565b60008060008060808587031215611bba57600080fd5b611bc385611b8b565b9350611bd160208601611b8b565b9250611bdf60408601611b8b565b9396929550929360600135925050565b600060208284031215611c0157600080fd5b81356bffffffffffffffffffffffff811681146104aa57600080fd5b600060208284031215611c2f57600080fd5b813567ffffffffffffffff811115611c4657600080fd5b610510848285016119e1565b60008060408385031215611c6557600080fd5b823564ffffffffff81168114611c7a57600080fd5b9150602083013567ffffffffffffffff811115611c9657600080fd5b611ca2858286016119e1565b9150509250929050565b600060208284031215611cbe57600080fd5b5035919050565b64ffffffffff831681526040602082015260006104a76040830184611b14565b60008060408385031215611cf857600080fd5b611d0183611b8b565b9150611d0f60208401611b8b565b90509250929050565b600060208284031215611d2a57600080fd5b813567ffffffffffffffff811681146104aa57600080fd5b600080600060608486031215611d5757600080fd5b611d6084611b8b565b9250611d6e60208501611b8b565b9150611d7c60408501611b8b565b90509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561055457610554611d85565b808202811582820484141761055457610554611d85565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60ff828116828216039081111561055457610554611d85565b60ff818116838216029081169081811461098957610989611d85565b600082611e78577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611eae57611eae611d85565b506001019056fea26469706673582212204485c0e451e93a24acd24b92b89a1caca671b441f66f5f18f590f74141ba331364736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/**\n * @dev The goal of this library is to assign a type for every bytes29 memory pointer\n * and enforce strict type checking for every bytes29 operation. This will prevent\n * a misuse of libraries, i.e. using Attestation functions on a Report pointer.\n */\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"61726:7276:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"61726:7276:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;65947:272;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;66653:266;;;;;;:::i;:::-;;:::i;67488:156::-;;;;;;:::i;:::-;;:::i;:::-;;;;3502:18:1;3490:31;;;3472:50;;3570:10;3558:23;;;3553:2;3538:18;;3531:51;3445:18;67488:156:0;3302:286:1;68318:103:0;68363:7;68318:103;;;3739:25:1;;;3727:2;3712:18;68318:103:0;3593:177:1;65218:141:0;;;;;;:::i;:::-;;:::i;:::-;;;4265:14:1;;4258:22;4240:41;;4228:2;4213:18;65218:141:0;4100:187:1;63929:160:0;;;;;;:::i;:::-;;:::i;:::-;;;4957:10:1;4945:23;;;4927:42;;4915:2;4900:18;63929:160:0;4783:192:1;61937:81:0;;;;;;:::i;:::-;61989:14;:22;61937:81;;;63233:263;;;;;;:::i;:::-;;:::i;:::-;;;;;;;;:::i;68546:101::-;48438:1;68546:101;;68653:99;48485:2;68653:99;;66925:171;;;;;;:::i;:::-;;:::i;:::-;;;5910:18:1;5898:31;;;5880:50;;5868:2;5853:18;66925:171:0;5736:200:1;67324:158:0;;;;;;:::i;:::-;;:::i;:::-;;;;6410:10:1;6447:15;;;6429:34;;6499:15;;;;6494:2;6479:18;;6472:43;6373:18;67324:158:0;6230:291:1;66225:422:0;;;;;;:::i;:::-;;:::i;64407:144::-;;;;;;:::i;:::-;;:::i;:::-;;;6700:26:1;6688:39;;;6670:58;;6658:2;6643:18;64407:144:0;6526:208:1;64095:148:0;;;;;;:::i;:::-;;:::i;64557:147::-;;;;;;:::i;:::-;;:::i;68880:120::-;;;:::i;67102:216::-;;;;;;:::i;:::-;;:::i;62976:251::-;;;;;;:::i;:::-;;:::i;68190:122::-;48545:2;68190:122;;63502:265;;;;;;:::i;:::-;;:::i;63773:150::-;;;;;;:::i;:::-;;:::i;64249:152::-;;;;;;:::i;:::-;;:::i;62564:406::-;;;;;;:::i;:::-;;:::i;65059:153::-;;;;;;:::i;:::-;;:::i;:::-;;;7426:4:1;7414:17;;;7396:36;;7384:2;7369:18;65059:153:0;7254:184:1;68427:113:0;48390:1;68427:113;;64902:151;;;;;;:::i;:::-;;:::i;64710:186::-;;;;;;:::i;:::-;;:::i;:::-;;;;7639:4:1;7627:17;;;7609:36;;7681:17;;;;7676:2;7661:18;;7654:45;7582:18;64710:186:0;7443:262:1;65947:272:0;66108:12;66139:73;66169:5;66176:16;66194:17;66139:29;:73::i;:::-;66132:80;;65947:272;;;;;;:::o;66653:266::-;52209:54;;;8246:66:1;8341:3;8337:16;;;8333:25;;52209:54:0;;;8321:38:1;8392:16;;;8388:25;;8375:11;;;8368:46;8447:16;;;8443:25;8430:11;;;8423:46;8485:12;;;;8478:28;;;52209:54:0;;;;;;;;;;8522:12:1;;;;52209:54:0;;;66653:266;;;;;;;:::o;67488:156::-;67552:14;;54676:2;54657:21;;;;;54752:16;54734:34;;67599:38;67592:45;;;;67488:156;;;:::o;65218:141::-;65285:4;65308:44;:28;:8;:26;:28::i;:::-;-1:-1:-1;;65308:42:0;;:44::i;:::-;65301:51;65218:141;-1:-1:-1;;65218:141:0:o;63929:160::-;64016:6;64041:41;:19;:8;64054:5;64041:12;:19::i;:::-;-1:-1:-1;;64041:39:0;;:41::i;63233:263::-;63339:6;63347:12;63375:13;63391:50;63426:14;;63391:19;63404:5;63391:8;:12;;:19;;;;:::i;:::-;-1:-1:-1;;63391:34:0;;;:50::i;:::-;63375:66;-1:-1:-1;63459:14:0;-1:-1:-1;;63459:12:0;;;:14::i;:::-;63475:13;-1:-1:-1;;63475:11:0;;;:13::i;:::-;63451:38;;;;;63233:263;;;;;:::o;66925:171::-;67011:6;53620:21;53639:2;53620:21;;;;53619:38;;;;67036:53;53478:186;67324:158;67396:6;;54331:25;54354:2;54331:25;;;;;;54418:38;;67429:46;54132:332;66225:422;66395:12;66438:202;66497:12;:5;66507:1;66497:9;:12::i;:::-;66543:23;:16;66564:1;66543:20;:23::i;:::-;66601:24;:17;66623:1;66601:21;:24::i;:::-;66438:29;:202::i;64407:144::-;64486:6;64511:33;:19;:8;64524:5;64511:12;:19::i;:::-;-1:-1:-1;;64511:31:0;;:33::i;64095:148::-;64176:6;64201:35;:19;:8;64214:5;64201:12;:19::i;:::-;-1:-1:-1;;64201:33:0;;:35::i;64557:147::-;64637:7;64663:34;:19;:8;64676:5;64663:12;:19::i;:::-;-1:-1:-1;;64663:32:0;;:34::i;68880:120::-;68933:7;48680:21;48545:2;48700:1;48680:21;:::i;:::-;68952:41;;68880:120;:::o;67102:216::-;67229:6;54056:63;;;54107:2;54083:26;;;;;54076:2;54057:21;;;;;54056:54;:63;67254:57;53902:224;62976:251;63083:6;63091:12;63083:6;63135:37;:19;:8;63148:5;63135:12;:19::i;:::-;-1:-1:-1;;63135:35:0;;:37::i;63502:265::-;63609:6;63617:12;63645:13;63661:51;63697:14;;63661:19;63674:5;63661:8;:12;;:19;;;;:::i;:::-;-1:-1:-1;;63661:35:0;;;:51::i;63773:150::-;63855:6;63880:36;:19;:8;63893:5;63880:12;:19::i;:::-;-1:-1:-1;;63880:34:0;;:36::i;64249:152::-;64332:6;64357:37;:19;:8;64370:5;64357:12;:19::i;:::-;-1:-1:-1;;64357:35:0;;:37::i;62564:406::-;62667:6;62675:12;62860:13;62876:39;62906:8;62876:29;:39::i;65059:153::-;65143:5;65167:38;:19;:8;65180:5;65167:12;:19::i;:::-;-1:-1:-1;;65167:36:0;;:38::i;64902:151::-;64985:5;65009:37;:19;:8;65022:5;65009:12;:19::i;:::-;-1:-1:-1;;65009:35:0;;:37::i;64710:186::-;64817:5;;64852:37;:19;:8;64865:5;64852:12;:19::i;:::-;-1:-1:-1;;64852:35:0;;:37::i;:::-;64845:44;;;;64710:186;;;;;:::o;50434:433::-;50597:12;50640:220;50687:22;:5;:20;:22::i;:::-;50743:33;:16;:31;:33::i;:::-;50811:34;:17;:32;:34::i;52376:144::-;52449:7;52475:38;:8;37950:16;52475:12;:38::i;52615:618::-;52676:4;3151:2;18587:23;;;3544:16;18583:41;48680:21;48545:2;48700:1;48680:21;:::i;:::-;52792:6;:31;52788:49;;;-1:-1:-1;52832:5:0;;52615:618;-1:-1:-1;;52615:618:0:o;52788:49::-;52848:17;52867:18;52889:23;52906:5;52889:16;:23::i;:::-;52847:65;;;;;-1:-1:-1;52847:65:0;;-1:-1:-1;52922:17:0;52942:22;52847:65;;52942:22;:::i;:::-;52922:42;;53028:9;53041:1;53028:14;53024:32;;-1:-1:-1;53051:5:0;;52615:618;-1:-1:-1;;;;;52615:618:0:o;53024:32::-;53187:39;40686:2;53187:9;:39;:::i;:::-;48680:21;48545:2;48700:1;48680:21;:::i;:::-;53162:64;;;;:::i;:::-;53152:74;;;;52615:618;-1:-1:-1;;;;;52615:618:0:o;14676:595::-;14780:10;;14746:7;;15206:4;15197:14;;15238:26;;;;15197:14;14780:10;15238:5;:26::i;:::-;15231:33;14676:595;-1:-1:-1;;;;;14676:595:0:o;55697:224::-;55819:6;55795:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;55855:58:0::1;-1:-1:-1::0;;55855:15:0;::::1;48390:1;::::0;55855:15:::1;:58::i;58553:519::-:0;58691:7;58667:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;;58715:15:::1;58736:23;58753:5;58736:16;:23::i;:::-;58714:45;;;58791:9;58777:23;;:11;:23;58769:48;;;::::0;::::1;::::0;;8920:2:1;58769:48:0::1;::::0;::::1;8902:21:1::0;8959:2;8939:18;;;8932:30;8998:14;8978:18;;;8971:42;9030:18;;58769:48:0::1;;;;;;;;;58846:219;58909:41;40686:2;58909:11:::0;:41:::1;:::i;:::-;48680:21;48545:2;48700:1;48680:21;:::i;:::-;58884:66;;;;:::i;:::-;-1:-1:-1::0;;58846:11:0;::::1;::::0;40686:2:::1;37211:16;58846:11;:219::i;49350:1::-;58553:519:::0;;;;;:::o;15463:504::-;15519:12;;3063:2;3335:20;3063:2;3151;3335:20;:::i;:::-;3415;;;;:::i;:::-;15927:24;;;;;15463:504;-1:-1:-1;;15463:504:0:o;31606:632::-;31661:16;31689:11;31710:12;31725;31729:7;3151:2;18587:23;3544:16;18583:41;;18067:573;31725:12;31710:27;;;;31847:4;31841:11;31834:18;;31902:3;31895:10;;31948:33;31961:7;31970:3;31976:4;31970:10;31948:12;:33::i;:::-;-1:-1:-1;32105:14:0;;;32121:4;32101:25;32095:4;32088:39;32168:17;;31606:632;;-1:-1:-1;31606:632:0:o;50873:793::-;51021:12;51045:15;51063:33;51081:14;51063:17;:33::i;:::-;51045:51;;51106:16;51125:34;51143:15;51125:17;:34::i;:::-;51421:16;;;51435:1;51421:16;;;;;;;;;51106:53;;-1:-1:-1;51257:22:0;51278:1;51257:22;;;;51256:37;;;;;51237:16;;51421;;;;;;;;;;-1:-1:-1;51421:16:0;51393:44;;51461:9;51447:8;51456:1;51447:11;;;;;;;;:::i;:::-;-1:-1:-1;;51447:23:0;;;:11;;;;;;;;;;:23;51494:27;;:44;;:27;;51511:9;;51494:27;9395:3:1;9391:16;;;;9409:66;9387:89;9375:102;;9502:1;9493:11;;9248:262;51494:27:0;;;;;;;;;;;;;:42;:44::i;:::-;51480:8;51489:1;51480:11;;;;;;;;:::i;:::-;;;;;;:58;;;;;;;;;;;;;51562:14;51548:8;51557:1;51548:11;;;;;;;;:::i;:::-;;;;;;:28;;;;;;;;;;;;;51600:15;51586:8;51595:1;51586:11;;;;;;;;:::i;:::-;-1:-1:-1;;51586:29:0;;;:11;;;;;;;;;;;:29;51632:27;51650:8;51632:17;:27::i;:::-;51625:34;50873:793;-1:-1:-1;;;;;;;;50873:793:0:o;56629:176::-;56711:6;56695:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;56743:54:0::1;-1:-1:-1::0;;56743:15:0;::::1;48336:1;56792:2;56743:15;:54::i;56037:176::-:0;56121:6;56105:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;56153:52:0::1;-1:-1:-1::0;;56153:15:0;::::1;48438:1;56201;56153:15;:52::i;56900:164::-:0;56983:7;56967:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;57009:48:0::1;-1:-1:-1::0;;57009:11:0;::::1;48485:2;57052;57009:11;:48::i;57170:300::-:0;57256:7;57240:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;57294:169:0::1;-1:-1:-1::0;;57294:11:0;::::1;48336:1;48545:2;38049:16;57294:11;:169::i;59216:594::-:0;59356:7;59332:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;;59380:15:::1;59397:16:::0;59417:23:::1;59434:5;59417:16;:23::i;:::-;59379:61;;;;59473:10;59458:25;;:12;:25;59450:50;;;::::0;::::1;::::0;;8920:2:1;59450:50:0::1;::::0;::::1;8902:21:1::0;8959:2;8939:18;;;8932:30;8998:14;8978:18;;;8971:42;9030:18;;59450:50:0::1;8718:336:1::0;59450:50:0::1;59529:274;40686:2;59613:24;;::::0;::::1;:12:::0;:24:::1;:::i;:::-;59612:76;;;;:::i;:::-;48680:21;48545:2;48700:1;48680:21;:::i;:::-;59567:121;;;;:::i;:::-;-1:-1:-1::0;;59529:11:0;::::1;::::0;40686:2:::1;37211:16;59529:11;:274::i;:::-;59510:293:::0;59216:594;-1:-1:-1;;;;;;59216:594:0:o;55415:178::-;55500:6;55484:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;55532:53:0::1;-1:-1:-1::0;;55532:15:0;::::1;48336:1;55581;55532:15;:53::i;56330:179::-:0;56416:6;56400:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;-1:-1:-1;56448:53:0::1;-1:-1:-1::0;;56448:15:0;::::1;48336:1;56497;56448:15;:53::i;58212:198::-:0;58331:16;58307:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;;58380:23:::1;58397:5;58380:16;:23::i;57912:195::-:0;58030:15;58006:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;;58077:23:::1;58094:5;58077:16;:23::i;:::-;-1:-1:-1::0;58061:39:0;57912:195;-1:-1:-1;;;57912:195:0:o;57585:223::-;57703:15;;57679:5;49298:42;-1:-1:-1;;49298:16:0;;37950;49298;:42::i;:::-;;57778:23:::1;57795:5;57778:16;:23::i;:::-;57752:49:::0;;;;-1:-1:-1;57585:223:0;-1:-1:-1;;;57585:223:0:o;42932:139::-;43002:7;43028:36;:8;43002:7;43028:12;:36::i;60554:487::-;60641:15;;;60759:57;-1:-1:-1;;60759:15:0;;48545:2;60812:1;60759:15;:57::i;:::-;60903:20;60922:1;60903:20;;;;;;61011:22;;;-1:-1:-1;60554:487:0;-1:-1:-1;;;60554:487:0:o;13664:615::-;13775:15;;13817:11;13824:4;13817;:11;:::i;:::-;13802:26;;14096:4;14090:11;14084:4;14081:21;14078:66;;;-1:-1:-1;14129:1:0;14078:66;14167:4;14175:1;14167:9;14163:51;;-1:-1:-1;;14192:11:0;;;;;14163:51;-1:-1:-1;;3063:2:0;12830:33;;;12968:17;;;;12954:32;;;13091:17;3151:2;13075:34;;13664:615::o;10169:578::-;10247:7;10271:26;10278:7;10287:9;10271:6;:26::i;:::-;10266:451;;10316:9;10329:35;10347:15;10354:7;10347:6;:15::i;:::-;10339:24;;10329:9;:35::i;:::-;10313:51;;;10381:9;10394:29;10412:9;10404:18;;10394:9;:29::i;:::-;10481:186;;9882:31:1;10481:186:0;;;9870:44:1;9933:66;10037:3;10033:16;;;10029:25;;10015:12;;;10008:47;10085:15;10071:12;;;10064:37;10135:16;;;10131:25;10117:12;;;10110:47;10378:45:0;;-1:-1:-1;10437:17:0;;-1:-1:-1;10173:12:1;;10481:186:0;;;;;;;;;;;;10437:244;;10702:3;10695:11;;;;;;;;;;;:::i;10266:451::-;-1:-1:-1;10733:7:0;;10169:578;-1:-1:-1;10169:578:0:o;23870:374::-;23989:14;24220:11;24225:6;24220:2;:11;:::i;:::-;24219:17;;24235:1;24219:17;:::i;:::-;24175:62;;24183:30;24189:7;24198:6;24206;24183:5;:30::i;:::-;24175:62;;;23870:374;-1:-1:-1;;;;23870:374:0:o;19241:399::-;19380:7;19399:12;19414;19418:7;19414:3;:12::i;:::-;19399:27;;;;19510:12;19514:7;19510:3;:12::i;:::-;19503:4;19487:13;19494:6;19487:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;19483:77;;;-1:-1:-1;;19538:11:0;;;;;19483:77;19577:13;19584:6;19577:4;:13;:::i;:::-;19570:20;;19607:26;19613:7;19607:26;;19622:4;19628;19607:5;:26::i;30343:892::-;30421:15;-1:-1:-1;;7936:15:0;;;;30448:55;;;;;;;11008:2:1;30448:55:0;;;10990:21:1;11047:2;11027:18;;;11020:30;11086:28;11066:18;;;11059:56;11132:18;;30448:55:0;10806:350:1;30448:55:0;30521:16;30529:7;30521;:16::i;:::-;30513:58;;;;;;;11363:2:1;30513:58:0;;;11345:21:1;11402:2;11382:18;;;11375:30;11441:31;11421:18;;;11414:59;11490:18;;30513:58:0;11161:353:1;30513:58:0;30581:12;30596;30600:7;3151:2;18587:23;3544:16;18583:41;;18067:573;30596:12;30581:27;;;;30618:15;30636:12;30640:7;30636:3;:12::i;:::-;30618:30;;;;30659:11;30680:8;30798:4;30792:11;30785:18;;30885:7;30880:3;30877:16;30874:94;;;30925:4;30919;30912:18;30874:94;31095:4;31086:7;31080:4;31071:7;31065:4;31058:5;31047:53;31040:60;;31127:3;31119:36;;;;;;;11721:2:1;31119:36:0;;;11703:21:1;11760:2;11740:18;;;11733:30;11799:22;11779:18;;;11772:50;11839:18;;31119:36:0;11519:344:1;31119:36:0;31176:52;31197:15;31204:7;31197:6;:15::i;:::-;12830:33;3063:2;12830:33;;;;12968:17;;12954:32;;13091:17;;3151:2;13075:34;;12189:936;31176:52;31166:62;30343:892;-1:-1:-1;;;;;;;30343:892:0:o;61265:382::-;61333:12;3151:2;18587:23;;;3544:16;18583:41;61333:12;61417:36;40686:2;18583:41;61417:36;:::i;:::-;61399:54;-1:-1:-1;61512:6:0;61471:37;40686:2;61399:54;61471:37;:::i;:::-;:47;61463:77;;;;;;;12349:2:1;61463:77:0;;;12331:21:1;12388:2;12368:18;;;12361:30;12427:19;12407:18;;;12400:47;12464:18;;61463:77:0;12147:341:1;61463:77:0;61568:15;61558:25;;61550:57;;;;;;;12695:2:1;61550:57:0;;;12677:21:1;12734:2;12714:18;;;12707:30;12773:21;12753:18;;;12746:49;12812:18;;61550:57:0;12493:343:1;34784:780:0;34997:4;34991:11;34848:16;;34876:11;35113:32;35124:8;35140:4;35134:10;;35113;:32::i;:::-;35102:43;;35165:16;35184:13;35188:8;3151:2;18587:23;3544:16;18583:41;;18067:573;35184:13;35165:32;;;;35207:18;35228:19;35238:8;35228:9;:19::i;:::-;35377:21;;;-1:-1:-1;35497:20:0;;35519:4;35493:31;35487:4;35480:45;-1:-1:-1;35384:3:0;34784:780;-1:-1:-1;;34784:780:0:o;22634:890::-;22749:14;22779:6;:11;;22789:1;22779:11;22775:59;;-1:-1:-1;22821:1:0;22806:17;;22775:59;22865:12;22869:7;3151:2;18587:23;3544:16;18583:41;;18067:573;22865:12;22847:30;;:15;;;;:6;:15;:::i;:::-;:30;22843:137;;;22900:68;22916:12;22920:7;22916:3;:12::i;:::-;22900:68;;22930:12;22934:7;3151:2;18587:23;3544:16;18583:41;;18067:573;22930:12;22900:68;;22944:6;22960;22952:15;;22900;:68::i;:::-;22893:76;;;;;;;;;;;:::i;22843:137::-;23007:2;22997:6;:12;;;;22989:50;;;;;;;13043:2:1;22989:50:0;;;13025:21:1;13082:2;13062:18;;;13055:30;13121:27;13101:18;;;13094:55;13166:18;;22989:50:0;12841:349:1;22989:50:0;23120:1;23111:10;;23050:15;23156:12;23160:7;23156:3;:12::i;:::-;23141:27;;;-1:-1:-1;23234:13:0;7410:66;7380:12;;;7359:131;23482:17;;;;23476:24;23472:36;;;-1:-1:-1;;;;;22634:890:0:o;9739:132::-;9813:4;9855:9;9836:28;;:15;9843:7;9836:6;:15::i;:::-;:28;;;;9739:132;-1:-1:-1;;;9739:132:0:o;4754:667::-;4808:13;;4864:2;4849:258;4872:2;4868:1;:6;;;4849:258;;;4892:11;4919:5;:1;4923;4919:5;:::i;:::-;4912:13;;:2;:13;;4892:34;;4949:14;4957:5;4949:7;:14::i;:::-;4940:23;;;;;;4981:1;:7;;4986:2;4981:7;4977:58;;5018:2;5008:12;;;;;4977:58;-1:-1:-1;5076:6:0;;4849:258;;;-1:-1:-1;5170:2:0;5155:260;5178:3;5174:1;:7;;;5155:260;;;5199:11;5226:5;:1;5230;5226:5;:::i;:::-;5219:13;;:2;:13;;5199:34;;5257:14;5265:5;5257:7;:14::i;:::-;5247:24;;;;;;5289:1;:6;;5294:1;5289:6;5285:58;;5326:2;5315:13;;;;;5285:58;-1:-1:-1;5384:6:0;;5155:260;;;;4754:667;;;:::o;16630:573::-;16683:11;;3335:20;3106:2;3151;3335:20;:::i;:::-;17150:23;;;;3544:16;17146:41;;16630:573;-1:-1:-1;;16630:573:0:o;18814:147::-;18867:7;18932:12;18936:7;3151:2;18587:23;3544:16;18583:41;;18067:573;18932:12;18917;18921:7;18917:3;:12::i;:::-;:27;18910:34;;;;18814:147;;;:::o;8609:465::-;8666:8;8690:15;8697:7;8690:6;:15::i;:::-;:31;;8709:12;8690:31;8686:74;;-1:-1:-1;8744:5:0;;8609:465;-1:-1:-1;8609:465:0:o;8686:74::-;8769:12;8784;8788:7;8784:3;:12::i;:::-;9051:4;9045:11;-1:-1:-1;9032:26:0;;8609:465;-1:-1:-1;;;8609:465:0:o;32786:782::-;32898:18;33036:4;33030:11;33123:9;33118:3;33115:18;33112:96;;;33165:4;33159;33152:18;33112:96;;33228:15;33262:9;33257:239;33281:8;:15;33277:1;:19;33257:239;;;33317:15;33335:8;33344:1;33335:11;;;;;;;;:::i;:::-;;;;;;;33317:29;;33388:42;33401:7;33422;33410:9;:19;33388:12;:42::i;:::-;;33459:12;33463:7;3151:2;18587:23;3544:16;18583:41;;18067:573;33459:12;33448:23;;;;;;33303:193;33298:3;;;;;:::i;:::-;;;;33257:239;;;-1:-1:-1;3063:2:0;12954:32;;;13091:17;;3151:2;13075:34;33518:43;12189:936;17790:111;17849:7;17875:14;17881:7;17875:5;:14::i;:::-;:19;;17892:2;17875:19;:::i;21391:741::-;21537:17;21569:9;21582:15;21592:4;21582:9;:15::i;:::-;21566:31;;;21610:9;21623:15;21633:4;21623:9;:15::i;:::-;21607:31;;;21651:9;21664:17;21674:6;21664:9;:17::i;:::-;21648:33;;;21694:9;21707:17;21717:6;21707:9;:17::i;:::-;21760:355;;;14236:34:1;21760:355:0;;;14224:47:1;14301:23;14287:12;;;14280:45;14344:66;14448:3;14444:16;;;14440:25;;14426:12;;;14419:47;14485:17;14518:12;;;14511:24;;;14569:16;;;14565:25;;14551:12;;;14544:47;14621:34;14607:12;;;14600:56;14687:3;14672:13;;;14665:26;14726:16;;;14722:25;;14707:13;;;14700:48;14764:13;;;14757:25;;;;14817:16;;14813:25;;;14798:13;;;14791:48;-1:-1:-1;;13472:3:1;14885:13;;;13460:16;21760:355:0;;;;;;;;;13492:11:1;;;;21760:355:0;;;;;-1:-1:-1;;;;;21391:741:0:o;4231:199::-;4281:14;4318:18;4334:1;4328:2;:7;;;;4318:9;:18::i;:::-;4307:29;;4360:13;;;;;;4372:1;4360:13;4394;4404:2;4394:9;:13::i;:::-;4383:24;;;;4231:199;-1:-1:-1;4231:199:0:o;17409:162::-;17464:7;17562:2;17540:12;17544:7;3151:2;18587:23;3544:16;18583:41;;18067:573;17540:12;17532:26;;:21;;17556:2;17532:26;:::i;:::-;17531:33;;;;:::i;3856:203::-;4029:13;;;;;;;;;;;;;;;;;;3911:11;;3958:4;3950:12;;;;;4029:22;;;;;;:::i;:::-;;;;;;;;3856:203;-1:-1:-1;;;3856:203:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:737::-;1089:6;1097;1105;1158:2;1146:9;1137:7;1133:23;1129:32;1126:52;;;1174:1;1171;1164:12;1126:52;1214:9;1201:23;1243:18;1284:2;1276:6;1273:14;1270:34;;;1300:1;1297;1290:12;1270:34;1323:49;1364:7;1355:6;1344:9;1340:22;1323:49;:::i;:::-;1313:59;;1425:2;1414:9;1410:18;1397:32;1381:48;;1454:2;1444:8;1441:16;1438:36;;;1470:1;1467;1460:12;1438:36;1493:51;1536:7;1525:8;1514:9;1510:24;1493:51;:::i;:::-;1483:61;;1597:2;1586:9;1582:18;1569:32;1553:48;;1626:2;1616:8;1613:16;1610:36;;;1642:1;1639;1632:12;1610:36;;1665:51;1708:7;1697:8;1686:9;1682:24;1665:51;:::i;:::-;1655:61;;;985:737;;;;;:::o;1727:481::-;1768:3;1806:5;1800:12;1833:6;1828:3;1821:19;1858:1;1868:162;1882:6;1879:1;1876:13;1868:162;;;1944:4;2000:13;;;1996:22;;1990:29;1972:11;;;1968:20;;1961:59;1897:12;1868:162;;;1872:3;2075:1;2068:4;2059:6;2054:3;2050:16;2046:27;2039:38;2197:4;2127:66;2122:2;2114:6;2110:15;2106:88;2101:3;2097:98;2093:109;2086:116;;;1727:481;;;;:::o;2213:217::-;2360:2;2349:9;2342:21;2323:4;2380:44;2420:2;2409:9;2405:18;2397:6;2380:44;:::i;2435:163::-;2502:20;;2562:10;2551:22;;2541:33;;2531:61;;2588:1;2585;2578:12;2531:61;2435:163;;;:::o;2603:397::-;2686:6;2694;2702;2710;2763:3;2751:9;2742:7;2738:23;2734:33;2731:53;;;2780:1;2777;2770:12;2731:53;2803:28;2821:9;2803:28;:::i;:::-;2793:38;;2850:37;2883:2;2872:9;2868:18;2850:37;:::i;:::-;2840:47;;2906:37;2939:2;2928:9;2924:18;2906:37;:::i;:::-;2603:397;;;;-1:-1:-1;2896:47:1;;2990:2;2975:18;2962:32;;-1:-1:-1;;2603:397:1:o;3005:292::-;3063:6;3116:2;3104:9;3095:7;3091:23;3087:32;3084:52;;;3132:1;3129;3122:12;3084:52;3171:9;3158:23;3221:26;3214:5;3210:38;3203:5;3200:49;3190:77;;3263:1;3260;3253:12;3775:320;3843:6;3896:2;3884:9;3875:7;3871:23;3867:32;3864:52;;;3912:1;3909;3902:12;3864:52;3952:9;3939:23;3985:18;3977:6;3974:30;3971:50;;;4017:1;4014;4007:12;3971:50;4040:49;4081:7;4072:6;4061:9;4057:22;4040:49;:::i;4292:486::-;4368:6;4376;4429:2;4417:9;4408:7;4404:23;4400:32;4397:52;;;4445:1;4442;4435:12;4397:52;4484:9;4471:23;4534:12;4527:5;4523:24;4516:5;4513:35;4503:63;;4562:1;4559;4552:12;4503:63;4585:5;-1:-1:-1;4641:2:1;4626:18;;4613:32;4668:18;4657:30;;4654:50;;;4700:1;4697;4690:12;4654:50;4723:49;4764:7;4755:6;4744:9;4740:22;4723:49;:::i;:::-;4713:59;;;4292:486;;;;;:::o;4980:180::-;5039:6;5092:2;5080:9;5071:7;5067:23;5063:32;5060:52;;;5108:1;5105;5098:12;5060:52;-1:-1:-1;5131:23:1;;4980:180;-1:-1:-1;4980:180:1:o;5165:305::-;5350:12;5342:6;5338:25;5327:9;5320:44;5400:2;5395;5384:9;5380:18;5373:30;5301:4;5420:44;5460:2;5449:9;5445:18;5437:6;5420:44;:::i;5475:256::-;5541:6;5549;5602:2;5590:9;5581:7;5577:23;5573:32;5570:52;;;5618:1;5615;5608:12;5570:52;5641:28;5659:9;5641:28;:::i;:::-;5631:38;;5688:37;5721:2;5710:9;5706:18;5688:37;:::i;:::-;5678:47;;5475:256;;;;;:::o;5941:284::-;5999:6;6052:2;6040:9;6031:7;6027:23;6023:32;6020:52;;;6068:1;6065;6058:12;6020:52;6107:9;6094:23;6157:18;6150:5;6146:30;6139:5;6136:41;6126:69;;6191:1;6188;6181:12;6921:328;6995:6;7003;7011;7064:2;7052:9;7043:7;7039:23;7035:32;7032:52;;;7080:1;7077;7070:12;7032:52;7103:28;7121:9;7103:28;:::i;:::-;7093:38;;7150:37;7183:2;7172:9;7168:18;7150:37;:::i;:::-;7140:47;;7206:37;7239:2;7228:9;7224:18;7206:37;:::i;:::-;7196:47;;6921:328;;;;;:::o;7710:184::-;7762:77;7759:1;7752:88;7859:4;7856:1;7849:15;7883:4;7880:1;7873:15;7899:125;7964:9;;;7985:10;;;7982:36;;;7998:18;;:::i;8545:168::-;8618:9;;;8649;;8666:15;;;8660:22;;8646:37;8636:71;;8687:18;;:::i;9059:184::-;9111:77;9108:1;9101:88;9208:4;9205:1;9198:15;9232:4;9229:1;9222:15;10420:151;10510:4;10503:12;;;10489;;;10485:31;;10528:14;;10525:40;;;10545:18;;:::i;10576:225::-;10680:4;10659:12;;;10673;;;10655:31;10706:22;;;;10747:24;;;10737:58;;10775:18;;:::i;11868:274::-;11908:1;11934;11924:189;;11969:77;11966:1;11959:88;12070:4;12067:1;12060:15;12098:4;12095:1;12088:15;11924:189;-1:-1:-1;12127:9:1;;11868:274::o;13195:195::-;13234:3;13265:66;13258:5;13255:77;13252:103;;13335:18;;:::i;:::-;-1:-1:-1;13382:1:1;13371:13;;13195:195::o","abiDefinition":[{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"agentSignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"},{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestationData","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"attestationDataLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"}],"name":"attestationDomains","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"}],"name":"attestationKey","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedDestination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedDomains","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedKey","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedNonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedOrigin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"castToAttestation","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes","name":"_guardSignatures","type":"bytes"},{"internalType":"bytes","name":"_notarySignatures","type":"bytes"}],"name":"formatAttestation","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"bytes32","name":"_root","type":"bytes32"}],"name":"formatAttestationData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes","name":"_guardSignatures","type":"bytes"},{"internalType":"bytes","name":"_notarySignatures","type":"bytes"}],"name":"formatAttestationFromViews","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"guardSignature","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"guardSignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"isAttestation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"notarySignature","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"notarySignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetAgentSignatures","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetDestination","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetFirstSignature","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetOrigin","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetRoot","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"setIndex","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"_attestationDomains","type":"uint64"}],"name":"unpackDomains","outputs":[{"internalType":"uint32","name":"","type":"uint32"},{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint96","name":"_attestationKey","type":"uint96"}],"name":"unpackKey","outputs":[{"internalType":"uint64","name":"domains","type":"uint64"},{"internalType":"uint32","name":"nonce","type":"uint32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Attestation methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"agentSignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestationData\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"attestationDataLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"}],\"name\":\"attestationDomains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"}],\"name\":\"attestationKey\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedDestination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedDomains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedKey\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedNonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedOrigin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"castToAttestation\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_guardSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_notarySignatures\",\"type\":\"bytes\"}],\"name\":\"formatAttestation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"formatAttestationData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_guardSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_notarySignatures\",\"type\":\"bytes\"}],\"name\":\"formatAttestationFromViews\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"guardSignature\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"guardSignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"isAttestation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"notarySignature\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"notarySignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetAgentSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetDestination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetFirstSignature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_attestationDomains\",\"type\":\"uint64\"}],\"name\":\"unpackDomains\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_attestationKey\",\"type\":\"uint96\"}],\"name\":\"unpackKey\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"domains\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Attestation methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"AttestationHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0xc2ab2be19882fab6ed5fa1d1248163ddd7c9abaecbc54b83014aa2fbbfe57314\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2749989ad204420aee57301fb6fedfb2e29204459b29725f7562ddc8386f680d\",\"dweb:/ipfs/Qma6TQMtxEUu1uvbaeX6PP1ZPcpLiPEwr9cDYyzPPhxXWa\"]}},\"version\":1}"},"hashes":{"agentSignatures(uint40,bytes)":"f24caf61","attestationData(uint40,bytes)":"9ffb971e","attestationDataLength()":"a104a5e5","attestationDomains(uint32,uint32)":"65dfb428","attestationKey(uint32,uint32,uint32)":"9f668e20","attestedDestination(uint40,bytes)":"3b830f3b","attestedDomains(uint40,bytes)":"c231bd8f","attestedKey(uint40,bytes)":"79ce92a9","attestedNonce(uint40,bytes)":"8b445f51","attestedOrigin(uint40,bytes)":"badad7db","attestedRoot(uint40,bytes)":"91eedc1d","castToAttestation(uint40,bytes)":"c2e19ed2","formatAttestation(bytes,bytes,bytes)":"036227a2","formatAttestationData(uint32,uint32,uint32,bytes32)":"2951eae3","formatAttestationFromViews(bytes,bytes,bytes)":"794dd214","guardSignature(uint40,bytes)":"4a0cfe0e","guardSignatures(uint40,bytes)":"dc1e976d","isAttestation(bytes)":"3ae7034d","notarySignature(uint40,bytes)":"a43aa286","notarySignatures(uint40,bytes)":"cbe9d784","offsetAgentSignatures()":"ce533592","offsetDestination()":"d2c4428a","offsetFirstSignature()":"97d91f1a","offsetNonce()":"569e1eaf","offsetOrigin()":"320bfc44","offsetRoot()":"5b42242d","setIndex(uint256)":"40a5737f","unpackDomains(uint64)":"7214101b","unpackKey(uint96)":"308514be"}},"solidity/AttestationHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b208ccdc5e9d75f1a63da44c7a83a614f682c82490eaba5ec38855f8900a280564736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b208ccdc5e9d75f1a63da44c7a83a614f682c82490eaba5ec38855f8900a280564736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/**\n * @dev The goal of this library is to assign a type for every bytes29 memory pointer\n * and enforce strict type checking for every bytes29 operation. This will prevent\n * a misuse of libraries, i.e. using Attestation functions on a Report pointer.\n */\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"40287:7148:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;40287:7148:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"40287:7148:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Call payload memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Call payload memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0xc2ab2be19882fab6ed5fa1d1248163ddd7c9abaecbc54b83014aa2fbbfe57314\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2749989ad204420aee57301fb6fedfb2e29204459b29725f7562ddc8386f680d\",\"dweb:/ipfs/Qma6TQMtxEUu1uvbaeX6PP1ZPcpLiPEwr9cDYyzPPhxXWa\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:SynapseTypes":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204aee4a6b37c6af87f9819463d669c53693a74aff75cd5b48d242170a851fd03c64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212204aee4a6b37c6af87f9819463d669c53693a74aff75cd5b48d242170a851fd03c64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/**\n * @dev The goal of this library is to assign a type for every bytes29 memory pointer\n * and enforce strict type checking for every bytes29 operation. This will prevent\n * a misuse of libraries, i.e. using Attestation functions on a Report pointer.\n */\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35825:4460:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35825:4460:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35825:4460:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"The goal of this library is to assign a type for every bytes29 memory pointer and enforce strict type checking for every bytes29 operation. This will prevent a misuse of libraries, i.e. using Attestation functions on a Report pointer.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"The goal of this library is to assign a type for every bytes29 memory pointer and enforce strict type checking for every bytes29 operation. This will prevent a misuse of libraries, i.e. using Attestation functions on a Report pointer.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"SynapseTypes\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0xc2ab2be19882fab6ed5fa1d1248163ddd7c9abaecbc54b83014aa2fbbfe57314\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2749989ad204420aee57301fb6fedfb2e29204459b29725f7562ddc8386f680d\",\"dweb:/ipfs/Qma6TQMtxEUu1uvbaeX6PP1ZPcpLiPEwr9cDYyzPPhxXWa\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220a581a65672c6517980835fe9a38549634cc9d743d493792bfac43c59aa7ad80264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220a581a65672c6517980835fe9a38549634cc9d743d493792bfac43c59aa7ad80264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n/**\n * @dev The goal of this library is to assign a type for every bytes29 memory pointer\n * and enforce strict type checking for every bytes29 operation. This will prevent\n * a misuse of libraries, i.e. using Attestation functions on a Report pointer.\n */\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"58:35508:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;58:35508:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"58:35508:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2984:38;;3020:2;2984:38;;;;;168:25:1;;;156:2;141:18;2984:38:0;;;;;;;;3241:46;;3151:2;3241:46;;3378:57;;;:::i;3299:56::-;;;:::i;3501:59::-;;3544:16;3501:59;;3071:37;;3106:2;3071:37;;2572:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2572:94:0;204:258:1;3378:57:0;3063:2;3335:20;3063:2;3151;3335:20;:::i;:::-;3415;;;;:::i;:::-;3378:57;:::o;3299:56::-;3335:20;3106:2;3151;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0xc2ab2be19882fab6ed5fa1d1248163ddd7c9abaecbc54b83014aa2fbbfe57314\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2749989ad204420aee57301fb6fedfb2e29204459b29725f7562ddc8386f680d\",\"dweb:/ipfs/Qma6TQMtxEUu1uvbaeX6PP1ZPcpLiPEwr9cDYyzPPhxXWa\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}