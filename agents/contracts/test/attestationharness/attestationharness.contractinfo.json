{"solidity/AttestationHarness.t.sol:Attestation":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b3a5cda562bd3c850eea4a3eddea7cdd22ea7399cbe3c887fecb12c9b0e3b09a64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b3a5cda562bd3c850eea4a3eddea7cdd22ea7399cbe3c887fecb12c9b0e3b09a64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Returns an array of properly typed bytes29 pointers for\n     * every signature payload from the given array.\n     */\n    function castToSignatures(bytes[] memory _signaturePayloads)\n        internal\n        pure\n        returns (bytes29[] memory signatureViews)\n    {\n        uint256 length = _signaturePayloads.length;\n        signatureViews = new bytes29[](length);\n        for (uint256 i = 0; i \u003c length; ++i) {\n            signatureViews[i] = castToSignature(_signaturePayloads[i]);\n        }\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSignatures);\n        uint8 notarySigs = _amountSignatures(_notarySignatures);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _data.castToRawBytes();\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSignatures.castToRawBytes();\n        allViews[3] = _notarySignatures.castToRawBytes();\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes memory _signatures) private pure returns (uint8 amount) {\n        uint256 _amount = _signatures.length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == _signatures.length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"47281:13182:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;47281:13182:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"47281:13182:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"AttestationData memory layout [000 .. 004): origin         uint32   4 bytes [004 .. 008): destination    uint32   4 bytes [008 .. 012): nonce          uint32   4 bytes [012 .. 044): root           bytes32 32 bytes      Attestation memory layout [000 .. 044): attData        bytes   44 bytes (see above) [044 .. 045): G = guardSigs  uint8    1 byte [045 .. 046): N = notarySigs uint8    1 byte [046 .. 111): guardSig[0]    bytes   65 bytes      .. [AAA .. BBB): guardSig[G-1]  bytes   65 bytes [BBB .. CCC): notarySig[0]   bytes   65 bytes      .. [DDD .. END): notarySig[N-1] bytes   65 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"AttestationData memory layout [000 .. 004): origin         uint32   4 bytes [004 .. 008): destination    uint32   4 bytes [008 .. 012): nonce          uint32   4 bytes [012 .. 044): root           bytes32 32 bytes      Attestation memory layout [000 .. 044): attData        bytes   44 bytes (see above) [044 .. 045): G = guardSigs  uint8    1 byte [045 .. 046): N = notarySigs uint8    1 byte [046 .. 111): guardSig[0]    bytes   65 bytes      .. [AAA .. BBB): guardSig[G-1]  bytes   65 bytes [BBB .. CCC): notarySig[0]   bytes   65 bytes      .. [DDD .. END): notarySig[N-1] bytes   65 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"Attestation\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x28471e17ecfc213ffe5847f2d3237838a0fd73739ec8753d82da3603c271a78c\",\"urls\":[\"bzz-raw://d1d60bf8ec7bdfc98fa78101d6f437e409b0dc716d4cb5565206050246949147\",\"dweb:/ipfs/QmV4MYGNnQw78JzFX5oTY6rxAanRduoUgwfpFZW9j3eXFB\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:AttestationHarness":{"code":"0x608060405234801561001057600080fd5b50611d72806100206000396000f3fe608060405234801561001057600080fd5b50600436106101ae5760003560e01c806397d91f1a116100ee578063c231bd8f11610097578063ce53359211610071578063ce5335921461033f578063d2c4428a146103b7578063dc1e976d146103be578063f24caf61146103d157600080fd5b8063c231bd8f1461036c578063c2e19ed21461037f578063cbe9d7841461039257600080fd5b8063a104a5e5116100c8578063a104a5e51461033f578063a43aa28614610346578063badad7db1461035957600080fd5b806397d91f1a146103115780639f668e20146103195780639ffb971e1461032c57600080fd5b80634a0cfe0e1161015b57806365dfb4281161013557806365dfb4281461028f57806379ce92a9146102bb5780638b445f51146102eb57806391eedc1d146102fe57600080fd5b80634a0cfe0e14610260578063569e1eaf146102815780635b42242d1461028857600080fd5b80633ae7034d1161018c5780633ae7034d146102005780633b830f3b1461022357806340a5737f1461024b57600080fd5b8063036227a2146101b35780632951eae3146101dc578063320bfc44146101ef575b600080fd5b6101c66101c136600461196b565b6103fe565b6040516101d39190611a57565b60405180910390f35b6101c66101ea366004611a83565b610415565b60005b6040519081526020016101d3565b61021361020e366004611ace565b61047c565b60405190151581526020016101d3565b610236610231366004611b03565b61049b565b60405163ffffffff90911681526020016101d3565b61025e610259366004611b5d565b600055565b005b61027361026e366004611b03565b6104b5565b6040516101d3929190611b76565b60086101f2565b600c6101f2565b6102a261029d366004611b96565b61050c565b60405167ffffffffffffffff90911681526020016101d3565b6102ce6102c9366004611b03565b61052a565b6040516bffffffffffffffffffffffff90911681526020016101d3565b6102366102f9366004611b03565b610544565b6101f261030c366004611b03565b61055e565b6101f2610578565b6102ce610327366004611bc9565b61058b565b61027361033a366004611b03565b6105bd565b602c6101f2565b610273610354366004611b03565b6105da565b610236610367366004611b03565b610605565b6102a261037a366004611b03565b61061f565b61027361038d366004611b03565b610639565b6103a56103a0366004611b03565b610648565b60405160ff90911681526020016101d3565b60046101f2565b6103a56103cc366004611b03565b610662565b6103e46103df366004611b03565b61067c565b6040805160ff9384168152929091166020830152016101d3565b606061040b8484846106a2565b90505b9392505050565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e087811b8216602084015286811b8216602484015285901b166028820152602c80820184905282518083039091018152604c9091019091525b949350505050565b600061049561048a83610812565b62ffffff1916610823565b92915050565b600061040e6104aa83856108b9565b62ffffff19166108dd565b6000606060006104e06000546104d487876108b990919063ffffffff16565b62ffffff191690610908565b90506104f162ffffff1982166109df565b61050062ffffff198316610a03565b92509250509250929050565b600067ffffffff00000000602084901b1663ffffffff83161761040e565b600061040e61053983856108b9565b62ffffff1916610a56565b600061040e61055383856108b9565b62ffffff1916610a82565b600061040e61056d83856108b9565b62ffffff1916610aae565b6000610586602c6002611c3b565b905090565b600063ffffffff8216602084901b67ffffffff0000000016604086901b6bffffffff000000000000000016171761040b565b60006060816104e06105cf85876108b9565b62ffffff1916610ada565b6000606060006104e06000546105f987876108b990919063ffffffff16565b62ffffff191690610b0c565b600061040e61061483856108b9565b62ffffff1916610bf1565b600061040e61062e83856108b9565b62ffffff1916610c1d565b6000606060006104e084610812565b600061040e61065783856108b9565b62ffffff1916610c49565b600061040e61067183856108b9565b62ffffff1916610c6b565b60008061069761068c84866108b9565b62ffffff1916610c95565b915091509250929050565b606060006106af84610cc3565b905060006106bc84610cc3565b60408051600480825260a0820190925291925061ff00600885901b1660ff84161791600091602082016080803683370190505090506106fa88610db5565b8160008151811061070d5761070d611c4e565b62ffffff199092166020928302919091018201526040516107739161075f9185910160f09190911b7fffff00000000000000000000000000000000000000000000000000000000000016815260020190565b604051602081830303815290604052610db5565b8160018151811061078657610786611c4e565b62ffffff19909216602092830291909101909101526107a487610db5565b816002815181106107b7576107b7611c4e565b62ffffff19909216602092830291909101909101526107d586610db5565b816003815181106107e8576107e8611c4e565b62ffffff199092166020928302919091019091015261080681610dc1565b98975050505050505050565b6000610495826401010000006108b9565b6000601882901c6bffffffffffffffffffffffff16610844602c6002611c3b565b8110156108545750600092915050565b60008061086085610e20565b60ff918216935016905060006108768284611c3b565b90508060000361088c5750600095945050505050565b610897604182611c7d565b6108a3602c6002611c3b565b6108ad9190611c3b565b90931495945050505050565b8151600090602084016108d464ffffffffff85168284610e4b565b95945050505050565b6000816108f562ffffff198216640101000000610e92565b5061040e62ffffff198416600480610fac565b60008261092062ffffff198216640101000000610e92565b50600061092c85610e20565b5090508060ff1684106109a0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e6765000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6108d46109ae604186611c7d565b6109ba602c6002611c3b565b6109c49190611c3b565b62ffffff1987169060416301000000610fdc565b5092915050565b60008060606109ef816018611c3b565b6109f99190611c3b565b9290921c92915050565b6060600080610a208460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506040519150819250610a458483602001611047565b508181016020016040529052919050565b600081610a6e62ffffff198216640101000000610e92565b5061040e62ffffff1984166000600c610fac565b600081610a9a62ffffff198216640101000000610e92565b5061040e62ffffff19841660086004610fac565b600081610ac662ffffff198216640101000000610e92565b5061040e62ffffff198416600c602061122e565b600081610af262ffffff198216640101000000610e92565b5061040e62ffffff1984166000602c640101010000610fdc565b600082610b2462ffffff198216640101000000610e92565b50600080610b3186610e20565b915091508060ff168510610ba1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e676500000000000000000000000000000000000000006044820152606401610997565b610be76041610bb360ff851688611c3b565b610bbd9190611c7d565b610bc9602c6002611c3b565b610bd39190611c3b565b62ffffff1988169060416301000000610fdc565b9695505050505050565b600081610c0962ffffff198216640101000000610e92565b5061040e62ffffff19841660006004610fac565b600081610c3562ffffff198216640101000000610e92565b5061040e62ffffff19841660006008610fac565b600081610c6162ffffff198216640101000000610e92565b5061047483610e20565b600081610c8362ffffff198216640101000000610e92565b50610c8d83610e20565b509392505050565b60008082610cae62ffffff198216640101000000610e92565b50610cb884610e20565b909590945092505050565b60008060418351610cd49190611c94565b8351909150610ce4604183611c7d565b14610d4b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f217369676e6174757265734c656e6774680000000000000000000000000000006044820152606401610997565b60ff8110610495576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f546f6f206d616e79207369676e617475726573000000000000000000000000006044820152606401610997565b600061049582826108b9565b6040516060906000610dd684602084016113dc565b90506000610df28260181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610e0d83611476565b9184525082016020016040525092915050565b60008080610e3762ffffff198516602c6002610fac565b60ff600882901c8116969116945092505050565b600080610e588385611c3b565b9050604051811115610e68575060005b80600003610e7d5762ffffff1991505061040e565b5050606092831b9190911790911b1760181b90565b6000610e9e838361148c565b610fa5576000610ebc610eb0856109df565b64ffffffffff166114ae565b9150506000610ed18464ffffffffff166114ae565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109979190611a57565b5090919050565b6000610fb9826020611ccf565b610fc4906008611ce8565b60ff16610fd285858561122e565b901c949350505050565b600080610fe886611598565b6bffffffffffffffffffffffff169050611001866115bf565b8461100c8784611c3b565b6110169190611c3b565b11156110295762ffffff19915050610474565b6110338582611c3b565b9050610be78364ffffffffff168286610e4b565b600062ffffff19808416036110b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610997565b6110c1836115f8565b611127576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610997565b60006111418460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061115c85611598565b6bffffffffffffffffffffffff1690506000806040519150858211156111825760206060fd5b8386858560045afa9050806111f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610997565b6112236111ff886109df565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b60008160ff166000036112435750600061040e565b61125b8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661127660ff841685611c3b565b11156112f9576112c661128885611598565b6bffffffffffffffffffffffff166112ae8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611634565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109979190611a57565b60208260ff161115611367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610997565b60088202600061137686611598565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b6000604051828111156113ef5760206060fd5b506000805b845181101561146657600085828151811061141157611411611c4e565b6020026020010151905061142781848701611047565b506114408160181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff168301925050808061145e90611d04565b9150506113f4565b50606083901b811760181b610474565b6000611481826117c4565b610495906020611c7d565b60008164ffffffffff1661149f846109df565b64ffffffffff16149392505050565b600080601f5b600f8160ff1611156115215760006114cd826008611ce8565b60ff1685901c90506114de81611803565b61ffff16841793508160ff166010146114f957601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016114b4565b50600f5b60ff8160ff16101561159257600061153e826008611ce8565b60ff1685901c905061154f81611803565b61ffff16831792508160ff1660001461156a57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611525565b50915091565b6000806115a760606018611c3b565b9290921c6bffffffffffffffffffffffff1692915050565b60006115d98260181c6bffffffffffffffffffffffff1690565b6115e283611598565b016bffffffffffffffffffffffff169050919050565b6000611603826109df565b64ffffffffff1664ffffffffff0361161d57506000919050565b6000611628836115bf565b60405110199392505050565b60606000611641866114ae565b915050600061164f866114ae565b915050600061165d866114ae565b915050600061166b866114ae565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600060206117e08360181c6bffffffffffffffffffffffff1690565b6117f9906bffffffffffffffffffffffff16601f611c3b565b6104959190611c94565b600061181560048360ff16901c611835565b60ff1661ffff919091161760081b61182c82611835565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f8416918290811061188257611882611c4e565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126118d157600080fd5b813567ffffffffffffffff808211156118ec576118ec611891565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561193257611932611891565b8160405283815286602085880101111561194b57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060006060848603121561198057600080fd5b833567ffffffffffffffff8082111561199857600080fd5b6119a4878388016118c0565b945060208601359150808211156119ba57600080fd5b6119c6878388016118c0565b935060408601359150808211156119dc57600080fd5b506119e9868287016118c0565b9150509250925092565b6000815180845260005b81811015611a19576020818501810151868301820152016119fd565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b60208152600061040e60208301846119f3565b803563ffffffff81168114611a7e57600080fd5b919050565b60008060008060808587031215611a9957600080fd5b611aa285611a6a565b9350611ab060208601611a6a565b9250611abe60408601611a6a565b9396929550929360600135925050565b600060208284031215611ae057600080fd5b813567ffffffffffffffff811115611af757600080fd5b610474848285016118c0565b60008060408385031215611b1657600080fd5b823564ffffffffff81168114611b2b57600080fd5b9150602083013567ffffffffffffffff811115611b4757600080fd5b611b53858286016118c0565b9150509250929050565b600060208284031215611b6f57600080fd5b5035919050565b64ffffffffff8316815260406020820152600061040b60408301846119f3565b60008060408385031215611ba957600080fd5b611bb283611a6a565b9150611bc060208401611a6a565b90509250929050565b600080600060608486031215611bde57600080fd5b611be784611a6a565b9250611bf560208501611a6a565b9150611c0360408501611a6a565b90509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561049557610495611c0c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b808202811582820484141761049557610495611c0c565b600082611cca577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60ff828116828216039081111561049557610495611c0c565b60ff81811683821602908116908181146109d8576109d8611c0c565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611d3557611d35611c0c565b506001019056fea2646970667358221220a4af5d7487275ed170b0735b512787d73f1cb74d41c65e9c414a31c0d03fae7d64736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106101ae5760003560e01c806397d91f1a116100ee578063c231bd8f11610097578063ce53359211610071578063ce5335921461033f578063d2c4428a146103b7578063dc1e976d146103be578063f24caf61146103d157600080fd5b8063c231bd8f1461036c578063c2e19ed21461037f578063cbe9d7841461039257600080fd5b8063a104a5e5116100c8578063a104a5e51461033f578063a43aa28614610346578063badad7db1461035957600080fd5b806397d91f1a146103115780639f668e20146103195780639ffb971e1461032c57600080fd5b80634a0cfe0e1161015b57806365dfb4281161013557806365dfb4281461028f57806379ce92a9146102bb5780638b445f51146102eb57806391eedc1d146102fe57600080fd5b80634a0cfe0e14610260578063569e1eaf146102815780635b42242d1461028857600080fd5b80633ae7034d1161018c5780633ae7034d146102005780633b830f3b1461022357806340a5737f1461024b57600080fd5b8063036227a2146101b35780632951eae3146101dc578063320bfc44146101ef575b600080fd5b6101c66101c136600461196b565b6103fe565b6040516101d39190611a57565b60405180910390f35b6101c66101ea366004611a83565b610415565b60005b6040519081526020016101d3565b61021361020e366004611ace565b61047c565b60405190151581526020016101d3565b610236610231366004611b03565b61049b565b60405163ffffffff90911681526020016101d3565b61025e610259366004611b5d565b600055565b005b61027361026e366004611b03565b6104b5565b6040516101d3929190611b76565b60086101f2565b600c6101f2565b6102a261029d366004611b96565b61050c565b60405167ffffffffffffffff90911681526020016101d3565b6102ce6102c9366004611b03565b61052a565b6040516bffffffffffffffffffffffff90911681526020016101d3565b6102366102f9366004611b03565b610544565b6101f261030c366004611b03565b61055e565b6101f2610578565b6102ce610327366004611bc9565b61058b565b61027361033a366004611b03565b6105bd565b602c6101f2565b610273610354366004611b03565b6105da565b610236610367366004611b03565b610605565b6102a261037a366004611b03565b61061f565b61027361038d366004611b03565b610639565b6103a56103a0366004611b03565b610648565b60405160ff90911681526020016101d3565b60046101f2565b6103a56103cc366004611b03565b610662565b6103e46103df366004611b03565b61067c565b6040805160ff9384168152929091166020830152016101d3565b606061040b8484846106a2565b90505b9392505050565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e087811b8216602084015286811b8216602484015285901b166028820152602c80820184905282518083039091018152604c9091019091525b949350505050565b600061049561048a83610812565b62ffffff1916610823565b92915050565b600061040e6104aa83856108b9565b62ffffff19166108dd565b6000606060006104e06000546104d487876108b990919063ffffffff16565b62ffffff191690610908565b90506104f162ffffff1982166109df565b61050062ffffff198316610a03565b92509250509250929050565b600067ffffffff00000000602084901b1663ffffffff83161761040e565b600061040e61053983856108b9565b62ffffff1916610a56565b600061040e61055383856108b9565b62ffffff1916610a82565b600061040e61056d83856108b9565b62ffffff1916610aae565b6000610586602c6002611c3b565b905090565b600063ffffffff8216602084901b67ffffffff0000000016604086901b6bffffffff000000000000000016171761040b565b60006060816104e06105cf85876108b9565b62ffffff1916610ada565b6000606060006104e06000546105f987876108b990919063ffffffff16565b62ffffff191690610b0c565b600061040e61061483856108b9565b62ffffff1916610bf1565b600061040e61062e83856108b9565b62ffffff1916610c1d565b6000606060006104e084610812565b600061040e61065783856108b9565b62ffffff1916610c49565b600061040e61067183856108b9565b62ffffff1916610c6b565b60008061069761068c84866108b9565b62ffffff1916610c95565b915091509250929050565b606060006106af84610cc3565b905060006106bc84610cc3565b60408051600480825260a0820190925291925061ff00600885901b1660ff84161791600091602082016080803683370190505090506106fa88610db5565b8160008151811061070d5761070d611c4e565b62ffffff199092166020928302919091018201526040516107739161075f9185910160f09190911b7fffff00000000000000000000000000000000000000000000000000000000000016815260020190565b604051602081830303815290604052610db5565b8160018151811061078657610786611c4e565b62ffffff19909216602092830291909101909101526107a487610db5565b816002815181106107b7576107b7611c4e565b62ffffff19909216602092830291909101909101526107d586610db5565b816003815181106107e8576107e8611c4e565b62ffffff199092166020928302919091019091015261080681610dc1565b98975050505050505050565b6000610495826401010000006108b9565b6000601882901c6bffffffffffffffffffffffff16610844602c6002611c3b565b8110156108545750600092915050565b60008061086085610e20565b60ff918216935016905060006108768284611c3b565b90508060000361088c5750600095945050505050565b610897604182611c7d565b6108a3602c6002611c3b565b6108ad9190611c3b565b90931495945050505050565b8151600090602084016108d464ffffffffff85168284610e4b565b95945050505050565b6000816108f562ffffff198216640101000000610e92565b5061040e62ffffff198416600480610fac565b60008261092062ffffff198216640101000000610e92565b50600061092c85610e20565b5090508060ff1684106109a0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e6765000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6108d46109ae604186611c7d565b6109ba602c6002611c3b565b6109c49190611c3b565b62ffffff1987169060416301000000610fdc565b5092915050565b60008060606109ef816018611c3b565b6109f99190611c3b565b9290921c92915050565b6060600080610a208460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506040519150819250610a458483602001611047565b508181016020016040529052919050565b600081610a6e62ffffff198216640101000000610e92565b5061040e62ffffff1984166000600c610fac565b600081610a9a62ffffff198216640101000000610e92565b5061040e62ffffff19841660086004610fac565b600081610ac662ffffff198216640101000000610e92565b5061040e62ffffff198416600c602061122e565b600081610af262ffffff198216640101000000610e92565b5061040e62ffffff1984166000602c640101010000610fdc565b600082610b2462ffffff198216640101000000610e92565b50600080610b3186610e20565b915091508060ff168510610ba1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e676500000000000000000000000000000000000000006044820152606401610997565b610be76041610bb360ff851688611c3b565b610bbd9190611c7d565b610bc9602c6002611c3b565b610bd39190611c3b565b62ffffff1988169060416301000000610fdc565b9695505050505050565b600081610c0962ffffff198216640101000000610e92565b5061040e62ffffff19841660006004610fac565b600081610c3562ffffff198216640101000000610e92565b5061040e62ffffff19841660006008610fac565b600081610c6162ffffff198216640101000000610e92565b5061047483610e20565b600081610c8362ffffff198216640101000000610e92565b50610c8d83610e20565b509392505050565b60008082610cae62ffffff198216640101000000610e92565b50610cb884610e20565b909590945092505050565b60008060418351610cd49190611c94565b8351909150610ce4604183611c7d565b14610d4b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f217369676e6174757265734c656e6774680000000000000000000000000000006044820152606401610997565b60ff8110610495576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f546f6f206d616e79207369676e617475726573000000000000000000000000006044820152606401610997565b600061049582826108b9565b6040516060906000610dd684602084016113dc565b90506000610df28260181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610e0d83611476565b9184525082016020016040525092915050565b60008080610e3762ffffff198516602c6002610fac565b60ff600882901c8116969116945092505050565b600080610e588385611c3b565b9050604051811115610e68575060005b80600003610e7d5762ffffff1991505061040e565b5050606092831b9190911790911b1760181b90565b6000610e9e838361148c565b610fa5576000610ebc610eb0856109df565b64ffffffffff166114ae565b9150506000610ed18464ffffffffff166114ae565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109979190611a57565b5090919050565b6000610fb9826020611ccf565b610fc4906008611ce8565b60ff16610fd285858561122e565b901c949350505050565b600080610fe886611598565b6bffffffffffffffffffffffff169050611001866115bf565b8461100c8784611c3b565b6110169190611c3b565b11156110295762ffffff19915050610474565b6110338582611c3b565b9050610be78364ffffffffff168286610e4b565b600062ffffff19808416036110b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610997565b6110c1836115f8565b611127576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610997565b60006111418460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061115c85611598565b6bffffffffffffffffffffffff1690506000806040519150858211156111825760206060fd5b8386858560045afa9050806111f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610997565b6112236111ff886109df565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b60008160ff166000036112435750600061040e565b61125b8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661127660ff841685611c3b565b11156112f9576112c661128885611598565b6bffffffffffffffffffffffff166112ae8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611634565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109979190611a57565b60208260ff161115611367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610997565b60088202600061137686611598565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b6000604051828111156113ef5760206060fd5b506000805b845181101561146657600085828151811061141157611411611c4e565b6020026020010151905061142781848701611047565b506114408160181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff168301925050808061145e90611d04565b9150506113f4565b50606083901b811760181b610474565b6000611481826117c4565b610495906020611c7d565b60008164ffffffffff1661149f846109df565b64ffffffffff16149392505050565b600080601f5b600f8160ff1611156115215760006114cd826008611ce8565b60ff1685901c90506114de81611803565b61ffff16841793508160ff166010146114f957601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016114b4565b50600f5b60ff8160ff16101561159257600061153e826008611ce8565b60ff1685901c905061154f81611803565b61ffff16831792508160ff1660001461156a57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611525565b50915091565b6000806115a760606018611c3b565b9290921c6bffffffffffffffffffffffff1692915050565b60006115d98260181c6bffffffffffffffffffffffff1690565b6115e283611598565b016bffffffffffffffffffffffff169050919050565b6000611603826109df565b64ffffffffff1664ffffffffff0361161d57506000919050565b6000611628836115bf565b60405110199392505050565b60606000611641866114ae565b915050600061164f866114ae565b915050600061165d866114ae565b915050600061166b866114ae565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600060206117e08360181c6bffffffffffffffffffffffff1690565b6117f9906bffffffffffffffffffffffff16601f611c3b565b6104959190611c94565b600061181560048360ff16901c611835565b60ff1661ffff919091161760081b61182c82611835565b60ff1617919050565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f8416918290811061188257611882611c4e565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126118d157600080fd5b813567ffffffffffffffff808211156118ec576118ec611891565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561193257611932611891565b8160405283815286602085880101111561194b57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060006060848603121561198057600080fd5b833567ffffffffffffffff8082111561199857600080fd5b6119a4878388016118c0565b945060208601359150808211156119ba57600080fd5b6119c6878388016118c0565b935060408601359150808211156119dc57600080fd5b506119e9868287016118c0565b9150509250925092565b6000815180845260005b81811015611a19576020818501810151868301820152016119fd565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b60208152600061040e60208301846119f3565b803563ffffffff81168114611a7e57600080fd5b919050565b60008060008060808587031215611a9957600080fd5b611aa285611a6a565b9350611ab060208601611a6a565b9250611abe60408601611a6a565b9396929550929360600135925050565b600060208284031215611ae057600080fd5b813567ffffffffffffffff811115611af757600080fd5b610474848285016118c0565b60008060408385031215611b1657600080fd5b823564ffffffffff81168114611b2b57600080fd5b9150602083013567ffffffffffffffff811115611b4757600080fd5b611b53858286016118c0565b9150509250929050565b600060208284031215611b6f57600080fd5b5035919050565b64ffffffffff8316815260406020820152600061040b60408301846119f3565b60008060408385031215611ba957600080fd5b611bb283611a6a565b9150611bc060208401611a6a565b90509250929050565b600080600060608486031215611bde57600080fd5b611be784611a6a565b9250611bf560208501611a6a565b9150611c0360408501611a6a565b90509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561049557610495611c0c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b808202811582820484141761049557610495611c0c565b600082611cca577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60ff828116828216039081111561049557610495611c0c565b60ff81811683821602908116908181146109d8576109d8611c0c565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611d3557611d35611c0c565b506001019056fea2646970667358221220a4af5d7487275ed170b0735b512787d73f1cb74d41c65e9c414a31c0d03fae7d64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Returns an array of properly typed bytes29 pointers for\n     * every signature payload from the given array.\n     */\n    function castToSignatures(bytes[] memory _signaturePayloads)\n        internal\n        pure\n        returns (bytes29[] memory signatureViews)\n    {\n        uint256 length = _signaturePayloads.length;\n        signatureViews = new bytes29[](length);\n        for (uint256 i = 0; i \u003c length; ++i) {\n            signatureViews[i] = castToSignature(_signaturePayloads[i]);\n        }\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSignatures);\n        uint8 notarySigs = _amountSignatures(_notarySignatures);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _data.castToRawBytes();\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSignatures.castToRawBytes();\n        allViews[3] = _notarySignatures.castToRawBytes();\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes memory _signatures) private pure returns (uint8 amount) {\n        uint256 _amount = _signatures.length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == _signatures.length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"60544:6522:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"60544:6522:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;64765:272;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;65043:266;;;;;;:::i;:::-;;:::i;66382:103::-;66427:7;66382:103;;;3151:25:1;;;3139:2;3124:18;66382:103:0;3005:177:1;64036:141:0;;;;;;:::i;:::-;;:::i;:::-;;;3677:14:1;;3670:22;3652:41;;3640:2;3625:18;64036:141:0;3512:187:1;62747:160:0;;;;;;:::i;:::-;;:::i;:::-;;;4369:10:1;4357:23;;;4339:42;;4327:2;4312:18;62747:160:0;4195:192:1;60755:81:0;;;;;;:::i;:::-;60807:14;:22;60755:81;;;62051:263;;;;;;:::i;:::-;;:::i;:::-;;;;;;;;:::i;66610:101::-;48282:1;66610:101;;66717:99;48329:2;66717:99;;65315:171;;;;;;:::i;:::-;;:::i;:::-;;;5322:18:1;5310:31;;;5292:50;;5280:2;5265:18;65315:171:0;5148:200:1;63225:144:0;;;;;;:::i;:::-;;:::i;:::-;;;5527:26:1;5515:39;;;5497:58;;5485:2;5470:18;63225:144:0;5353:208:1;62913:148:0;;;;;;:::i;:::-;;:::i;63375:147::-;;;;;;:::i;:::-;;:::i;66944:120::-;;;:::i;65492:216::-;;;;;;:::i;:::-;;:::i;61794:251::-;;;;;;:::i;:::-;;:::i;66254:122::-;48389:2;66254:122;;62320:265;;;;;;:::i;:::-;;:::i;62591:150::-;;;;;;:::i;:::-;;:::i;63067:152::-;;;;;;:::i;:::-;;:::i;61382:406::-;;;;;;:::i;:::-;;:::i;63877:153::-;;;;;;:::i;:::-;;:::i;:::-;;;6253:4:1;6241:17;;;6223:36;;6211:2;6196:18;63877:153:0;6081:184:1;66491:113:0;48234:1;66491:113;;63720:151;;;;;;:::i;:::-;;:::i;63528:186::-;;;;;;:::i;:::-;;:::i;:::-;;;;6466:4:1;6454:17;;;6436:36;;6508:17;;;;6503:2;6488:18;;6481:45;6409:18;63528:186:0;6270:262:1;64765:272:0;64926:12;64957:73;64987:5;64994:16;65012:17;64957:29;:73::i;:::-;64950:80;;64765:272;;;;;;:::o;65043:266::-;51684:54;;;7529:66:1;7624:3;7620:16;;;7616:25;;51684:54:0;;;7604:38:1;7675:16;;;7671:25;;7658:11;;;7651:46;7730:16;;;7726:25;7713:11;;;7706:46;7768:12;;;;7761:28;;;51684:54:0;;;;;;;;;;7805:12:1;;;;51684:54:0;;;65043:266;;;;;;;:::o;64036:141::-;64103:4;64126:44;:28;:8;:26;:28::i;:::-;-1:-1:-1;;64126:42:0;;:44::i;:::-;64119:51;64036:141;-1:-1:-1;;64036:141:0:o;62747:160::-;62834:6;62859:41;:19;:8;62872:5;62859:12;:19::i;:::-;-1:-1:-1;;62859:39:0;;:41::i;62051:263::-;62157:6;62165:12;62193:13;62209:50;62244:14;;62209:19;62222:5;62209:8;:12;;:19;;;;:::i;:::-;-1:-1:-1;;62209:34:0;;;:50::i;:::-;62193:66;-1:-1:-1;62277:14:0;-1:-1:-1;;62277:12:0;;;:14::i;:::-;62293:13;-1:-1:-1;;62293:11:0;;;:13::i;:::-;62269:38;;;;;62051:263;;;;;:::o;65315:171::-;65401:6;53095:21;53114:2;53095:21;;;;53094:38;;;;65426:53;52953:186;63225:144;63304:6;63329:33;:19;:8;63342:5;63329:12;:19::i;:::-;-1:-1:-1;;63329:31:0;;:33::i;62913:148::-;62994:6;63019:35;:19;:8;63032:5;63019:12;:19::i;:::-;-1:-1:-1;;63019:33:0;;:35::i;63375:147::-;63455:7;63481:34;:19;:8;63494:5;63481:12;:19::i;:::-;-1:-1:-1;;63481:32:0;;:34::i;66944:120::-;66997:7;48524:21;48389:2;48544:1;48524:21;:::i;:::-;67016:41;;66944:120;:::o;65492:216::-;65619:6;53531:63;;;53582:2;53558:26;;;;;53551:2;53532:21;;;;;53531:54;:63;65644:57;53377:224;61794:251;61901:6;61909:12;61901:6;61953:37;:19;:8;61966:5;61953:12;:19::i;:::-;-1:-1:-1;;61953:35:0;;:37::i;62320:265::-;62427:6;62435:12;62463:13;62479:51;62515:14;;62479:19;62492:5;62479:8;:12;;:19;;;;:::i;:::-;-1:-1:-1;;62479:35:0;;;:51::i;62591:150::-;62673:6;62698:36;:19;:8;62711:5;62698:12;:19::i;:::-;-1:-1:-1;;62698:34:0;;:36::i;63067:152::-;63150:6;63175:37;:19;:8;63188:5;63175:12;:19::i;:::-;-1:-1:-1;;63175:35:0;;:37::i;61382:406::-;61485:6;61493:12;61678:13;61694:39;61724:8;61694:29;:39::i;63877:153::-;63961:5;63985:38;:19;:8;63998:5;63985:12;:19::i;:::-;-1:-1:-1;;63985:36:0;;:38::i;63720:151::-;63803:5;63827:37;:19;:8;63840:5;63827:12;:19::i;:::-;-1:-1:-1;;63827:35:0;;:37::i;63528:186::-;63635:5;;63670:37;:19;:8;63683:5;63670:12;:19::i;:::-;-1:-1:-1;;63670:35:0;;:37::i;:::-;63663:44;;;;63528:186;;;;;:::o;50278:863::-;50441:12;50465:15;50483:35;50501:16;50483:17;:35::i;:::-;50465:53;;50528:16;50547:36;50565:17;50547;:36::i;:::-;50845:16;;;50859:1;50845:16;;;;;;;;;50528:55;;-1:-1:-1;50681:22:0;50702:1;50681:22;;;;50680:37;;;;;50661:16;;50845;;;;;;;;;;-1:-1:-1;50845:16:0;50817:44;;50885:22;:5;:20;:22::i;:::-;50871:8;50880:1;50871:11;;;;;;;;:::i;:::-;-1:-1:-1;;50871:36:0;;;:11;;;;;;;;;;:36;50931:27;;:44;;:27;;50948:9;;50931:27;7192:3:1;7188:16;;;;7206:66;7184:89;7172:102;;7299:1;7290:11;;7045:262;50931:27:0;;;;;;;;;;;;;:42;:44::i;:::-;50917:8;50926:1;50917:11;;;;;;;;:::i;:::-;-1:-1:-1;;50917:58:0;;;:11;;;;;;;;;;;:58;50999:33;:16;:31;:33::i;:::-;50985:8;50994:1;50985:11;;;;;;;;:::i;:::-;-1:-1:-1;;50985:47:0;;;:11;;;;;;;;;;;:47;51056:34;:17;:32;:34::i;:::-;51042:8;51051:1;51042:11;;;;;;;;:::i;:::-;-1:-1:-1;;51042:48:0;;;:11;;;;;;;;;;;:48;51107:27;51125:8;51107:17;:27::i;:::-;51100:34;50278:863;-1:-1:-1;;;;;;;;50278:863:0:o;51851:144::-;51924:7;51950:38;:8;37661:16;51950:12;:38::i;52090:618::-;52151:4;3119:2;18555:23;;;3512:16;18551:41;48524:21;48389:2;48544:1;48524:21;:::i;:::-;52267:6;:31;52263:49;;;-1:-1:-1;52307:5:0;;52090:618;-1:-1:-1;;52090:618:0:o;52263:49::-;52323:17;52342:18;52364:23;52381:5;52364:16;:23::i;:::-;52322:65;;;;;-1:-1:-1;52322:65:0;;-1:-1:-1;52397:17:0;52417:22;52322:65;;52417:22;:::i;:::-;52397:42;;52503:9;52516:1;52503:14;52499:32;;-1:-1:-1;52526:5:0;;52090:618;-1:-1:-1;;;;;52090:618:0:o;52499:32::-;52662:39;40397:2;52662:9;:39;:::i;:::-;48524:21;48389:2;48544:1;48524:21;:::i;:::-;52637:64;;;;:::i;:::-;52627:74;;;;52090:618;-1:-1:-1;;;;;52090:618:0:o;14644:595::-;14748:10;;14714:7;;15174:4;15165:14;;15206:26;;;;15165:14;14748:10;15206:5;:26::i;:::-;15199:33;14644:595;-1:-1:-1;;;;;14644:595:0:o;54522:224::-;54644:6;54620:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;54680:58:0::1;-1:-1:-1::0;;54680:15:0;::::1;48234:1;::::0;54680:15:::1;:58::i;57378:519::-:0;57516:7;57492:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;;57540:15:::1;57561:23;57578:5;57561:16;:23::i;:::-;57539:45;;;57616:9;57602:23;;:11;:23;57594:48;;;::::0;::::1;::::0;;8203:2:1;57594:48:0::1;::::0;::::1;8185:21:1::0;8242:2;8222:18;;;8215:30;8281:14;8261:18;;;8254:42;8313:18;;57594:48:0::1;;;;;;;;;57671:219;57734:41;40397:2;57734:11:::0;:41:::1;:::i;:::-;48524:21;48389:2;48544:1;48524:21;:::i;:::-;57709:66;;;;:::i;:::-;-1:-1:-1::0;;57671:11:0;::::1;::::0;40397:2:::1;36922:16;57671:11;:219::i;49194:1::-;57378:519:::0;;;;;:::o;15431:504::-;15487:12;;3031:2;3303:20;3031:2;3119;3303:20;:::i;:::-;3383;;;;:::i;:::-;15895:24;;;;;15431:504;-1:-1:-1;;15431:504:0:o;31574:632::-;31629:16;31657:11;31678:12;31693;31697:7;3119:2;18555:23;3512:16;18551:41;;18035:573;31693:12;31678:27;;;;31815:4;31809:11;31802:18;;31870:3;31863:10;;31916:33;31929:7;31938:3;31944:4;31938:10;31916:12;:33::i;:::-;-1:-1:-1;32073:14:0;;;32089:4;32069:25;32063:4;32056:39;32136:17;;31574:632;;-1:-1:-1;31574:632:0:o;55454:176::-;55536:6;55520:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;55568:54:0::1;-1:-1:-1::0;;55568:15:0;::::1;48180:1;55617:2;55568:15;:54::i;54862:176::-:0;54946:6;54930:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;54978:52:0::1;-1:-1:-1::0;;54978:15:0;::::1;48282:1;55026;54978:15;:52::i;55725:164::-:0;55808:7;55792:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;55834:48:0::1;-1:-1:-1::0;;55834:11:0;::::1;48329:2;55877;55834:11;:48::i;55995:300::-:0;56081:7;56065:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;56119:169:0::1;-1:-1:-1::0;;56119:11:0;::::1;48180:1;48389:2;37760:16;56119:11;:169::i;58041:594::-:0;58181:7;58157:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;;58205:15:::1;58222:16:::0;58242:23:::1;58259:5;58242:16;:23::i;:::-;58204:61;;;;58298:10;58283:25;;:12;:25;58275:50;;;::::0;::::1;::::0;;8203:2:1;58275:50:0::1;::::0;::::1;8185:21:1::0;8242:2;8222:18;;;8215:30;8281:14;8261:18;;;8254:42;8313:18;;58275:50:0::1;8001:336:1::0;58275:50:0::1;58354:274;40397:2;58438:24;;::::0;::::1;:12:::0;:24:::1;:::i;:::-;58437:76;;;;:::i;:::-;48524:21;48389:2;48544:1;48524:21;:::i;:::-;58392:121;;;;:::i;:::-;-1:-1:-1::0;;58354:11:0;::::1;::::0;40397:2:::1;36922:16;58354:11;:274::i;:::-;58335:293:::0;58041:594;-1:-1:-1;;;;;;58041:594:0:o;54240:178::-;54325:6;54309:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;54357:53:0::1;-1:-1:-1::0;;54357:15:0;::::1;48180:1;54406;54357:15;:53::i;55155:179::-:0;55241:6;55225:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;-1:-1:-1;55273:53:0::1;-1:-1:-1::0;;55273:15:0;::::1;48180:1;55322;55273:15;:53::i;57037:198::-:0;57156:16;57132:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;;57205:23:::1;57222:5;57205:16;:23::i;56737:195::-:0;56855:15;56831:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;;56902:23:::1;56919:5;56902:16;:23::i;:::-;-1:-1:-1::0;56886:39:0;56737:195;-1:-1:-1;;;56737:195:0:o;56410:223::-;56528:15;;56504:5;49142:42;-1:-1:-1;;49142:16:0;;37661;49142;:42::i;:::-;;56603:23:::1;56620:5;56603:16;:23::i;:::-;56577:49:::0;;;;-1:-1:-1;56410:223:0;-1:-1:-1;;;56410:223:0:o;60090:371::-;60165:12;60189:15;40397:2;60207:11;:18;:48;;;;:::i;:::-;60314:18;;60189:66;;-1:-1:-1;60273:37:0;40397:2;60189:66;60273:37;:::i;:::-;:59;60265:89;;;;;;;8823:2:1;60265:89:0;;;8805:21:1;8862:2;8842:18;;;8835:30;8901:19;8881:18;;;8874:47;8938:18;;60265:89:0;8621:341:1;60265:89:0;60382:15;60372:25;;60364:57;;;;;;;9169:2:1;60364:57:0;;;9151:21:1;9208:2;9188:18;;;9181:30;9247:21;9227:18;;;9220:49;9286:18;;60364:57:0;8967:343:1;42249:139:0;42319:7;42345:36;:8;42319:7;42345:12;:36::i;34752:780::-;34965:4;34959:11;34816:16;;34844:11;35081:32;35092:8;35108:4;35102:10;;35081;:32::i;:::-;35070:43;;35133:16;35152:13;35156:8;3119:2;18555:23;3512:16;18551:41;;18035:573;35152:13;35133:32;;;;35175:18;35196:19;35206:8;35196:9;:19::i;:::-;35345:21;;;-1:-1:-1;35465:20:0;;35487:4;35461:31;35455:4;35448:45;-1:-1:-1;35352:3:0;34752:780;-1:-1:-1;;34752:780:0:o;59379:487::-;59466:15;;;59584:57;-1:-1:-1;;59584:15:0;;48389:2;59637:1;59584:15;:57::i;:::-;59728:20;59747:1;59728:20;;;;;;59836:22;;;-1:-1:-1;59379:487:0;-1:-1:-1;;;59379:487:0:o;13632:615::-;13743:15;;13785:11;13792:4;13785;:11;:::i;:::-;13770:26;;14064:4;14058:11;14052:4;14049:21;14046:66;;;-1:-1:-1;14097:1:0;14046:66;14135:4;14143:1;14135:9;14131:51;;-1:-1:-1;;14160:11:0;;;;;14131:51;-1:-1:-1;;3031:2:0;12798:33;;;12936:17;;;;12922:32;;;13059:17;3119:2;13043:34;;13632:615::o;10137:578::-;10215:7;10239:26;10246:7;10255:9;10239:6;:26::i;:::-;10234:451;;10284:9;10297:35;10315:15;10322:7;10315:6;:15::i;:::-;10307:24;;10297:9;:35::i;:::-;10281:51;;;10349:9;10362:29;10380:9;10372:18;;10362:9;:29::i;:::-;10449:186;;9682:31:1;10449:186:0;;;9670:44:1;9733:66;9837:3;9833:16;;;9829:25;;9815:12;;;9808:47;9885:15;9871:12;;;9864:37;9935:16;;;9931:25;9917:12;;;9910:47;10346:45:0;;-1:-1:-1;10405:17:0;;-1:-1:-1;9973:12:1;;10449:186:0;;;;;;;;;;;;10405:244;;10670:3;10663:11;;;;;;;;;;;:::i;10234:451::-;-1:-1:-1;10701:7:0;;10137:578;-1:-1:-1;10137:578:0:o;23838:374::-;23957:14;24188:11;24193:6;24188:2;:11;:::i;:::-;24187:17;;24203:1;24187:17;:::i;:::-;24143:62;;24151:30;24157:7;24166:6;24174;24151:5;:30::i;:::-;24143:62;;;23838:374;-1:-1:-1;;;;23838:374:0:o;19209:399::-;19348:7;19367:12;19382;19386:7;19382:3;:12::i;:::-;19367:27;;;;19478:12;19482:7;19478:3;:12::i;:::-;19471:4;19455:13;19462:6;19455:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;19451:77;;;-1:-1:-1;;19506:11:0;;;;;19451:77;19545:13;19552:6;19545:4;:13;:::i;:::-;19538:20;;19575:26;19581:7;19575:26;;19590:4;19596;19575:5;:26::i;30311:892::-;30389:15;-1:-1:-1;;7904:15:0;;;;30416:55;;;;;;;10808:2:1;30416:55:0;;;10790:21:1;10847:2;10827:18;;;10820:30;10886:28;10866:18;;;10859:56;10932:18;;30416:55:0;10606:350:1;30416:55:0;30489:16;30497:7;30489;:16::i;:::-;30481:58;;;;;;;11163:2:1;30481:58:0;;;11145:21:1;11202:2;11182:18;;;11175:30;11241:31;11221:18;;;11214:59;11290:18;;30481:58:0;10961:353:1;30481:58:0;30549:12;30564;30568:7;3119:2;18555:23;3512:16;18551:41;;18035:573;30564:12;30549:27;;;;30586:15;30604:12;30608:7;30604:3;:12::i;:::-;30586:30;;;;30627:11;30648:8;30766:4;30760:11;30753:18;;30853:7;30848:3;30845:16;30842:94;;;30893:4;30887;30880:18;30842:94;31063:4;31054:7;31048:4;31039:7;31033:4;31026:5;31015:53;31008:60;;31095:3;31087:36;;;;;;;11521:2:1;31087:36:0;;;11503:21:1;11560:2;11540:18;;;11533:30;11599:22;11579:18;;;11572:50;11639:18;;31087:36:0;11319:344:1;31087:36:0;31144:52;31165:15;31172:7;31165:6;:15::i;:::-;12798:33;3031:2;12798:33;;;;12936:17;;12922:32;;13059:17;;3119:2;13043:34;;12157:936;31144:52;31134:62;30311:892;-1:-1:-1;;;;;;;30311:892:0:o;22602:890::-;22717:14;22747:6;:11;;22757:1;22747:11;22743:59;;-1:-1:-1;22789:1:0;22774:17;;22743:59;22833:12;22837:7;3119:2;18555:23;3512:16;18551:41;;18035:573;22833:12;22815:30;;:15;;;;:6;:15;:::i;:::-;:30;22811:137;;;22868:68;22884:12;22888:7;22884:3;:12::i;:::-;22868:68;;22898:12;22902:7;3119:2;18555:23;3512:16;18551:41;;18035:573;22898:12;22868:68;;22912:6;22928;22920:15;;22868;:68::i;:::-;22861:76;;;;;;;;;;;:::i;22811:137::-;22975:2;22965:6;:12;;;;22957:50;;;;;;;11870:2:1;22957:50:0;;;11852:21:1;11909:2;11889:18;;;11882:30;11948:27;11928:18;;;11921:55;11993:18;;22957:50:0;11668:349:1;22957:50:0;23088:1;23079:10;;23018:15;23124:12;23128:7;23124:3;:12::i;:::-;23109:27;;;-1:-1:-1;23202:13:0;7378:66;7348:12;;;7327:131;23450:17;;;;23444:24;23440:36;;;-1:-1:-1;;;;;22602:890:0:o;32754:782::-;32866:18;33004:4;32998:11;33091:9;33086:3;33083:18;33080:96;;;33133:4;33127;33120:18;33080:96;;33196:15;33230:9;33225:239;33249:8;:15;33245:1;:19;33225:239;;;33285:15;33303:8;33312:1;33303:11;;;;;;;;:::i;:::-;;;;;;;33285:29;;33356:42;33369:7;33390;33378:9;:19;33356:12;:42::i;:::-;;33427:12;33431:7;3119:2;18555:23;3512:16;18551:41;;18035:573;33427:12;33416:23;;;;;;33271:193;33266:3;;;;;:::i;:::-;;;;33225:239;;;-1:-1:-1;3031:2:0;12922:32;;;13059:17;;3119:2;13043:34;33486:43;12157:936;17758:111;17817:7;17843:14;17849:7;17843:5;:14::i;:::-;:19;;17860:2;17843:19;:::i;9707:132::-;9781:4;9823:9;9804:28;;:15;9811:7;9804:6;:15::i;:::-;:28;;;;9707:132;-1:-1:-1;;;9707:132:0:o;4722:667::-;4776:13;;4832:2;4817:258;4840:2;4836:1;:6;;;4817:258;;;4860:11;4887:5;:1;4891;4887:5;:::i;:::-;4880:13;;:2;:13;;4860:34;;4917:14;4925:5;4917:7;:14::i;:::-;4908:23;;;;;;4949:1;:7;;4954:2;4949:7;4945:58;;4986:2;4976:12;;;;;4945:58;-1:-1:-1;5044:6:0;;4817:258;;;-1:-1:-1;5138:2:0;5123:260;5146:3;5142:1;:7;;;5123:260;;;5167:11;5194:5;:1;5198;5194:5;:::i;:::-;5187:13;;:2;:13;;5167:34;;5225:14;5233:5;5225:7;:14::i;:::-;5215:24;;;;;;5257:1;:6;;5262:1;5257:6;5253:58;;5294:2;5283:13;;;;;5253:58;-1:-1:-1;5352:6:0;;5123:260;;;;4722:667;;;:::o;16598:573::-;16651:11;;3303:20;3074:2;3119;3303:20;:::i;:::-;17118:23;;;;3512:16;17114:41;;16598:573;-1:-1:-1;;16598:573:0:o;18782:147::-;18835:7;18900:12;18904:7;3119:2;18555:23;3512:16;18551:41;;18035:573;18900:12;18885;18889:7;18885:3;:12::i;:::-;:27;18878:34;;;;18782:147;;;:::o;8577:465::-;8634:8;8658:15;8665:7;8658:6;:15::i;:::-;:31;;8677:12;8658:31;8654:74;;-1:-1:-1;8712:5:0;;8577:465;-1:-1:-1;8577:465:0:o;8654:74::-;8737:12;8752;8756:7;8752:3;:12::i;:::-;9019:4;9013:11;-1:-1:-1;9000:26:0;;8577:465;-1:-1:-1;;;8577:465:0:o;21359:741::-;21505:17;21537:9;21550:15;21560:4;21550:9;:15::i;:::-;21534:31;;;21578:9;21591:15;21601:4;21591:9;:15::i;:::-;21575:31;;;21619:9;21632:17;21642:6;21632:9;:17::i;:::-;21616:33;;;21662:9;21675:17;21685:6;21675:9;:17::i;:::-;21728:355;;;13063:34:1;21728:355:0;;;13051:47:1;13128:23;13114:12;;;13107:45;13171:66;13275:3;13271:16;;;13267:25;;13253:12;;;13246:47;13312:17;13345:12;;;13338:24;;;13396:16;;;13392:25;;13378:12;;;13371:47;13448:34;13434:12;;;13427:56;13514:3;13499:13;;;13492:26;13553:16;;;13549:25;;13534:13;;;13527:48;13591:13;;;13584:25;;;;13644:16;;13640:25;;;13625:13;;;13618:48;-1:-1:-1;;12299:3:1;13712:13;;;12287:16;21728:355:0;;;;;;;;;12319:11:1;;;;21728:355:0;;;;;-1:-1:-1;;;;;21359:741:0:o;17377:162::-;17432:7;17530:2;17508:12;17512:7;3119:2;18555:23;3512:16;18551:41;;18035:573;17508:12;17500:26;;:21;;17524:2;17500:26;:::i;:::-;17499:33;;;;:::i;4199:199::-;4249:14;4286:18;4302:1;4296:2;:7;;;;4286:9;:18::i;:::-;4275:29;;4328:13;;;;;;4340:1;4328:13;4362;4372:2;4362:9;:13::i;:::-;4351:24;;;;4199:199;-1:-1:-1;4199:199:0:o;3824:203::-;3997:13;;;;;;;;;;;;;;;;;;3879:11;;3926:4;3918:12;;;;;3997:22;;;;;;:::i;:::-;;;;;;;;3824:203;-1:-1:-1;;;3824:203:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:737::-;1089:6;1097;1105;1158:2;1146:9;1137:7;1133:23;1129:32;1126:52;;;1174:1;1171;1164:12;1126:52;1214:9;1201:23;1243:18;1284:2;1276:6;1273:14;1270:34;;;1300:1;1297;1290:12;1270:34;1323:49;1364:7;1355:6;1344:9;1340:22;1323:49;:::i;:::-;1313:59;;1425:2;1414:9;1410:18;1397:32;1381:48;;1454:2;1444:8;1441:16;1438:36;;;1470:1;1467;1460:12;1438:36;1493:51;1536:7;1525:8;1514:9;1510:24;1493:51;:::i;:::-;1483:61;;1597:2;1586:9;1582:18;1569:32;1553:48;;1626:2;1616:8;1613:16;1610:36;;;1642:1;1639;1632:12;1610:36;;1665:51;1708:7;1697:8;1686:9;1682:24;1665:51;:::i;:::-;1655:61;;;985:737;;;;;:::o;1727:481::-;1768:3;1806:5;1800:12;1833:6;1828:3;1821:19;1858:1;1868:162;1882:6;1879:1;1876:13;1868:162;;;1944:4;2000:13;;;1996:22;;1990:29;1972:11;;;1968:20;;1961:59;1897:12;1868:162;;;1872:3;2075:1;2068:4;2059:6;2054:3;2050:16;2046:27;2039:38;2197:4;2127:66;2122:2;2114:6;2110:15;2106:88;2101:3;2097:98;2093:109;2086:116;;;1727:481;;;;:::o;2213:217::-;2360:2;2349:9;2342:21;2323:4;2380:44;2420:2;2409:9;2405:18;2397:6;2380:44;:::i;2435:163::-;2502:20;;2562:10;2551:22;;2541:33;;2531:61;;2588:1;2585;2578:12;2531:61;2435:163;;;:::o;2603:397::-;2686:6;2694;2702;2710;2763:3;2751:9;2742:7;2738:23;2734:33;2731:53;;;2780:1;2777;2770:12;2731:53;2803:28;2821:9;2803:28;:::i;:::-;2793:38;;2850:37;2883:2;2872:9;2868:18;2850:37;:::i;:::-;2840:47;;2906:37;2939:2;2928:9;2924:18;2906:37;:::i;:::-;2603:397;;;;-1:-1:-1;2896:47:1;;2990:2;2975:18;2962:32;;-1:-1:-1;;2603:397:1:o;3187:320::-;3255:6;3308:2;3296:9;3287:7;3283:23;3279:32;3276:52;;;3324:1;3321;3314:12;3276:52;3364:9;3351:23;3397:18;3389:6;3386:30;3383:50;;;3429:1;3426;3419:12;3383:50;3452:49;3493:7;3484:6;3473:9;3469:22;3452:49;:::i;3704:486::-;3780:6;3788;3841:2;3829:9;3820:7;3816:23;3812:32;3809:52;;;3857:1;3854;3847:12;3809:52;3896:9;3883:23;3946:12;3939:5;3935:24;3928:5;3925:35;3915:63;;3974:1;3971;3964:12;3915:63;3997:5;-1:-1:-1;4053:2:1;4038:18;;4025:32;4080:18;4069:30;;4066:50;;;4112:1;4109;4102:12;4066:50;4135:49;4176:7;4167:6;4156:9;4152:22;4135:49;:::i;:::-;4125:59;;;3704:486;;;;;:::o;4392:180::-;4451:6;4504:2;4492:9;4483:7;4479:23;4475:32;4472:52;;;4520:1;4517;4510:12;4472:52;-1:-1:-1;4543:23:1;;4392:180;-1:-1:-1;4392:180:1:o;4577:305::-;4762:12;4754:6;4750:25;4739:9;4732:44;4812:2;4807;4796:9;4792:18;4785:30;4713:4;4832:44;4872:2;4861:9;4857:18;4849:6;4832:44;:::i;4887:256::-;4953:6;4961;5014:2;5002:9;4993:7;4989:23;4985:32;4982:52;;;5030:1;5027;5020:12;4982:52;5053:28;5071:9;5053:28;:::i;:::-;5043:38;;5100:37;5133:2;5122:9;5118:18;5100:37;:::i;:::-;5090:47;;4887:256;;;;;:::o;5748:328::-;5822:6;5830;5838;5891:2;5879:9;5870:7;5866:23;5862:32;5859:52;;;5907:1;5904;5897:12;5859:52;5930:28;5948:9;5930:28;:::i;:::-;5920:38;;5977:37;6010:2;5999:9;5995:18;5977:37;:::i;:::-;5967:47;;6033:37;6066:2;6055:9;6051:18;6033:37;:::i;:::-;6023:47;;5748:328;;;;;:::o;6537:184::-;6589:77;6586:1;6579:88;6686:4;6683:1;6676:15;6710:4;6707:1;6700:15;6726:125;6791:9;;;6812:10;;;6809:36;;;6825:18;;:::i;6856:184::-;6908:77;6905:1;6898:88;7005:4;7002:1;6995:15;7029:4;7026:1;7019:15;7828:168;7901:9;;;7932;;7949:15;;;7943:22;;7929:37;7919:71;;7970:18;;:::i;8342:274::-;8382:1;8408;8398:189;;8443:77;8440:1;8433:88;8544:4;8541:1;8534:15;8572:4;8569:1;8562:15;8398:189;-1:-1:-1;8601:9:1;;8342:274::o;10220:151::-;10310:4;10303:12;;;10289;;;10285:31;;10328:14;;10325:40;;;10345:18;;:::i;10376:225::-;10480:4;10459:12;;;10473;;;10455:31;10506:22;;;;10547:24;;;10537:58;;10575:18;;:::i;12022:195::-;12061:3;12092:66;12085:5;12082:77;12079:103;;12162:18;;:::i;:::-;-1:-1:-1;12209:1:1;12198:13;;12022:195::o","abiDefinition":[{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"agentSignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"},{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestationData","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"attestationDataLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"}],"name":"attestationDomains","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"}],"name":"attestationKey","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedDestination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedDomains","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedKey","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedNonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedOrigin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"castToAttestation","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes","name":"_guardSignatures","type":"bytes"},{"internalType":"bytes","name":"_notarySignatures","type":"bytes"}],"name":"formatAttestation","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"bytes32","name":"_root","type":"bytes32"}],"name":"formatAttestationData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"guardSignature","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"guardSignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"isAttestation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"notarySignature","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"notarySignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetAgentSignatures","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetDestination","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetFirstSignature","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetOrigin","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetRoot","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"setIndex","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Attestation methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"agentSignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestationData\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"attestationDataLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"}],\"name\":\"attestationDomains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"}],\"name\":\"attestationKey\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedDestination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedDomains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedKey\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedNonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedOrigin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"castToAttestation\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_guardSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_notarySignatures\",\"type\":\"bytes\"}],\"name\":\"formatAttestation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"formatAttestationData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"guardSignature\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"guardSignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"isAttestation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"notarySignature\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"notarySignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetAgentSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetDestination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetFirstSignature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Attestation methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"AttestationHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x28471e17ecfc213ffe5847f2d3237838a0fd73739ec8753d82da3603c271a78c\",\"urls\":[\"bzz-raw://d1d60bf8ec7bdfc98fa78101d6f437e409b0dc716d4cb5565206050246949147\",\"dweb:/ipfs/QmV4MYGNnQw78JzFX5oTY6rxAanRduoUgwfpFZW9j3eXFB\"]}},\"version\":1}"},"hashes":{"agentSignatures(uint40,bytes)":"f24caf61","attestationData(uint40,bytes)":"9ffb971e","attestationDataLength()":"a104a5e5","attestationDomains(uint32,uint32)":"65dfb428","attestationKey(uint32,uint32,uint32)":"9f668e20","attestedDestination(uint40,bytes)":"3b830f3b","attestedDomains(uint40,bytes)":"c231bd8f","attestedKey(uint40,bytes)":"79ce92a9","attestedNonce(uint40,bytes)":"8b445f51","attestedOrigin(uint40,bytes)":"badad7db","attestedRoot(uint40,bytes)":"91eedc1d","castToAttestation(uint40,bytes)":"c2e19ed2","formatAttestation(bytes,bytes,bytes)":"036227a2","formatAttestationData(uint32,uint32,uint32,bytes32)":"2951eae3","guardSignature(uint40,bytes)":"4a0cfe0e","guardSignatures(uint40,bytes)":"dc1e976d","isAttestation(bytes)":"3ae7034d","notarySignature(uint40,bytes)":"a43aa286","notarySignatures(uint40,bytes)":"cbe9d784","offsetAgentSignatures()":"ce533592","offsetDestination()":"d2c4428a","offsetFirstSignature()":"97d91f1a","offsetNonce()":"569e1eaf","offsetOrigin()":"320bfc44","offsetRoot()":"5b42242d","setIndex(uint256)":"40a5737f"}},"solidity/AttestationHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122020054a20c26a7fd65066415652aba36c70a6d3d42f215e6d034fb76af4c8ea7c64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122020054a20c26a7fd65066415652aba36c70a6d3d42f215e6d034fb76af4c8ea7c64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Returns an array of properly typed bytes29 pointers for\n     * every signature payload from the given array.\n     */\n    function castToSignatures(bytes[] memory _signaturePayloads)\n        internal\n        pure\n        returns (bytes29[] memory signatureViews)\n    {\n        uint256 length = _signaturePayloads.length;\n        signatureViews = new bytes29[](length);\n        for (uint256 i = 0; i \u003c length; ++i) {\n            signatureViews[i] = castToSignature(_signaturePayloads[i]);\n        }\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSignatures);\n        uint8 notarySigs = _amountSignatures(_notarySignatures);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _data.castToRawBytes();\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSignatures.castToRawBytes();\n        allViews[3] = _notarySignatures.castToRawBytes();\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes memory _signatures) private pure returns (uint8 amount) {\n        uint256 _amount = _signatures.length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == _signatures.length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"39998:7281:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;39998:7281:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"39998:7281:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Call payload memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Call payload memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x28471e17ecfc213ffe5847f2d3237838a0fd73739ec8753d82da3603c271a78c\",\"urls\":[\"bzz-raw://d1d60bf8ec7bdfc98fa78101d6f437e409b0dc716d4cb5565206050246949147\",\"dweb:/ipfs/QmV4MYGNnQw78JzFX5oTY6rxAanRduoUgwfpFZW9j3eXFB\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:SynapseTypes":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c7ed0cc2f4b8169de426526dd705ef97fb2a569c1222329285a320c37bc2f2c664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c7ed0cc2f4b8169de426526dd705ef97fb2a569c1222329285a320c37bc2f2c664736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Returns an array of properly typed bytes29 pointers for\n     * every signature payload from the given array.\n     */\n    function castToSignatures(bytes[] memory _signaturePayloads)\n        internal\n        pure\n        returns (bytes29[] memory signatureViews)\n    {\n        uint256 length = _signaturePayloads.length;\n        signatureViews = new bytes29[](length);\n        for (uint256 i = 0; i \u003c length; ++i) {\n            signatureViews[i] = castToSignature(_signaturePayloads[i]);\n        }\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSignatures);\n        uint8 notarySigs = _amountSignatures(_notarySignatures);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _data.castToRawBytes();\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSignatures.castToRawBytes();\n        allViews[3] = _notarySignatures.castToRawBytes();\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes memory _signatures) private pure returns (uint8 amount) {\n        uint256 _amount = _signatures.length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == _signatures.length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35536:4460:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35536:4460:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35536:4460:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"SynapseTypes\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x28471e17ecfc213ffe5847f2d3237838a0fd73739ec8753d82da3603c271a78c\",\"urls\":[\"bzz-raw://d1d60bf8ec7bdfc98fa78101d6f437e409b0dc716d4cb5565206050246949147\",\"dweb:/ipfs/QmV4MYGNnQw78JzFX5oTY6rxAanRduoUgwfpFZW9j3eXFB\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220a25d33771efae5cc031dd1529c328e960bde285785c03b9f1423ae2f72f7926564736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220a25d33771efae5cc031dd1529c328e960bde285785c03b9f1423ae2f72f7926564736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Returns an array of properly typed bytes29 pointers for\n     * every signature payload from the given array.\n     */\n    function castToSignatures(bytes[] memory _signaturePayloads)\n        internal\n        pure\n        returns (bytes29[] memory signatureViews)\n    {\n        uint256 length = _signaturePayloads.length;\n        signatureViews = new bytes29[](length);\n        for (uint256 i = 0; i \u003c length; ++i) {\n            signatureViews[i] = castToSignature(_signaturePayloads[i]);\n        }\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSignatures);\n        uint8 notarySigs = _amountSignatures(_notarySignatures);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _data.castToRawBytes();\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSignatures.castToRawBytes();\n        allViews[3] = _notarySignatures.castToRawBytes();\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes memory _signatures) private pure returns (uint8 amount) {\n        uint256 _amount = _signatures.length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == _signatures.length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:35508:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:35508:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:35508:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2952:38;;2988:2;2952:38;;;;;168:25:1;;;156:2;141:18;2952:38:0;;;;;;;;3209:46;;3119:2;3209:46;;3346:57;;;:::i;3267:56::-;;;:::i;3469:59::-;;3512:16;3469:59;;3039:37;;3074:2;3039:37;;2540:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2540:94:0;204:258:1;3346:57:0;3031:2;3303:20;3031:2;3119;3303:20;:::i;:::-;3383;;;;:::i;:::-;3346:57;:::o;3267:56::-;3303:20;3074:2;3119;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x28471e17ecfc213ffe5847f2d3237838a0fd73739ec8753d82da3603c271a78c\",\"urls\":[\"bzz-raw://d1d60bf8ec7bdfc98fa78101d6f437e409b0dc716d4cb5565206050246949147\",\"dweb:/ipfs/QmV4MYGNnQw78JzFX5oTY6rxAanRduoUgwfpFZW9j3eXFB\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}