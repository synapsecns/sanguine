{"solidity/AttestationHarness.t.sol:Attestation":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201ab18a9211de863de487a0bc693629adc84216776cf2e2726dfb3b10b775d0cc64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201ab18a9211de863de487a0bc693629adc84216776cf2e2726dfb3b10b775d0cc64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"47148:14212:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;47148:14212:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"47148:14212:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"AttestationData memory layout [000 .. 004): origin         uint32   4 bytes [004 .. 008): destination    uint32   4 bytes [008 .. 012): nonce          uint32   4 bytes [012 .. 044): root           bytes32 32 bytes      Attestation memory layout [000 .. 044): attData        bytes   44 bytes (see above) [044 .. 045): G = guardSigs  uint8    1 byte [045 .. 046): N = notarySigs uint8    1 byte [046 .. 111): guardSig[0]    bytes   65 bytes      .. [AAA .. BBB): guardSig[G-1]  bytes   65 bytes [BBB .. CCC): notarySig[0]   bytes   65 bytes      .. [DDD .. END): notarySig[N-1] bytes   65 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"AttestationData memory layout [000 .. 004): origin         uint32   4 bytes [004 .. 008): destination    uint32   4 bytes [008 .. 012): nonce          uint32   4 bytes [012 .. 044): root           bytes32 32 bytes      Attestation memory layout [000 .. 044): attData        bytes   44 bytes (see above) [044 .. 045): G = guardSigs  uint8    1 byte [045 .. 046): N = notarySigs uint8    1 byte [046 .. 111): guardSig[0]    bytes   65 bytes      .. [AAA .. BBB): guardSig[G-1]  bytes   65 bytes [BBB .. CCC): notarySig[0]   bytes   65 bytes      .. [DDD .. END): notarySig[N-1] bytes   65 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"Attestation\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x197271cacf44fd889b254b99e78ceada93f38ee1128ba06e0ccbd5491dee31ad\",\"urls\":[\"bzz-raw://69c561a7522bd48a02038c330f3271b7507f95b065d8f28100e185eab8f8732d\",\"dweb:/ipfs/QmUbw3H7DNd2QcUa65BXtHqWazZwSRheVNnATnUGpkWZiU\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:AttestationHarness":{"code":"0x608060405234801561001057600080fd5b50611eeb806100206000396000f3fe608060405234801561001057600080fd5b50600436106101cf5760003560e01c80638b445f5111610104578063badad7db116100a2578063ce53359211610071578063ce533592146103db578063d2c4428a14610453578063dc1e976d1461045a578063f24caf611461046d57600080fd5b8063badad7db146103f5578063c231bd8f14610408578063c2e19ed21461041b578063cbe9d7841461042e57600080fd5b80639f668e20116100de5780639f668e20146103b55780639ffb971e146103c8578063a104a5e5146103db578063a43aa286146103e257600080fd5b80638b445f511461038757806391eedc1d1461039a57806397d91f1a146103ad57600080fd5b80634a0cfe0e1161017157806365dfb4281161014b57806365dfb428146102e85780637214101b14610314578063794dd2141461034457806379ce92a91461035757600080fd5b80634a0cfe0e146102b9578063569e1eaf146102da5780635b42242d146102e157600080fd5b8063320bfc44116101ad578063320bfc44146102485780633ae7034d146102595780633b830f3b1461027c57806340a5737f146102a457600080fd5b8063036227a2146101d45780632951eae3146101fd578063308514be14610210575b600080fd5b6101e76101e2366004611a8c565b61049a565b6040516101f49190611b78565b60405180910390f35b6101e761020b366004611ba4565b6104b1565b61022361021e366004611bef565b610518565b6040805167ffffffffffffffff909316835263ffffffff9091166020830152016101f4565b60005b6040519081526020016101f4565b61026c610267366004611c1d565b61053b565b60405190151581526020016101f4565b61028f61028a366004611c52565b61055a565b60405163ffffffff90911681526020016101f4565b6102b76102b2366004611cac565b600055565b005b6102cc6102c7366004611c52565b610574565b6040516101f4929190611cc5565b600861024b565b600c61024b565b6102fb6102f6366004611ce5565b6105cb565b60405167ffffffffffffffff90911681526020016101f4565b610327610322366004611d18565b6105e9565b6040805163ffffffff9384168152929091166020830152016101f4565b6101e7610352366004611a8c565b610600565b61036a610365366004611c52565b61062b565b6040516bffffffffffffffffffffffff90911681526020016101f4565b61028f610395366004611c52565b610645565b61024b6103a8366004611c52565b61065f565b61024b610679565b61036a6103c3366004611d42565b61068c565b6102cc6103d6366004611c52565b6106be565b602c61024b565b6102cc6103f0366004611c52565b6106db565b61028f610403366004611c52565b610706565b6102fb610416366004611c52565b610720565b6102cc610429366004611c52565b61073a565b61044161043c366004611c52565b610749565b60405160ff90911681526020016101f4565b600461024b565b610441610468366004611c52565b610763565b61048061047b366004611c52565b61077d565b6040805160ff9384168152929091166020830152016101f4565b60606104a78484846107a3565b90505b9392505050565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e087811b8216602084015286811b8216602484015285901b166028820152602c80820184905282518083039091018152604c9091019091525b949350505050565b600080602083901c67ffffffffffffffff1663ffffffff84165b91509150915091565b6000610554610549836107c3565b62ffffff19166107d4565b92915050565b60006104aa610569838561086a565b62ffffff191661088e565b60006060600061059f600054610593878761086a90919063ffffffff16565b62ffffff1916906108b9565b90506105b062ffffff198216610990565b6105bf62ffffff1983166109b4565b92509250509250929050565b600067ffffffff00000000602084901b1663ffffffff8316176104aa565b60008063ffffffff602084901c8116908416610532565b60606104a761061085600061086a565b61061b85600061086a565b61062685600061086a565b610a07565b60006104aa61063a838561086a565b62ffffff1916610b69565b60006104aa610654838561086a565b62ffffff1916610b95565b60006104aa61066e838561086a565b62ffffff1916610bc1565b6000610687602c6002611db4565b905090565b600063ffffffff8216602084901b67ffffffff0000000016604086901b6bffffffff00000000000000001617176104a7565b600060608161059f6106d0858761086a565b62ffffff1916610bed565b60006060600061059f6000546106fa878761086a90919063ffffffff16565b62ffffff191690610c1f565b60006104aa610715838561086a565b62ffffff1916610d04565b60006104aa61072f838561086a565b62ffffff1916610d30565b60006060600061059f846107c3565b60006104aa610758838561086a565b62ffffff1916610d5c565b60006104aa610772838561086a565b62ffffff1916610d7e565b60008061079861078d848661086a565b62ffffff1916610da8565b915091509250929050565b60606104a76107b185610dd6565b6107ba85610dd6565b61062685610dd6565b60006105548264010100000061086a565b6000601882901c6bffffffffffffffffffffffff166107f5602c6002611db4565b8110156108055750600092915050565b60008061081185610de2565b60ff918216935016905060006108278284611db4565b90508060000361083d5750600095945050505050565b610848604182611dc7565b610854602c6002611db4565b61085e9190611db4565b90931495945050505050565b81516000906020840161088564ffffffffff85168284610e0d565b95945050505050565b6000816108a662ffffff198216640101000000610e54565b506104aa62ffffff198416600480610f6e565b6000826108d162ffffff198216640101000000610e54565b5060006108dd85610de2565b5090508060ff168410610951576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e6765000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61088561095f604186611dc7565b61096b602c6002611db4565b6109759190611db4565b62ffffff1987169060416301000000610f9e565b5092915050565b60008060606109a0816018611db4565b6109aa9190611db4565b9290921c92915050565b60606000806109d18460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506109f68483602001611009565b508181016020016040529052919050565b60606000610a14846111f0565b90506000610a21846111f0565b60408051600480825260a0820190925291925061ff00600885901b1660ff84161791600091602082016080803683370190505090508781600081518110610a6a57610a6a611dde565b62ffffff19909216602092830291909101820152604051610ad091610abc9185910160f09190911b7fffff00000000000000000000000000000000000000000000000000000000000016815260020190565b604051602081830303815290604052610dd6565b81600181518110610ae357610ae3611dde565b602002602001019062ffffff1916908162ffffff1916815250508681600281518110610b1157610b11611dde565b602002602001019062ffffff1916908162ffffff1916815250508581600381518110610b3f57610b3f611dde565b62ffffff1990921660209283029190910190910152610b5d816112f0565b98975050505050505050565b600081610b8162ffffff198216640101000000610e54565b506104aa62ffffff1984166000600c610f6e565b600081610bad62ffffff198216640101000000610e54565b506104aa62ffffff19841660086004610f6e565b600081610bd962ffffff198216640101000000610e54565b506104aa62ffffff198416600c602061134f565b600081610c0562ffffff198216640101000000610e54565b506104aa62ffffff1984166000602c640101010000610f9e565b600082610c3762ffffff198216640101000000610e54565b50600080610c4486610de2565b915091508060ff168510610cb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e676500000000000000000000000000000000000000006044820152606401610948565b610cfa6041610cc660ff851688611db4565b610cd09190611dc7565b610cdc602c6002611db4565b610ce69190611db4565b62ffffff1988169060416301000000610f9e565b9695505050505050565b600081610d1c62ffffff198216640101000000610e54565b506104aa62ffffff19841660006004610f6e565b600081610d4862ffffff198216640101000000610e54565b506104aa62ffffff19841660006008610f6e565b600081610d7462ffffff198216640101000000610e54565b5061051083610de2565b600081610d9662ffffff198216640101000000610e54565b50610da083610de2565b509392505050565b60008082610dc162ffffff198216640101000000610e54565b50610dcb84610de2565b909590945092505050565b6000610554828261086a565b60008080610df962ffffff198516602c6002610f6e565b60ff600882901c8116969116945092505050565b600080610e1a8385611db4565b9050604051811115610e2a575060005b80600003610e3f5762ffffff199150506104aa565b5050606092831b9190911790911b1760181b90565b6000610e6083836114fd565b610f67576000610e7e610e7285610990565b64ffffffffff1661151f565b9150506000610e938464ffffffffff1661151f565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b5090919050565b6000610f7b826020611e0d565b610f86906008611e26565b60ff16610f9485858561134f565b901c949350505050565b600080610faa86611609565b6bffffffffffffffffffffffff169050610fc386611630565b84610fce8784611db4565b610fd89190611db4565b1115610feb5762ffffff19915050610510565b610ff58582611db4565b9050610cfa8364ffffffffff168286610e0d565b600062ffffff198084160361107a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610948565b61108383611669565b6110e9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610948565b60006111038460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061111e85611609565b6bffffffffffffffffffffffff1690506000806040519150858211156111445760206060fd5b8386858560045afa9050806111b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610948565b6111e56111c188610990565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b6000601882901c6bffffffffffffffffffffffff1681611211604183611e42565b90508161121f604183611dc7565b14611286576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f217369676e6174757265734c656e6774680000000000000000000000000000006044820152606401610948565b60ff81106104aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f546f6f206d616e79207369676e617475726573000000000000000000000000006044820152606401610948565b604051606090600061130584602084016116a5565b905060006113218260181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061133c8361173f565b9184525082016020016040525092915050565b60008160ff16600003611364575060006104aa565b61137c8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661139760ff841685611db4565b111561141a576113e76113a985611609565b6bffffffffffffffffffffffff166113cf8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611755565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b60208260ff161115611488576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610948565b60088202600061149786611609565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008164ffffffffff1661151084610990565b64ffffffffff16149392505050565b600080601f5b600f8160ff16111561159257600061153e826008611e26565b60ff1685901c905061154f816118e5565b61ffff16841793508160ff1660101461156a57601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611525565b50600f5b60ff8160ff1610156116035760006115af826008611e26565b60ff1685901c90506115c0816118e5565b61ffff16831792508160ff166000146115db57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611596565b50915091565b60008061161860606018611db4565b9290921c6bffffffffffffffffffffffff1692915050565b600061164a8260181c6bffffffffffffffffffffffff1690565b61165383611609565b016bffffffffffffffffffffffff169050919050565b600061167482610990565b64ffffffffff1664ffffffffff0361168e57506000919050565b600061169983611630565b60405110199392505050565b6000604051828111156116b85760206060fd5b506000805b845181101561172f5760008582815181106116da576116da611dde565b602002602001015190506116f081848701611009565b506117098160181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff168301925050808061172790611e7d565b9150506116bd565b50606083901b811760181b610510565b600061174a82611917565b610554906020611dc7565b606060006117628661151f565b91505060006117708661151f565b915050600061177e8661151f565b915050600061178c8661151f565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b60006118f760048360ff16901c611956565b60ff1661ffff919091161760081b61190e82611956565b60ff1617919050565b600060206119338360181c6bffffffffffffffffffffffff1690565b61194c906bffffffffffffffffffffffff16601f611db4565b6105549190611e42565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f841691829081106119a3576119a3611dde565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126119f257600080fd5b813567ffffffffffffffff80821115611a0d57611a0d6119b2565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611a5357611a536119b2565b81604052838152866020858801011115611a6c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215611aa157600080fd5b833567ffffffffffffffff80821115611ab957600080fd5b611ac5878388016119e1565b94506020860135915080821115611adb57600080fd5b611ae7878388016119e1565b93506040860135915080821115611afd57600080fd5b50611b0a868287016119e1565b9150509250925092565b6000815180845260005b81811015611b3a57602081850181015186830182015201611b1e565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b6020815260006104aa6020830184611b14565b803563ffffffff81168114611b9f57600080fd5b919050565b60008060008060808587031215611bba57600080fd5b611bc385611b8b565b9350611bd160208601611b8b565b9250611bdf60408601611b8b565b9396929550929360600135925050565b600060208284031215611c0157600080fd5b81356bffffffffffffffffffffffff811681146104aa57600080fd5b600060208284031215611c2f57600080fd5b813567ffffffffffffffff811115611c4657600080fd5b610510848285016119e1565b60008060408385031215611c6557600080fd5b823564ffffffffff81168114611c7a57600080fd5b9150602083013567ffffffffffffffff811115611c9657600080fd5b611ca2858286016119e1565b9150509250929050565b600060208284031215611cbe57600080fd5b5035919050565b64ffffffffff831681526040602082015260006104a76040830184611b14565b60008060408385031215611cf857600080fd5b611d0183611b8b565b9150611d0f60208401611b8b565b90509250929050565b600060208284031215611d2a57600080fd5b813567ffffffffffffffff811681146104aa57600080fd5b600080600060608486031215611d5757600080fd5b611d6084611b8b565b9250611d6e60208501611b8b565b9150611d7c60408501611b8b565b90509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561055457610554611d85565b808202811582820484141761055457610554611d85565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60ff828116828216039081111561055457610554611d85565b60ff818116838216029081169081811461098957610989611d85565b600082611e78577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611eae57611eae611d85565b506001019056fea2646970667358221220c8c27f01d97061e9864cbedbda1622c98cf066af66805692b6a81e196c547bf564736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106101cf5760003560e01c80638b445f5111610104578063badad7db116100a2578063ce53359211610071578063ce533592146103db578063d2c4428a14610453578063dc1e976d1461045a578063f24caf611461046d57600080fd5b8063badad7db146103f5578063c231bd8f14610408578063c2e19ed21461041b578063cbe9d7841461042e57600080fd5b80639f668e20116100de5780639f668e20146103b55780639ffb971e146103c8578063a104a5e5146103db578063a43aa286146103e257600080fd5b80638b445f511461038757806391eedc1d1461039a57806397d91f1a146103ad57600080fd5b80634a0cfe0e1161017157806365dfb4281161014b57806365dfb428146102e85780637214101b14610314578063794dd2141461034457806379ce92a91461035757600080fd5b80634a0cfe0e146102b9578063569e1eaf146102da5780635b42242d146102e157600080fd5b8063320bfc44116101ad578063320bfc44146102485780633ae7034d146102595780633b830f3b1461027c57806340a5737f146102a457600080fd5b8063036227a2146101d45780632951eae3146101fd578063308514be14610210575b600080fd5b6101e76101e2366004611a8c565b61049a565b6040516101f49190611b78565b60405180910390f35b6101e761020b366004611ba4565b6104b1565b61022361021e366004611bef565b610518565b6040805167ffffffffffffffff909316835263ffffffff9091166020830152016101f4565b60005b6040519081526020016101f4565b61026c610267366004611c1d565b61053b565b60405190151581526020016101f4565b61028f61028a366004611c52565b61055a565b60405163ffffffff90911681526020016101f4565b6102b76102b2366004611cac565b600055565b005b6102cc6102c7366004611c52565b610574565b6040516101f4929190611cc5565b600861024b565b600c61024b565b6102fb6102f6366004611ce5565b6105cb565b60405167ffffffffffffffff90911681526020016101f4565b610327610322366004611d18565b6105e9565b6040805163ffffffff9384168152929091166020830152016101f4565b6101e7610352366004611a8c565b610600565b61036a610365366004611c52565b61062b565b6040516bffffffffffffffffffffffff90911681526020016101f4565b61028f610395366004611c52565b610645565b61024b6103a8366004611c52565b61065f565b61024b610679565b61036a6103c3366004611d42565b61068c565b6102cc6103d6366004611c52565b6106be565b602c61024b565b6102cc6103f0366004611c52565b6106db565b61028f610403366004611c52565b610706565b6102fb610416366004611c52565b610720565b6102cc610429366004611c52565b61073a565b61044161043c366004611c52565b610749565b60405160ff90911681526020016101f4565b600461024b565b610441610468366004611c52565b610763565b61048061047b366004611c52565b61077d565b6040805160ff9384168152929091166020830152016101f4565b60606104a78484846107a3565b90505b9392505050565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e087811b8216602084015286811b8216602484015285901b166028820152602c80820184905282518083039091018152604c9091019091525b949350505050565b600080602083901c67ffffffffffffffff1663ffffffff84165b91509150915091565b6000610554610549836107c3565b62ffffff19166107d4565b92915050565b60006104aa610569838561086a565b62ffffff191661088e565b60006060600061059f600054610593878761086a90919063ffffffff16565b62ffffff1916906108b9565b90506105b062ffffff198216610990565b6105bf62ffffff1983166109b4565b92509250509250929050565b600067ffffffff00000000602084901b1663ffffffff8316176104aa565b60008063ffffffff602084901c8116908416610532565b60606104a761061085600061086a565b61061b85600061086a565b61062685600061086a565b610a07565b60006104aa61063a838561086a565b62ffffff1916610b69565b60006104aa610654838561086a565b62ffffff1916610b95565b60006104aa61066e838561086a565b62ffffff1916610bc1565b6000610687602c6002611db4565b905090565b600063ffffffff8216602084901b67ffffffff0000000016604086901b6bffffffff00000000000000001617176104a7565b600060608161059f6106d0858761086a565b62ffffff1916610bed565b60006060600061059f6000546106fa878761086a90919063ffffffff16565b62ffffff191690610c1f565b60006104aa610715838561086a565b62ffffff1916610d04565b60006104aa61072f838561086a565b62ffffff1916610d30565b60006060600061059f846107c3565b60006104aa610758838561086a565b62ffffff1916610d5c565b60006104aa610772838561086a565b62ffffff1916610d7e565b60008061079861078d848661086a565b62ffffff1916610da8565b915091509250929050565b60606104a76107b185610dd6565b6107ba85610dd6565b61062685610dd6565b60006105548264010100000061086a565b6000601882901c6bffffffffffffffffffffffff166107f5602c6002611db4565b8110156108055750600092915050565b60008061081185610de2565b60ff918216935016905060006108278284611db4565b90508060000361083d5750600095945050505050565b610848604182611dc7565b610854602c6002611db4565b61085e9190611db4565b90931495945050505050565b81516000906020840161088564ffffffffff85168284610e0d565b95945050505050565b6000816108a662ffffff198216640101000000610e54565b506104aa62ffffff198416600480610f6e565b6000826108d162ffffff198216640101000000610e54565b5060006108dd85610de2565b5090508060ff168410610951576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e6765000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61088561095f604186611dc7565b61096b602c6002611db4565b6109759190611db4565b62ffffff1987169060416301000000610f9e565b5092915050565b60008060606109a0816018611db4565b6109aa9190611db4565b9290921c92915050565b60606000806109d18460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506109f68483602001611009565b508181016020016040529052919050565b60606000610a14846111f0565b90506000610a21846111f0565b60408051600480825260a0820190925291925061ff00600885901b1660ff84161791600091602082016080803683370190505090508781600081518110610a6a57610a6a611dde565b62ffffff19909216602092830291909101820152604051610ad091610abc9185910160f09190911b7fffff00000000000000000000000000000000000000000000000000000000000016815260020190565b604051602081830303815290604052610dd6565b81600181518110610ae357610ae3611dde565b602002602001019062ffffff1916908162ffffff1916815250508681600281518110610b1157610b11611dde565b602002602001019062ffffff1916908162ffffff1916815250508581600381518110610b3f57610b3f611dde565b62ffffff1990921660209283029190910190910152610b5d816112f0565b98975050505050505050565b600081610b8162ffffff198216640101000000610e54565b506104aa62ffffff1984166000600c610f6e565b600081610bad62ffffff198216640101000000610e54565b506104aa62ffffff19841660086004610f6e565b600081610bd962ffffff198216640101000000610e54565b506104aa62ffffff198416600c602061134f565b600081610c0562ffffff198216640101000000610e54565b506104aa62ffffff1984166000602c640101010000610f9e565b600082610c3762ffffff198216640101000000610e54565b50600080610c4486610de2565b915091508060ff168510610cb4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4f7574206f662072616e676500000000000000000000000000000000000000006044820152606401610948565b610cfa6041610cc660ff851688611db4565b610cd09190611dc7565b610cdc602c6002611db4565b610ce69190611db4565b62ffffff1988169060416301000000610f9e565b9695505050505050565b600081610d1c62ffffff198216640101000000610e54565b506104aa62ffffff19841660006004610f6e565b600081610d4862ffffff198216640101000000610e54565b506104aa62ffffff19841660006008610f6e565b600081610d7462ffffff198216640101000000610e54565b5061051083610de2565b600081610d9662ffffff198216640101000000610e54565b50610da083610de2565b509392505050565b60008082610dc162ffffff198216640101000000610e54565b50610dcb84610de2565b909590945092505050565b6000610554828261086a565b60008080610df962ffffff198516602c6002610f6e565b60ff600882901c8116969116945092505050565b600080610e1a8385611db4565b9050604051811115610e2a575060005b80600003610e3f5762ffffff199150506104aa565b5050606092831b9190911790911b1760181b90565b6000610e6083836114fd565b610f67576000610e7e610e7285610990565b64ffffffffff1661151f565b9150506000610e938464ffffffffff1661151f565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b5090919050565b6000610f7b826020611e0d565b610f86906008611e26565b60ff16610f9485858561134f565b901c949350505050565b600080610faa86611609565b6bffffffffffffffffffffffff169050610fc386611630565b84610fce8784611db4565b610fd89190611db4565b1115610feb5762ffffff19915050610510565b610ff58582611db4565b9050610cfa8364ffffffffff168286610e0d565b600062ffffff198084160361107a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f636f7079546f3a204e756c6c20706f696e7465722064657265660000000000006044820152606401610948565b61108383611669565b6110e9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f636f7079546f3a20496e76616c696420706f696e7465722064657265660000006044820152606401610948565b60006111038460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061111e85611609565b6bffffffffffffffffffffffff1690506000806040519150858211156111445760206060fd5b8386858560045afa9050806111b5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f6964656e746974793a206f7574206f66206761730000000000000000000000006044820152606401610948565b6111e56111c188610990565b70ffffffffff000000000000000000000000606091821b168817901b851760181b90565b979650505050505050565b6000601882901c6bffffffffffffffffffffffff1681611211604183611e42565b90508161121f604183611dc7565b14611286576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f217369676e6174757265734c656e6774680000000000000000000000000000006044820152606401610948565b60ff81106104aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f546f6f206d616e79207369676e617475726573000000000000000000000000006044820152606401610948565b604051606090600061130584602084016116a5565b905060006113218260181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061133c8361173f565b9184525082016020016040525092915050565b60008160ff16600003611364575060006104aa565b61137c8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661139760ff841685611db4565b111561141a576113e76113a985611609565b6bffffffffffffffffffffffff166113cf8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16611755565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109489190611b78565b60208260ff161115611488576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f496e6465783a206d6f7265207468616e203332206279746573000000000000006044820152606401610948565b60088202600061149786611609565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008164ffffffffff1661151084610990565b64ffffffffff16149392505050565b600080601f5b600f8160ff16111561159257600061153e826008611e26565b60ff1685901c905061154f816118e5565b61ffff16841793508160ff1660101461156a57601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611525565b50600f5b60ff8160ff1610156116035760006115af826008611e26565b60ff1685901c90506115c0816118e5565b61ffff16831792508160ff166000146115db57601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01611596565b50915091565b60008061161860606018611db4565b9290921c6bffffffffffffffffffffffff1692915050565b600061164a8260181c6bffffffffffffffffffffffff1690565b61165383611609565b016bffffffffffffffffffffffff169050919050565b600061167482610990565b64ffffffffff1664ffffffffff0361168e57506000919050565b600061169983611630565b60405110199392505050565b6000604051828111156116b85760206060fd5b506000805b845181101561172f5760008582815181106116da576116da611dde565b602002602001015190506116f081848701611009565b506117098160181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff168301925050808061172790611e7d565b9150506116bd565b50606083901b811760181b610510565b600061174a82611917565b610554906020611dc7565b606060006117628661151f565b91505060006117708661151f565b915050600061177e8661151f565b915050600061178c8661151f565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b60006118f760048360ff16901c611956565b60ff1661ffff919091161760081b61190e82611956565b60ff1617919050565b600060206119338360181c6bffffffffffffffffffffffff1690565b61194c906bffffffffffffffffffffffff16601f611db4565b6105549190611e42565b6040805180820190915260108082527f30313233343536373839616263646566000000000000000000000000000000006020830152600091600f841691829081106119a3576119a3611dde565b016020015160f81c9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126119f257600080fd5b813567ffffffffffffffff80821115611a0d57611a0d6119b2565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611a5357611a536119b2565b81604052838152866020858801011115611a6c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215611aa157600080fd5b833567ffffffffffffffff80821115611ab957600080fd5b611ac5878388016119e1565b94506020860135915080821115611adb57600080fd5b611ae7878388016119e1565b93506040860135915080821115611afd57600080fd5b50611b0a868287016119e1565b9150509250925092565b6000815180845260005b81811015611b3a57602081850181015186830182015201611b1e565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b6020815260006104aa6020830184611b14565b803563ffffffff81168114611b9f57600080fd5b919050565b60008060008060808587031215611bba57600080fd5b611bc385611b8b565b9350611bd160208601611b8b565b9250611bdf60408601611b8b565b9396929550929360600135925050565b600060208284031215611c0157600080fd5b81356bffffffffffffffffffffffff811681146104aa57600080fd5b600060208284031215611c2f57600080fd5b813567ffffffffffffffff811115611c4657600080fd5b610510848285016119e1565b60008060408385031215611c6557600080fd5b823564ffffffffff81168114611c7a57600080fd5b9150602083013567ffffffffffffffff811115611c9657600080fd5b611ca2858286016119e1565b9150509250929050565b600060208284031215611cbe57600080fd5b5035919050565b64ffffffffff831681526040602082015260006104a76040830184611b14565b60008060408385031215611cf857600080fd5b611d0183611b8b565b9150611d0f60208401611b8b565b90509250929050565b600060208284031215611d2a57600080fd5b813567ffffffffffffffff811681146104aa57600080fd5b600080600060608486031215611d5757600080fd5b611d6084611b8b565b9250611d6e60208501611b8b565b9150611d7c60408501611b8b565b90509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561055457610554611d85565b808202811582820484141761055457610554611d85565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60ff828116828216039081111561055457610554611d85565b60ff818116838216029081169081811461098957610989611d85565b600082611e78577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611eae57611eae611d85565b506001019056fea2646970667358221220c8c27f01d97061e9864cbedbda1622c98cf066af66805692b6a81e196c547bf564736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"61441:7276:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"61441:7276:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;65662:272;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;66368:266;;;;;;:::i;:::-;;:::i;67203:156::-;;;;;;:::i;:::-;;:::i;:::-;;;;3502:18:1;3490:31;;;3472:50;;3570:10;3558:23;;;3553:2;3538:18;;3531:51;3445:18;67203:156:0;3302:286:1;68033:103:0;68078:7;68033:103;;;3739:25:1;;;3727:2;3712:18;68033:103:0;3593:177:1;64933:141:0;;;;;;:::i;:::-;;:::i;:::-;;;4265:14:1;;4258:22;4240:41;;4228:2;4213:18;64933:141:0;4100:187:1;63644:160:0;;;;;;:::i;:::-;;:::i;:::-;;;4957:10:1;4945:23;;;4927:42;;4915:2;4900:18;63644:160:0;4783:192:1;61652:81:0;;;;;;:::i;:::-;61704:14;:22;61652:81;;;62948:263;;;;;;:::i;:::-;;:::i;:::-;;;;;;;;:::i;68261:101::-;48149:1;68261:101;;68368:99;48196:2;68368:99;;66640:171;;;;;;:::i;:::-;;:::i;:::-;;;5910:18:1;5898:31;;;5880:50;;5868:2;5853:18;66640:171:0;5736:200:1;67039:158:0;;;;;;:::i;:::-;;:::i;:::-;;;;6410:10:1;6447:15;;;6429:34;;6499:15;;;;6494:2;6479:18;;6472:43;6373:18;67039:158:0;6230:291:1;65940:422:0;;;;;;:::i;:::-;;:::i;64122:144::-;;;;;;:::i;:::-;;:::i;:::-;;;6700:26:1;6688:39;;;6670:58;;6658:2;6643:18;64122:144:0;6526:208:1;63810:148:0;;;;;;:::i;:::-;;:::i;64272:147::-;;;;;;:::i;:::-;;:::i;68595:120::-;;;:::i;66817:216::-;;;;;;:::i;:::-;;:::i;62691:251::-;;;;;;:::i;:::-;;:::i;67905:122::-;48256:2;67905:122;;63217:265;;;;;;:::i;:::-;;:::i;63488:150::-;;;;;;:::i;:::-;;:::i;63964:152::-;;;;;;:::i;:::-;;:::i;62279:406::-;;;;;;:::i;:::-;;:::i;64774:153::-;;;;;;:::i;:::-;;:::i;:::-;;;7426:4:1;7414:17;;;7396:36;;7384:2;7369:18;64774:153:0;7254:184:1;68142:113:0;48101:1;68142:113;;64617:151;;;;;;:::i;:::-;;:::i;64425:186::-;;;;;;:::i;:::-;;:::i;:::-;;;;7639:4:1;7627:17;;;7609:36;;7681:17;;;;7676:2;7661:18;;7654:45;7582:18;64425:186:0;7443:262:1;65662:272:0;65823:12;65854:73;65884:5;65891:16;65909:17;65854:29;:73::i;:::-;65847:80;;65662:272;;;;;;:::o;66368:266::-;51920:54;;;8246:66:1;8341:3;8337:16;;;8333:25;;51920:54:0;;;8321:38:1;8392:16;;;8388:25;;8375:11;;;8368:46;8447:16;;;8443:25;8430:11;;;8423:46;8485:12;;;;8478:28;;;51920:54:0;;;;;;;;;;8522:12:1;;;;51920:54:0;;;66368:266;;;;;;;:::o;67203:156::-;67267:14;;54387:2;54368:21;;;;;54463:16;54445:34;;67314:38;67307:45;;;;67203:156;;;:::o;64933:141::-;65000:4;65023:44;:28;:8;:26;:28::i;:::-;-1:-1:-1;;65023:42:0;;:44::i;:::-;65016:51;64933:141;-1:-1:-1;;64933:141:0:o;63644:160::-;63731:6;63756:41;:19;:8;63769:5;63756:12;:19::i;:::-;-1:-1:-1;;63756:39:0;;:41::i;62948:263::-;63054:6;63062:12;63090:13;63106:50;63141:14;;63106:19;63119:5;63106:8;:12;;:19;;;;:::i;:::-;-1:-1:-1;;63106:34:0;;;:50::i;:::-;63090:66;-1:-1:-1;63174:14:0;-1:-1:-1;;63174:12:0;;;:14::i;:::-;63190:13;-1:-1:-1;;63190:11:0;;;:13::i;:::-;63166:38;;;;;62948:263;;;;;:::o;66640:171::-;66726:6;53331:21;53350:2;53331:21;;;;53330:38;;;;66751:53;53189:186;67039:158;67111:6;;54042:25;54065:2;54042:25;;;;;;54129:38;;67144:46;53843:332;65940:422;66110:12;66153:202;66212:12;:5;66222:1;66212:9;:12::i;:::-;66258:23;:16;66279:1;66258:20;:23::i;:::-;66316:24;:17;66338:1;66316:21;:24::i;:::-;66153:29;:202::i;64122:144::-;64201:6;64226:33;:19;:8;64239:5;64226:12;:19::i;:::-;-1:-1:-1;;64226:31:0;;:33::i;63810:148::-;63891:6;63916:35;:19;:8;63929:5;63916:12;:19::i;:::-;-1:-1:-1;;63916:33:0;;:35::i;64272:147::-;64352:7;64378:34;:19;:8;64391:5;64378:12;:19::i;:::-;-1:-1:-1;;64378:32:0;;:34::i;68595:120::-;68648:7;48391:21;48256:2;48411:1;48391:21;:::i;:::-;68667:41;;68595:120;:::o;66817:216::-;66944:6;53767:63;;;53818:2;53794:26;;;;;53787:2;53768:21;;;;;53767:54;:63;66969:57;53613:224;62691:251;62798:6;62806:12;62798:6;62850:37;:19;:8;62863:5;62850:12;:19::i;:::-;-1:-1:-1;;62850:35:0;;:37::i;63217:265::-;63324:6;63332:12;63360:13;63376:51;63412:14;;63376:19;63389:5;63376:8;:12;;:19;;;;:::i;:::-;-1:-1:-1;;63376:35:0;;;:51::i;63488:150::-;63570:6;63595:36;:19;:8;63608:5;63595:12;:19::i;:::-;-1:-1:-1;;63595:34:0;;:36::i;63964:152::-;64047:6;64072:37;:19;:8;64085:5;64072:12;:19::i;:::-;-1:-1:-1;;64072:35:0;;:37::i;62279:406::-;62382:6;62390:12;62575:13;62591:39;62621:8;62591:29;:39::i;64774:153::-;64858:5;64882:38;:19;:8;64895:5;64882:12;:19::i;:::-;-1:-1:-1;;64882:36:0;;:38::i;64617:151::-;64700:5;64724:37;:19;:8;64737:5;64724:12;:19::i;:::-;-1:-1:-1;;64724:35:0;;:37::i;64425:186::-;64532:5;;64567:37;:19;:8;64580:5;64567:12;:19::i;:::-;-1:-1:-1;;64567:35:0;;:37::i;:::-;64560:44;;;;64425:186;;;;;:::o;50145:433::-;50308:12;50351:220;50398:22;:5;:20;:22::i;:::-;50454:33;:16;:31;:33::i;:::-;50522:34;:17;:32;:34::i;52087:144::-;52160:7;52186:38;:8;37661:16;52186:12;:38::i;52326:618::-;52387:4;3119:2;18555:23;;;3512:16;18551:41;48391:21;48256:2;48411:1;48391:21;:::i;:::-;52503:6;:31;52499:49;;;-1:-1:-1;52543:5:0;;52326:618;-1:-1:-1;;52326:618:0:o;52499:49::-;52559:17;52578:18;52600:23;52617:5;52600:16;:23::i;:::-;52558:65;;;;;-1:-1:-1;52558:65:0;;-1:-1:-1;52633:17:0;52653:22;52558:65;;52653:22;:::i;:::-;52633:42;;52739:9;52752:1;52739:14;52735:32;;-1:-1:-1;52762:5:0;;52326:618;-1:-1:-1;;;;;52326:618:0:o;52735:32::-;52898:39;40397:2;52898:9;:39;:::i;:::-;48391:21;48256:2;48411:1;48391:21;:::i;:::-;52873:64;;;;:::i;:::-;52863:74;;;;52326:618;-1:-1:-1;;;;;52326:618:0:o;14644:595::-;14748:10;;14714:7;;15174:4;15165:14;;15206:26;;;;15165:14;14748:10;15206:5;:26::i;:::-;15199:33;14644:595;-1:-1:-1;;;;;14644:595:0:o;55408:224::-;55530:6;55506:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;55566:58:0::1;-1:-1:-1::0;;55566:15:0;::::1;48101:1;::::0;55566:15:::1;:58::i;58264:519::-:0;58402:7;58378:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;;58426:15:::1;58447:23;58464:5;58447:16;:23::i;:::-;58425:45;;;58502:9;58488:23;;:11;:23;58480:48;;;::::0;::::1;::::0;;8920:2:1;58480:48:0::1;::::0;::::1;8902:21:1::0;8959:2;8939:18;;;8932:30;8998:14;8978:18;;;8971:42;9030:18;;58480:48:0::1;;;;;;;;;58557:219;58620:41;40397:2;58620:11:::0;:41:::1;:::i;:::-;48391:21;48256:2;48411:1;48391:21;:::i;:::-;58595:66;;;;:::i;:::-;-1:-1:-1::0;;58557:11:0;::::1;::::0;40397:2:::1;36922:16;58557:11;:219::i;49061:1::-;58264:519:::0;;;;;:::o;15431:504::-;15487:12;;3031:2;3303:20;3031:2;3119;3303:20;:::i;:::-;3383;;;;:::i;:::-;15895:24;;;;;15431:504;-1:-1:-1;;15431:504:0:o;31574:632::-;31629:16;31657:11;31678:12;31693;31697:7;3119:2;18555:23;3512:16;18551:41;;18035:573;31693:12;31678:27;;;;31815:4;31809:11;31802:18;;31870:3;31863:10;;31916:33;31929:7;31938:3;31944:4;31938:10;31916:12;:33::i;:::-;-1:-1:-1;32073:14:0;;;32089:4;32069:25;32063:4;32056:39;32136:17;;31574:632;;-1:-1:-1;31574:632:0:o;50584:793::-;50732:12;50756:15;50774:33;50792:14;50774:17;:33::i;:::-;50756:51;;50817:16;50836:34;50854:15;50836:17;:34::i;:::-;51132:16;;;51146:1;51132:16;;;;;;;;;50817:53;;-1:-1:-1;50968:22:0;50989:1;50968:22;;;;50967:37;;;;;50948:16;;51132;;;;;;;;;;-1:-1:-1;51132:16:0;51104:44;;51172:9;51158:8;51167:1;51158:11;;;;;;;;:::i;:::-;-1:-1:-1;;51158:23:0;;;:11;;;;;;;;;;:23;51205:27;;:44;;:27;;51222:9;;51205:27;9395:3:1;9391:16;;;;9409:66;9387:89;9375:102;;9502:1;9493:11;;9248:262;51205:27:0;;;;;;;;;;;;;:42;:44::i;:::-;51191:8;51200:1;51191:11;;;;;;;;:::i;:::-;;;;;;:58;;;;;;;;;;;;;51273:14;51259:8;51268:1;51259:11;;;;;;;;:::i;:::-;;;;;;:28;;;;;;;;;;;;;51311:15;51297:8;51306:1;51297:11;;;;;;;;:::i;:::-;-1:-1:-1;;51297:29:0;;;:11;;;;;;;;;;;:29;51343:27;51361:8;51343:17;:27::i;:::-;51336:34;50584:793;-1:-1:-1;;;;;;;;50584:793:0:o;56340:176::-;56422:6;56406:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;56454:54:0::1;-1:-1:-1::0;;56454:15:0;::::1;48047:1;56503:2;56454:15;:54::i;55748:176::-:0;55832:6;55816:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;55864:52:0::1;-1:-1:-1::0;;55864:15:0;::::1;48149:1;55912;55864:15;:52::i;56611:164::-:0;56694:7;56678:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;56720:48:0::1;-1:-1:-1::0;;56720:11:0;::::1;48196:2;56763;56720:11;:48::i;56881:300::-:0;56967:7;56951:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;57005:169:0::1;-1:-1:-1::0;;57005:11:0;::::1;48047:1;48256:2;37760:16;57005:11;:169::i;58927:594::-:0;59067:7;59043:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;;59091:15:::1;59108:16:::0;59128:23:::1;59145:5;59128:16;:23::i;:::-;59090:61;;;;59184:10;59169:25;;:12;:25;59161:50;;;::::0;::::1;::::0;;8920:2:1;59161:50:0::1;::::0;::::1;8902:21:1::0;8959:2;8939:18;;;8932:30;8998:14;8978:18;;;8971:42;9030:18;;59161:50:0::1;8718:336:1::0;59161:50:0::1;59240:274;40397:2;59324:24;;::::0;::::1;:12:::0;:24:::1;:::i;:::-;59323:76;;;;:::i;:::-;48391:21;48256:2;48411:1;48391:21;:::i;:::-;59278:121;;;;:::i;:::-;-1:-1:-1::0;;59240:11:0;::::1;::::0;40397:2:::1;36922:16;59240:11;:274::i;:::-;59221:293:::0;58927:594;-1:-1:-1;;;;;;58927:594:0:o;55126:178::-;55211:6;55195:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;55243:53:0::1;-1:-1:-1::0;;55243:15:0;::::1;48047:1;55292;55243:15;:53::i;56041:179::-:0;56127:6;56111:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;-1:-1:-1;56159:53:0::1;-1:-1:-1::0;;56159:15:0;::::1;48047:1;56208;56159:15;:53::i;57923:198::-:0;58042:16;58018:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;;58091:23:::1;58108:5;58091:16;:23::i;57623:195::-:0;57741:15;57717:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;;57788:23:::1;57805:5;57788:16;:23::i;:::-;-1:-1:-1::0;57772:39:0;57623:195;-1:-1:-1;;;57623:195:0:o;57296:223::-;57414:15;;57390:5;49009:42;-1:-1:-1;;49009:16:0;;37661;49009;:42::i;:::-;;57489:23:::1;57506:5;57489:16;:23::i;:::-;57463:49:::0;;;;-1:-1:-1;57296:223:0;-1:-1:-1;;;57296:223:0:o;42643:139::-;42713:7;42739:36;:8;42713:7;42739:12;:36::i;60265:487::-;60352:15;;;60470:57;-1:-1:-1;;60470:15:0;;48256:2;60523:1;60470:15;:57::i;:::-;60614:20;60633:1;60614:20;;;;;;60722:22;;;-1:-1:-1;60265:487:0;-1:-1:-1;;;60265:487:0:o;13632:615::-;13743:15;;13785:11;13792:4;13785;:11;:::i;:::-;13770:26;;14064:4;14058:11;14052:4;14049:21;14046:66;;;-1:-1:-1;14097:1:0;14046:66;14135:4;14143:1;14135:9;14131:51;;-1:-1:-1;;14160:11:0;;;;;14131:51;-1:-1:-1;;3031:2:0;12798:33;;;12936:17;;;;12922:32;;;13059:17;3119:2;13043:34;;13632:615::o;10137:578::-;10215:7;10239:26;10246:7;10255:9;10239:6;:26::i;:::-;10234:451;;10284:9;10297:35;10315:15;10322:7;10315:6;:15::i;:::-;10307:24;;10297:9;:35::i;:::-;10281:51;;;10349:9;10362:29;10380:9;10372:18;;10362:9;:29::i;:::-;10449:186;;9882:31:1;10449:186:0;;;9870:44:1;9933:66;10037:3;10033:16;;;10029:25;;10015:12;;;10008:47;10085:15;10071:12;;;10064:37;10135:16;;;10131:25;10117:12;;;10110:47;10346:45:0;;-1:-1:-1;10405:17:0;;-1:-1:-1;10173:12:1;;10449:186:0;;;;;;;;;;;;10405:244;;10670:3;10663:11;;;;;;;;;;;:::i;10234:451::-;-1:-1:-1;10701:7:0;;10137:578;-1:-1:-1;10137:578:0:o;23838:374::-;23957:14;24188:11;24193:6;24188:2;:11;:::i;:::-;24187:17;;24203:1;24187:17;:::i;:::-;24143:62;;24151:30;24157:7;24166:6;24174;24151:5;:30::i;:::-;24143:62;;;23838:374;-1:-1:-1;;;;23838:374:0:o;19209:399::-;19348:7;19367:12;19382;19386:7;19382:3;:12::i;:::-;19367:27;;;;19478:12;19482:7;19478:3;:12::i;:::-;19471:4;19455:13;19462:6;19455:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;19451:77;;;-1:-1:-1;;19506:11:0;;;;;19451:77;19545:13;19552:6;19545:4;:13;:::i;:::-;19538:20;;19575:26;19581:7;19575:26;;19590:4;19596;19575:5;:26::i;30311:892::-;30389:15;-1:-1:-1;;7904:15:0;;;;30416:55;;;;;;;11008:2:1;30416:55:0;;;10990:21:1;11047:2;11027:18;;;11020:30;11086:28;11066:18;;;11059:56;11132:18;;30416:55:0;10806:350:1;30416:55:0;30489:16;30497:7;30489;:16::i;:::-;30481:58;;;;;;;11363:2:1;30481:58:0;;;11345:21:1;11402:2;11382:18;;;11375:30;11441:31;11421:18;;;11414:59;11490:18;;30481:58:0;11161:353:1;30481:58:0;30549:12;30564;30568:7;3119:2;18555:23;3512:16;18551:41;;18035:573;30564:12;30549:27;;;;30586:15;30604:12;30608:7;30604:3;:12::i;:::-;30586:30;;;;30627:11;30648:8;30766:4;30760:11;30753:18;;30853:7;30848:3;30845:16;30842:94;;;30893:4;30887;30880:18;30842:94;31063:4;31054:7;31048:4;31039:7;31033:4;31026:5;31015:53;31008:60;;31095:3;31087:36;;;;;;;11721:2:1;31087:36:0;;;11703:21:1;11760:2;11740:18;;;11733:30;11799:22;11779:18;;;11772:50;11839:18;;31087:36:0;11519:344:1;31087:36:0;31144:52;31165:15;31172:7;31165:6;:15::i;:::-;12798:33;3031:2;12798:33;;;;12936:17;;12922:32;;13059:17;;3119:2;13043:34;;12157:936;31144:52;31134:62;30311:892;-1:-1:-1;;;;;;;30311:892:0:o;60976:382::-;61044:12;3119:2;18555:23;;;3512:16;18551:41;61044:12;61128:36;40397:2;18551:41;61128:36;:::i;:::-;61110:54;-1:-1:-1;61223:6:0;61182:37;40397:2;61110:54;61182:37;:::i;:::-;:47;61174:77;;;;;;;12349:2:1;61174:77:0;;;12331:21:1;12388:2;12368:18;;;12361:30;12427:19;12407:18;;;12400:47;12464:18;;61174:77:0;12147:341:1;61174:77:0;61279:15;61269:25;;61261:57;;;;;;;12695:2:1;61261:57:0;;;12677:21:1;12734:2;12714:18;;;12707:30;12773:21;12753:18;;;12746:49;12812:18;;61261:57:0;12493:343:1;34752:780:0;34965:4;34959:11;34816:16;;34844:11;35081:32;35092:8;35108:4;35102:10;;35081;:32::i;:::-;35070:43;;35133:16;35152:13;35156:8;3119:2;18555:23;3512:16;18551:41;;18035:573;35152:13;35133:32;;;;35175:18;35196:19;35206:8;35196:9;:19::i;:::-;35345:21;;;-1:-1:-1;35465:20:0;;35487:4;35461:31;35455:4;35448:45;-1:-1:-1;35352:3:0;34752:780;-1:-1:-1;;34752:780:0:o;22602:890::-;22717:14;22747:6;:11;;22757:1;22747:11;22743:59;;-1:-1:-1;22789:1:0;22774:17;;22743:59;22833:12;22837:7;3119:2;18555:23;3512:16;18551:41;;18035:573;22833:12;22815:30;;:15;;;;:6;:15;:::i;:::-;:30;22811:137;;;22868:68;22884:12;22888:7;22884:3;:12::i;:::-;22868:68;;22898:12;22902:7;3119:2;18555:23;3512:16;18551:41;;18035:573;22898:12;22868:68;;22912:6;22928;22920:15;;22868;:68::i;:::-;22861:76;;;;;;;;;;;:::i;22811:137::-;22975:2;22965:6;:12;;;;22957:50;;;;;;;13043:2:1;22957:50:0;;;13025:21:1;13082:2;13062:18;;;13055:30;13121:27;13101:18;;;13094:55;13166:18;;22957:50:0;12841:349:1;22957:50:0;23088:1;23079:10;;23018:15;23124:12;23128:7;23124:3;:12::i;:::-;23109:27;;;-1:-1:-1;23202:13:0;7378:66;7348:12;;;7327:131;23450:17;;;;23444:24;23440:36;;;-1:-1:-1;;;;;22602:890:0:o;9707:132::-;9781:4;9823:9;9804:28;;:15;9811:7;9804:6;:15::i;:::-;:28;;;;9707:132;-1:-1:-1;;;9707:132:0:o;4722:667::-;4776:13;;4832:2;4817:258;4840:2;4836:1;:6;;;4817:258;;;4860:11;4887:5;:1;4891;4887:5;:::i;:::-;4880:13;;:2;:13;;4860:34;;4917:14;4925:5;4917:7;:14::i;:::-;4908:23;;;;;;4949:1;:7;;4954:2;4949:7;4945:58;;4986:2;4976:12;;;;;4945:58;-1:-1:-1;5044:6:0;;4817:258;;;-1:-1:-1;5138:2:0;5123:260;5146:3;5142:1;:7;;;5123:260;;;5167:11;5194:5;:1;5198;5194:5;:::i;:::-;5187:13;;:2;:13;;5167:34;;5225:14;5233:5;5225:7;:14::i;:::-;5215:24;;;;;;5257:1;:6;;5262:1;5257:6;5253:58;;5294:2;5283:13;;;;;5253:58;-1:-1:-1;5352:6:0;;5123:260;;;;4722:667;;;:::o;16598:573::-;16651:11;;3303:20;3074:2;3119;3303:20;:::i;:::-;17118:23;;;;3512:16;17114:41;;16598:573;-1:-1:-1;;16598:573:0:o;18782:147::-;18835:7;18900:12;18904:7;3119:2;18555:23;3512:16;18551:41;;18035:573;18900:12;18885;18889:7;18885:3;:12::i;:::-;:27;18878:34;;;;18782:147;;;:::o;8577:465::-;8634:8;8658:15;8665:7;8658:6;:15::i;:::-;:31;;8677:12;8658:31;8654:74;;-1:-1:-1;8712:5:0;;8577:465;-1:-1:-1;8577:465:0:o;8654:74::-;8737:12;8752;8756:7;8752:3;:12::i;:::-;9019:4;9013:11;-1:-1:-1;9000:26:0;;8577:465;-1:-1:-1;;;8577:465:0:o;32754:782::-;32866:18;33004:4;32998:11;33091:9;33086:3;33083:18;33080:96;;;33133:4;33127;33120:18;33080:96;;33196:15;33230:9;33225:239;33249:8;:15;33245:1;:19;33225:239;;;33285:15;33303:8;33312:1;33303:11;;;;;;;;:::i;:::-;;;;;;;33285:29;;33356:42;33369:7;33390;33378:9;:19;33356:12;:42::i;:::-;;33427:12;33431:7;3119:2;18555:23;3512:16;18551:41;;18035:573;33427:12;33416:23;;;;;;33271:193;33266:3;;;;;:::i;:::-;;;;33225:239;;;-1:-1:-1;3031:2:0;12922:32;;;13059:17;;3119:2;13043:34;33486:43;12157:936;17758:111;17817:7;17843:14;17849:7;17843:5;:14::i;:::-;:19;;17860:2;17843:19;:::i;21359:741::-;21505:17;21537:9;21550:15;21560:4;21550:9;:15::i;:::-;21534:31;;;21578:9;21591:15;21601:4;21591:9;:15::i;:::-;21575:31;;;21619:9;21632:17;21642:6;21632:9;:17::i;:::-;21616:33;;;21662:9;21675:17;21685:6;21675:9;:17::i;:::-;21728:355;;;14236:34:1;21728:355:0;;;14224:47:1;14301:23;14287:12;;;14280:45;14344:66;14448:3;14444:16;;;14440:25;;14426:12;;;14419:47;14485:17;14518:12;;;14511:24;;;14569:16;;;14565:25;;14551:12;;;14544:47;14621:34;14607:12;;;14600:56;14687:3;14672:13;;;14665:26;14726:16;;;14722:25;;14707:13;;;14700:48;14764:13;;;14757:25;;;;14817:16;;14813:25;;;14798:13;;;14791:48;-1:-1:-1;;13472:3:1;14885:13;;;13460:16;21728:355:0;;;;;;;;;13492:11:1;;;;21728:355:0;;;;;-1:-1:-1;;;;;21359:741:0:o;4199:199::-;4249:14;4286:18;4302:1;4296:2;:7;;;;4286:9;:18::i;:::-;4275:29;;4328:13;;;;;;4340:1;4328:13;4362;4372:2;4362:9;:13::i;:::-;4351:24;;;;4199:199;-1:-1:-1;4199:199:0:o;17377:162::-;17432:7;17530:2;17508:12;17512:7;3119:2;18555:23;3512:16;18551:41;;18035:573;17508:12;17500:26;;:21;;17524:2;17500:26;:::i;:::-;17499:33;;;;:::i;3824:203::-;3997:13;;;;;;;;;;;;;;;;;;3879:11;;3926:4;3918:12;;;;;3997:22;;;;;;:::i;:::-;;;;;;;;3824:203;-1:-1:-1;;;3824:203:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:737::-;1089:6;1097;1105;1158:2;1146:9;1137:7;1133:23;1129:32;1126:52;;;1174:1;1171;1164:12;1126:52;1214:9;1201:23;1243:18;1284:2;1276:6;1273:14;1270:34;;;1300:1;1297;1290:12;1270:34;1323:49;1364:7;1355:6;1344:9;1340:22;1323:49;:::i;:::-;1313:59;;1425:2;1414:9;1410:18;1397:32;1381:48;;1454:2;1444:8;1441:16;1438:36;;;1470:1;1467;1460:12;1438:36;1493:51;1536:7;1525:8;1514:9;1510:24;1493:51;:::i;:::-;1483:61;;1597:2;1586:9;1582:18;1569:32;1553:48;;1626:2;1616:8;1613:16;1610:36;;;1642:1;1639;1632:12;1610:36;;1665:51;1708:7;1697:8;1686:9;1682:24;1665:51;:::i;:::-;1655:61;;;985:737;;;;;:::o;1727:481::-;1768:3;1806:5;1800:12;1833:6;1828:3;1821:19;1858:1;1868:162;1882:6;1879:1;1876:13;1868:162;;;1944:4;2000:13;;;1996:22;;1990:29;1972:11;;;1968:20;;1961:59;1897:12;1868:162;;;1872:3;2075:1;2068:4;2059:6;2054:3;2050:16;2046:27;2039:38;2197:4;2127:66;2122:2;2114:6;2110:15;2106:88;2101:3;2097:98;2093:109;2086:116;;;1727:481;;;;:::o;2213:217::-;2360:2;2349:9;2342:21;2323:4;2380:44;2420:2;2409:9;2405:18;2397:6;2380:44;:::i;2435:163::-;2502:20;;2562:10;2551:22;;2541:33;;2531:61;;2588:1;2585;2578:12;2531:61;2435:163;;;:::o;2603:397::-;2686:6;2694;2702;2710;2763:3;2751:9;2742:7;2738:23;2734:33;2731:53;;;2780:1;2777;2770:12;2731:53;2803:28;2821:9;2803:28;:::i;:::-;2793:38;;2850:37;2883:2;2872:9;2868:18;2850:37;:::i;:::-;2840:47;;2906:37;2939:2;2928:9;2924:18;2906:37;:::i;:::-;2603:397;;;;-1:-1:-1;2896:47:1;;2990:2;2975:18;2962:32;;-1:-1:-1;;2603:397:1:o;3005:292::-;3063:6;3116:2;3104:9;3095:7;3091:23;3087:32;3084:52;;;3132:1;3129;3122:12;3084:52;3171:9;3158:23;3221:26;3214:5;3210:38;3203:5;3200:49;3190:77;;3263:1;3260;3253:12;3775:320;3843:6;3896:2;3884:9;3875:7;3871:23;3867:32;3864:52;;;3912:1;3909;3902:12;3864:52;3952:9;3939:23;3985:18;3977:6;3974:30;3971:50;;;4017:1;4014;4007:12;3971:50;4040:49;4081:7;4072:6;4061:9;4057:22;4040:49;:::i;4292:486::-;4368:6;4376;4429:2;4417:9;4408:7;4404:23;4400:32;4397:52;;;4445:1;4442;4435:12;4397:52;4484:9;4471:23;4534:12;4527:5;4523:24;4516:5;4513:35;4503:63;;4562:1;4559;4552:12;4503:63;4585:5;-1:-1:-1;4641:2:1;4626:18;;4613:32;4668:18;4657:30;;4654:50;;;4700:1;4697;4690:12;4654:50;4723:49;4764:7;4755:6;4744:9;4740:22;4723:49;:::i;:::-;4713:59;;;4292:486;;;;;:::o;4980:180::-;5039:6;5092:2;5080:9;5071:7;5067:23;5063:32;5060:52;;;5108:1;5105;5098:12;5060:52;-1:-1:-1;5131:23:1;;4980:180;-1:-1:-1;4980:180:1:o;5165:305::-;5350:12;5342:6;5338:25;5327:9;5320:44;5400:2;5395;5384:9;5380:18;5373:30;5301:4;5420:44;5460:2;5449:9;5445:18;5437:6;5420:44;:::i;5475:256::-;5541:6;5549;5602:2;5590:9;5581:7;5577:23;5573:32;5570:52;;;5618:1;5615;5608:12;5570:52;5641:28;5659:9;5641:28;:::i;:::-;5631:38;;5688:37;5721:2;5710:9;5706:18;5688:37;:::i;:::-;5678:47;;5475:256;;;;;:::o;5941:284::-;5999:6;6052:2;6040:9;6031:7;6027:23;6023:32;6020:52;;;6068:1;6065;6058:12;6020:52;6107:9;6094:23;6157:18;6150:5;6146:30;6139:5;6136:41;6126:69;;6191:1;6188;6181:12;6921:328;6995:6;7003;7011;7064:2;7052:9;7043:7;7039:23;7035:32;7032:52;;;7080:1;7077;7070:12;7032:52;7103:28;7121:9;7103:28;:::i;:::-;7093:38;;7150:37;7183:2;7172:9;7168:18;7150:37;:::i;:::-;7140:47;;7206:37;7239:2;7228:9;7224:18;7206:37;:::i;:::-;7196:47;;6921:328;;;;;:::o;7710:184::-;7762:77;7759:1;7752:88;7859:4;7856:1;7849:15;7883:4;7880:1;7873:15;7899:125;7964:9;;;7985:10;;;7982:36;;;7998:18;;:::i;8545:168::-;8618:9;;;8649;;8666:15;;;8660:22;;8646:37;8636:71;;8687:18;;:::i;9059:184::-;9111:77;9108:1;9101:88;9208:4;9205:1;9198:15;9232:4;9229:1;9222:15;10420:151;10510:4;10503:12;;;10489;;;10485:31;;10528:14;;10525:40;;;10545:18;;:::i;10576:225::-;10680:4;10659:12;;;10673;;;10655:31;10706:22;;;;10747:24;;;10737:58;;10775:18;;:::i;11868:274::-;11908:1;11934;11924:189;;11969:77;11966:1;11959:88;12070:4;12067:1;12060:15;12098:4;12095:1;12088:15;11924:189;-1:-1:-1;12127:9:1;;11868:274::o;13195:195::-;13234:3;13265:66;13258:5;13255:77;13252:103;;13335:18;;:::i;:::-;-1:-1:-1;13382:1:1;13371:13;;13195:195::o","abiDefinition":[{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"agentSignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"},{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestationData","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"attestationDataLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"}],"name":"attestationDomains","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"}],"name":"attestationKey","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedDestination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedDomains","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedKey","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedNonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedOrigin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"attestedRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"castToAttestation","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes","name":"_guardSignatures","type":"bytes"},{"internalType":"bytes","name":"_notarySignatures","type":"bytes"}],"name":"formatAttestation","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"bytes32","name":"_root","type":"bytes32"}],"name":"formatAttestationData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes","name":"_guardSignatures","type":"bytes"},{"internalType":"bytes","name":"_notarySignatures","type":"bytes"}],"name":"formatAttestationFromViews","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"guardSignature","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"guardSignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"isAttestation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"notarySignature","outputs":[{"internalType":"uint40","name":"","type":"uint40"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint40","name":"_type","type":"uint40"},{"internalType":"bytes","name":"_payload","type":"bytes"}],"name":"notarySignatures","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetAgentSignatures","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetDestination","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetFirstSignature","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetOrigin","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetRoot","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"setIndex","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint64","name":"_attestationDomains","type":"uint64"}],"name":"unpackDomains","outputs":[{"internalType":"uint32","name":"","type":"uint32"},{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint96","name":"_attestationKey","type":"uint96"}],"name":"unpackKey","outputs":[{"internalType":"uint64","name":"domains","type":"uint64"},{"internalType":"uint32","name":"nonce","type":"uint32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"Exposes Attestation methods for testing against golang.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"agentSignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestationData\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"attestationDataLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"}],\"name\":\"attestationDomains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"}],\"name\":\"attestationKey\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedDestination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedDomains\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedKey\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedNonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedOrigin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"attestedRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"castToAttestation\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_guardSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_notarySignatures\",\"type\":\"bytes\"}],\"name\":\"formatAttestation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"formatAttestationData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_guardSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_notarySignatures\",\"type\":\"bytes\"}],\"name\":\"formatAttestationFromViews\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"guardSignature\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"guardSignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"isAttestation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"notarySignature\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"notarySignatures\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetAgentSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetDestination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetFirstSignature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_attestationDomains\",\"type\":\"uint64\"}],\"name\":\"unpackDomains\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_attestationKey\",\"type\":\"uint96\"}],\"name\":\"unpackKey\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"domains\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Exposes Attestation methods for testing against golang.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"AttestationHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x197271cacf44fd889b254b99e78ceada93f38ee1128ba06e0ccbd5491dee31ad\",\"urls\":[\"bzz-raw://69c561a7522bd48a02038c330f3271b7507f95b065d8f28100e185eab8f8732d\",\"dweb:/ipfs/QmUbw3H7DNd2QcUa65BXtHqWazZwSRheVNnATnUGpkWZiU\"]}},\"version\":1}"},"hashes":{"agentSignatures(uint40,bytes)":"f24caf61","attestationData(uint40,bytes)":"9ffb971e","attestationDataLength()":"a104a5e5","attestationDomains(uint32,uint32)":"65dfb428","attestationKey(uint32,uint32,uint32)":"9f668e20","attestedDestination(uint40,bytes)":"3b830f3b","attestedDomains(uint40,bytes)":"c231bd8f","attestedKey(uint40,bytes)":"79ce92a9","attestedNonce(uint40,bytes)":"8b445f51","attestedOrigin(uint40,bytes)":"badad7db","attestedRoot(uint40,bytes)":"91eedc1d","castToAttestation(uint40,bytes)":"c2e19ed2","formatAttestation(bytes,bytes,bytes)":"036227a2","formatAttestationData(uint32,uint32,uint32,bytes32)":"2951eae3","formatAttestationFromViews(bytes,bytes,bytes)":"794dd214","guardSignature(uint40,bytes)":"4a0cfe0e","guardSignatures(uint40,bytes)":"dc1e976d","isAttestation(bytes)":"3ae7034d","notarySignature(uint40,bytes)":"a43aa286","notarySignatures(uint40,bytes)":"cbe9d784","offsetAgentSignatures()":"ce533592","offsetDestination()":"d2c4428a","offsetFirstSignature()":"97d91f1a","offsetNonce()":"569e1eaf","offsetOrigin()":"320bfc44","offsetRoot()":"5b42242d","setIndex(uint256)":"40a5737f","unpackDomains(uint64)":"7214101b","unpackKey(uint96)":"308514be"}},"solidity/AttestationHarness.t.sol:ByteString":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a5f364d63f7a1761f63092e4ca8e3a7670e5eafadc955b0dda13d1c02c8ff89864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a5f364d63f7a1761f63092e4ca8e3a7670e5eafadc955b0dda13d1c02c8ff89864736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"39998:7148:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;39998:7148:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"39998:7148:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"SELECTOR_LENGTH":{"details":"Call payload memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes"},"SIGNATURE_LENGTH":{"details":"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"SELECTOR_LENGTH\":{\"details\":\"Call payload memory layout [000 .. 004) selector    bytes4  4 bytes      Optional: N function arguments [004 .. 036) arg1        bytes32 32 bytes      .. [AAA .. END) argN        bytes32 32 bytes\"},\"SIGNATURE_LENGTH\":{\"details\":\"non-compact ECDSA signatures are enforced as of OZ 4.7.3      Signature payload memory layout [000 .. 032) r   bytes32 32 bytes [032 .. 064) s   bytes32 32 bytes [064 .. 065) v   uint8    1 byte\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"ByteString\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x197271cacf44fd889b254b99e78ceada93f38ee1128ba06e0ccbd5491dee31ad\",\"urls\":[\"bzz-raw://69c561a7522bd48a02038c330f3271b7507f95b065d8f28100e185eab8f8732d\",\"dweb:/ipfs/QmUbw3H7DNd2QcUa65BXtHqWazZwSRheVNnATnUGpkWZiU\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:SynapseTypes":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dc017f6281bd284a75fcf83606176abbb50f2a61d1fd22a8026c953510a0fa5a64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220dc017f6281bd284a75fcf83606176abbb50f2a61d1fd22a8026c953510a0fa5a64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35536:4460:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;35536:4460:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"35536:4460:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"SynapseTypes\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x197271cacf44fd889b254b99e78ceada93f38ee1128ba06e0ccbd5491dee31ad\",\"urls\":[\"bzz-raw://69c561a7522bd48a02038c330f3271b7507f95b065d8f28100e185eab8f8732d\",\"dweb:/ipfs/QmUbw3H7DNd2QcUa65BXtHqWazZwSRheVNnATnUGpkWZiU\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.t.sol:TypedMemView":{"code":"0x6101f061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220110df5fb752464bda323895a4570e59dca1c48d110847776887e6db6d73f9c7b64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600436106100ad5760003560e01c806397b8ad4a11610080578063eb74062811610065578063eb740628146100f8578063f26be3fc14610100578063fb734584146100f857600080fd5b806397b8ad4a146100cd578063b602d173146100e557600080fd5b806310153fce146100b25780631136e7ea146100cd57806313090c5a146100d55780631bfe17ce146100dd575b600080fd5b6100ba602881565b6040519081526020015b60405180910390f35b6100ba601881565b6100ba610158565b6100ba610172565b6100ba6bffffffffffffffffffffffff81565b6100ba606081565b6101277fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000090911681526020016100c4565b606061016581601861017a565b61016f919061017a565b81565b61016f606060185b808201808211156101b4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b9291505056fea2646970667358221220110df5fb752464bda323895a4570e59dca1c48d110847776887e6db6d73f9c7b64736f6c63430008110033","info":{"source":"pragma solidity 0.8.17;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifier onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\n    /**\n     * @dev Memory layout for bytes29\n     * [000..005)   type     5 bytes    Type flag for the pointer\n     * [005..017)   loc     12 bytes    Memory address of underlying bytes\n     * [017..029)   len     12 bytes    Length of underlying bytes\n     * [029..032)   empty    3 bytes    Not used\n     */\n    uint256 public constant BITS_TYPE = 40;\n    uint256 public constant BITS_LOC = 96;\n    uint256 public constant BITS_LEN = 96;\n    uint256 public constant BITS_EMPTY = 24;\n\n    // `SHIFT_X` is how much bits to shift for `X` to be in the very bottom bits\n    uint256 public constant SHIFT_LEN = BITS_EMPTY; // 24\n    uint256 public constant SHIFT_LOC = SHIFT_LEN + BITS_LEN; // 24 + 96 = 120\n    uint256 public constant SHIFT_TYPE = SHIFT_LOC + BITS_LOC; // 24 + 96 + 96 = 216\n    // Bitmask for the lowest 96 bits\n    uint256 public constant LOW_96_BITS_MASK = type(uint96).max;\n\n    // For nibble encoding\n    bytes private constant NIBBLE_LOOKUP = \"0123456789abcdef\";\n\n    /**\n     * @notice Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _byte     The byte\n     * @return _char    The encoded hex character\n     */\n    function nibbleHex(uint8 _byte) internal pure returns (uint8 _char) {\n        uint8 _nibble = _byte \u0026 0x0f; // keep bottom 4 bits, zero out top 4 bits\n        _char = uint8(NIBBLE_LOOKUP[_nibble]);\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // 0x800...00 binary representation is 100...00\n        // sar stands for \"signed arithmetic shift\": https://en.wikipedia.org/wiki/Arithmetic_shift\n        // sar(N-1, 100...00) = 11...100..00, with exactly N highest bits set to 1\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    // solhint-disable-next-line ordering\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // View is valid if (\"upper bound\" \u003c= \"unallocated memory pointer\")\n            // Upper bound is exclusive, hence \"\u003c=\"\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // How many bits are the \"type bits\" occupying\n        uint256 _bitsType = BITS_TYPE;\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the \"type bits\" (shift left, then sift right)\n            newView := or(newView, shr(_bitsType, shl(_bitsType, memView)))\n            // set the new \"type bits\" (shift left, then OR)\n            newView := or(newView, shl(_shiftType, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        uint256 _bitsLoc = BITS_LOC;\n        uint256 _bitsLen = BITS_LEN;\n        uint256 _bitsEmpty = BITS_EMPTY;\n        // Ref memory layout\n        // [000..005) 5 bytes of type\n        // [005..017) 12 bytes of location\n        // [017..029) 12 bytes of length\n        // last 3 bits are blank and dropped in typecast\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // insert `type`, shift to prepare empty bits for `loc`\n            newView := shl(_bitsLoc, or(newView, _type))\n            // insert `loc`, shift to prepare empty bits for `len`\n            newView := shl(_bitsLen, or(newView, _loc))\n            // insert `len`, shift to insert 3 blank lowest bits\n            newView := shl(_bitsEmpty, or(newView, _len))\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        // Make sure that a view is not constructed that points to unallocated memory\n        // as this could be indicative of a buffer overflow attack\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // We add 0x20, so that the view starts exactly where the array data starts\n            _loc := add(arr, 0x20)\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        // How many bits are the \"type bits\" shifted from the bottom\n        uint256 _shiftType = SHIFT_TYPE;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"type bits\". \"type bits\" are occupying\n            // the highest bits, so all that's left is \"type bits\", OR is not required.\n            _type := shr(_shiftType, memView)\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        // Check that the highest 5 bytes are equal: xor and shift out lower 27 bytes\n        return (left ^ right) \u003e\u003e SHIFT_TYPE == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        // How many bits are the \"loc bits\" shifted from the bottom\n        uint256 _shiftLoc = SHIFT_LOC;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"loc bits\".\n            // Then use the lowest 96 bits to determine `loc` by applying the bit-mask.\n            _loc := and(shr(_shiftLoc, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        // returning ceil(length / 32.0)\n        return (uint256(len(memView)) + 31) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        // How many bits are the \"len bits\" shifted from the bottom\n        uint256 _shiftLen = SHIFT_LEN;\n        // Mask for the bottom 96 bits\n        uint256 _uint96Mask = LOW_96_BITS_MASK;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Shift out the bottom bits preceding \"len bits\".\n            // Then use the lowest 96 bits to determine `len` by applying the bit-mask.\n            _len := and(shr(_shiftLen, memView), _uint96Mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing\n     *                  bytes from `_index` to end(memView).\n     * @param memView   The view\n     * @param _index    The start index\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function sliceFrom(\n        bytes29 memView,\n        uint256 _index,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, _index, len(memView) - _index, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"Index: more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        // Get a mask with `bitLength` highest bits set\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // Load a full word using index offset, and apply mask to ignore non-relevant bytes\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        // `index()` returns left-aligned `_bytes`, while integers are right-aligned\n        // Shifting here to right-align with the full 32 bytes word\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`.\n     *                  Requires that the view have \u003e= 20 bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        // index 20 bytes as `uint160`, and then cast to `address`\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            digest := mload(ptr)\n        }\n        require(res, \"sha2: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            // rmd160 precompile is 0x03\n            res := and(res, staticcall(gas(), 0x03, ptr, 0x20, ptr, 0x20))\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n        require(res, \"hash160: out of gas\");\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // sha2 precompile is 0x02\n            res := staticcall(gas(), 0x02, _loc, _len, ptr, 0x20)\n            res := and(res, staticcall(gas(), 0x02, ptr, 0x20, ptr, 0x20))\n            digest := mload(ptr)\n        }\n        require(res, \"hash256: out of gas\");\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"copyTo: Null pointer deref\");\n        require(isValid(memView), \"copyTo: Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        bool res;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile (0x04) to copy\n            res := staticcall(gas(), 0x04, _oldLoc, _len, _newLoc, _len)\n        }\n        require(res, \"identity: out of gas\");\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory,\n     *                  returning a `bytes` pointing to the new memory.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the length\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary SynapseTypes {\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          0X00: BYTE STRINGS                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * 1. RAW_BYTES refers to a generic byte string, that is not supposed to be parsed\n     * by the messaging contracts. RAW_BYTES is set to uint40(0) so that\n     * the \"default zero\" type would represent a generic byte string.\n     * 2. SIGNATURE refers to 65 bytes string that is an off-chain agent signature for some data.\n     * 3. CALL_PAYLOAD refers to the payload, that is supposed to be used for an external call, i.e.\n     * recipient.call(CALL_PAYLOAD). Its length is always (4 + 32 * N) bytes:\n     *      - First 4 bytes represent the function selector.\n     *      - 32 * N bytes represent N function arguments.\n     */\n    // prettier-ignore\n    uint40 internal constant RAW_BYTES                  = 0x00_00_00_00_00;\n    // prettier-ignore\n    uint40 internal constant SIGNATURE                  = 0x00_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant CALL_PAYLOAD               = 0x00_02_00_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X01: ATTESTATION                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant ATTESTATION                = 0x01_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant ATTESTATION_DATA           = 0x01_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X02: REPORT                                 ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant REPORT                     = 0x02_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant REPORT_DATA                = 0x02_01_01_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         0X03: MESSAGE                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant MESSAGE                    = 0x03_01_00_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_HEADER             = 0x03_01_01_00_00;\n    // prettier-ignore\n    uint40 internal constant MESSAGE_TIPS               = 0x03_01_02_00_00;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                             0X04: SYSTEM                             ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // prettier-ignore\n    uint40 internal constant SYSTEM_CALL                = 0x04_00_00_00_00;\n}\n\nlibrary ByteString {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev non-compact ECDSA signatures are enforced as of OZ 4.7.3\n     *\n     *      Signature payload memory layout\n     * [000 .. 032) r   bytes32 32 bytes\n     * [032 .. 064) s   bytes32 32 bytes\n     * [064 .. 065) v   uint8    1 byte\n     */\n    uint256 internal constant SIGNATURE_LENGTH = 65;\n    uint256 internal constant OFFSET_R = 0;\n    uint256 internal constant OFFSET_S = 32;\n    uint256 internal constant OFFSET_V = 64;\n\n    /**\n     * @dev Call payload memory layout\n     * [000 .. 004) selector    bytes4  4 bytes\n     *      Optional: N function arguments\n     * [004 .. 036) arg1        bytes32 32 bytes\n     *      ..\n     * [AAA .. END) argN        bytes32 32 bytes\n     */\n    uint256 internal constant SELECTOR_LENGTH = 4;\n    uint256 internal constant OFFSET_SELECTOR = 0;\n    uint256 internal constant OFFSET_ARGUMENTS = SELECTOR_LENGTH;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyType(bytes29 _view, uint40 _type) {\n        _view.assertType(_type);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Constructs the signature payload from the given values.\n     * @dev Using ByteString.formatSignature({r: r, s: s, v: v}) will make sure\n     * that params are given in the right order.\n     */\n    function formatSignature(\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a raw bytes payload.\n     */\n    function castToRawBytes(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.RAW_BYTES);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a signature payload.\n     */\n    function castToSignature(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.SIGNATURE);\n    }\n\n    /**\n     * @notice Checks that a byte string is a signature\n     */\n    function isSignature(bytes29 _view) internal pure returns (bool) {\n        return _view.len() == SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for a call payload.\n     */\n    function castToCallPayload(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.CALL_PAYLOAD);\n    }\n\n    /**\n     * @notice Checks that a byte string is a call payload, i.e.\n     * a function selector, followed by arbitrary amount of arguments.\n     */\n    function isCallPayload(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // Call payload should at least have a function selector\n        if (length \u003c SELECTOR_LENGTH) return false;\n        // The remainder of the payload should be exactly N words (N \u003e= 0), i.e.\n        // (length - SELECTOR_LENGTH) % 32 == 0\n        // We're using logical AND here to speed it up a bit\n        return (length - SELECTOR_LENGTH) \u0026 31 == 0;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         CALL PAYLOAD SLICING                         ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns amount of memory words (32 byte chunks) the function arguments\n     * occupy in the call payload.\n     * @dev This might differ from amount of arguments supplied, if any of the arguments\n     * occupies more than one memory slot. It is true, however, that argument part of the payload\n     * occupies exactly N words, even for dynamic types like `bytes`\n     */\n    function argumentWords(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (uint256)\n    {\n        // Equivalent of (length - SELECTOR_LENGTH) / 32\n        return (_view.len() - SELECTOR_LENGTH) \u003e\u003e 5;\n    }\n\n    /// @notice Returns selector for the provided call payload.\n    function callSelector(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return\n            _view.slice({\n                _index: OFFSET_SELECTOR,\n                _len: SELECTOR_LENGTH,\n                newType: SynapseTypes.RAW_BYTES\n            });\n    }\n\n    /// @notice Returns abi encoded arguments for the provided call payload.\n    function argumentsPayload(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.CALL_PAYLOAD)\n        returns (bytes29)\n    {\n        return _view.sliceFrom({ _index: OFFSET_ARGUMENTS, newType: SynapseTypes.RAW_BYTES });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                          SIGNATURE SLICING                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /// @notice Unpacks signature payload into (r, s, v) parameters.\n    /// @dev Make sure to verify signature length with isSignature() beforehand.\n    function toRSV(bytes29 _view)\n        internal\n        pure\n        onlyType(_view, SynapseTypes.SIGNATURE)\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        r = _view.index({ _index: OFFSET_R, _bytes: 32 });\n        s = _view.index({ _index: OFFSET_S, _bytes: 32 });\n        v = uint8(_view.indexUint({ _index: OFFSET_V, _bytes: 1 }));\n    }\n}\n\nlibrary Attestation {\n    using ByteString for bytes;\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): origin         uint32   4 bytes\n     * [004 .. 008): destination    uint32   4 bytes\n     * [008 .. 012): nonce          uint32   4 bytes\n     * [012 .. 044): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 044): attData        bytes   44 bytes (see above)\n     * [044 .. 045): G = guardSigs  uint8    1 byte\n     * [045 .. 046): N = notarySigs uint8    1 byte\n     * [046 .. 111): guardSig[0]    bytes   65 bytes\n     *      ..\n     * [AAA .. BBB): guardSig[G-1]  bytes   65 bytes\n     * [BBB .. CCC): notarySig[0]   bytes   65 bytes\n     *      ..\n     * [DDD .. END): notarySig[N-1] bytes   65 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 0;\n    uint256 internal constant OFFSET_DESTINATION = 4;\n    uint256 internal constant OFFSET_NONCE = 8;\n    uint256 internal constant OFFSET_ROOT = 12;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 44;\n\n    uint256 internal constant OFFSET_AGENT_SIGS = ATTESTATION_DATA_LENGTH;\n    uint256 internal constant OFFSET_FIRST_SIGNATURE = OFFSET_AGENT_SIGS + 2;\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              MODIFIERS                               ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    modifier onlyAttestation(bytes29 _view) {\n        _view.assertType(SynapseTypes.ATTESTATION);\n        _;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns a formatted Attestation payload with provided fields\n     * @dev `_guardSignatures` and `_notarySignatures` payloads could be empty.\n     * They have to contain exactly 65 * N bytes, otherwise the execution will be reverted.\n     * @param _data                 Attestation Data (see above)\n     * @param _guardSignatures      Payload with all Guard signatures on `_data`\n     * @param _notarySignatures     Payload with all Notary signatures on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) internal view returns (bytes memory) {\n        return\n            formatAttestation({\n                _dataView: _data.castToRawBytes(),\n                _guardSigsView: _guardSignatures.castToRawBytes(),\n                _notarySigsView: _notarySignatures.castToRawBytes()\n            });\n    }\n\n    function formatAttestation(\n        bytes29 _dataView,\n        bytes29 _guardSigsView,\n        bytes29 _notarySigsView\n    ) internal view returns (bytes memory) {\n        uint8 guardSigs = _amountSignatures(_guardSigsView);\n        uint8 notarySigs = _amountSignatures(_notarySigsView);\n        // Pack (guardSigs, notarySigs) into a single 16-byte value\n        uint16 agentSigs = (uint16(guardSigs) \u003c\u003c 8) | notarySigs;\n        // We need to join: `_data`, `agentSigs`, `_guardSignatures`, `_notarySignatures`\n        bytes29[] memory allViews = new bytes29[](4);\n        allViews[0] = _dataView;\n        allViews[1] = abi.encodePacked(agentSigs).castToRawBytes();\n        allViews[2] = _guardSigsView;\n        allViews[3] = _notarySigsView;\n        return TypedMemView.join(allViews);\n    }\n\n    /**\n     * @notice Returns a formatted AttestationData payload with provided fields\n     * @param _origin       Domain of Origin's chain\n     * @param _destination  Domain of Destination's chain\n     * @param _root         New merkle root\n     * @param _nonce        Nonce of the merkle root\n     * @return Formatted attestation data\n     **/\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_origin, _destination, _nonce, _root);\n    }\n\n    /**\n     * @notice Returns a properly typed bytes29 pointer for an attestation payload.\n     */\n    function castToAttestation(bytes memory _payload) internal pure returns (bytes29) {\n        return _payload.ref(SynapseTypes.ATTESTATION);\n    }\n\n    /**\n     * @notice Checks that a payload is a formatted Attestation payload.\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        uint256 length = _view.len();\n        // (attData, guardSigs, notarySigs) need to exist\n        if (length \u003c OFFSET_FIRST_SIGNATURE) return false;\n        (uint256 guardSigs, uint256 notarySigs) = _agentSignatures(_view);\n        uint256 totalSigs = guardSigs + notarySigs;\n        // There should be at least one signature\n        if (totalSigs == 0) return false;\n        // Every signature has length of exactly `ByteString.SIGNATURE_LENGTH`\n        return length == OFFSET_FIRST_SIGNATURE + totalSigs * ByteString.SIGNATURE_LENGTH;\n    }\n\n    /**\n     * @notice Combines origin and destination domains into `attestationDomains`,\n     * a unique ID for every (origin, destination) pair. Could be used to identify\n     * Merkle trees on Origin, or Mirrors on Destination.\n     */\n    function attestationDomains(uint32 _origin, uint32 _destination)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) \u003c\u003c 32) | _destination;\n    }\n\n    /**\n     * @notice Combines origin, destination domains and message nonce into `attestationKey`,\n     * a unique key for every (origin, destination, nonce) tuple. Could be used to identify\n     * any dispatched message.\n     */\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) internal pure returns (uint96) {\n        return (uint96(_origin) \u003c\u003c 64) | (uint96(_destination) \u003c\u003c 32) | _nonce;\n    }\n\n    function unpackDomains(uint64 _attestationDomains)\n        internal\n        pure\n        returns (uint32 origin, uint32 destination)\n    {\n        // Shift out lower 32 bytes\n        origin = uint32(_attestationDomains \u003e\u003e 32);\n        // Use lower 32 bytes\n        destination = uint32(_attestationDomains \u0026 type(uint32).max);\n    }\n\n    function unpackKey(uint96 _attestationKey)\n        internal\n        pure\n        returns (uint64 domains, uint32 nonce)\n    {\n        // Shift out lower 32 bytes\n        domains = uint64(_attestationKey \u003e\u003e 32);\n        // Use lower 32 bytes\n        nonce = uint32(_attestationKey \u0026 type(uint32).max);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                         ATTESTATION SLICING                          ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @notice Returns domain of chain where the Origin contract is deployed\n     */\n    function attestedOrigin(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns domain of chain where the Destination contract is deployed\n     */\n    function attestedDestination(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint32)\n    {\n        return uint32(_view.indexUint({ _index: OFFSET_DESTINATION, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns nonce of Origin contract at the time, when `root` was the Merkle root.\n     */\n    function attestedNonce(bytes29 _view) internal pure onlyAttestation(_view) returns (uint32) {\n        return uint32(_view.indexUint({ _index: OFFSET_NONCE, _bytes: 4 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination). See `attestationDomains()`.\n     */\n    function attestedDomains(bytes29 _view) internal pure onlyAttestation(_view) returns (uint64) {\n        return uint64(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 8 }));\n    }\n\n    /**\n     * @notice Returns a combined field for (origin, destination, nonce). See `attestationKey()`.\n     */\n    function attestedKey(bytes29 _view) internal pure onlyAttestation(_view) returns (uint96) {\n        return uint96(_view.indexUint({ _index: OFFSET_ORIGIN, _bytes: 12 }));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Origin contract\n     */\n    function attestedRoot(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes32) {\n        return _view.index({ _index: OFFSET_ROOT, _bytes: 32 });\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure onlyAttestation(_view) returns (bytes29) {\n        return\n            _view.slice({\n                _index: OFFSET_ORIGIN,\n                _len: ATTESTATION_DATA_LENGTH,\n                newType: SynapseTypes.ATTESTATION_DATA\n            });\n    }\n\n    /**\n     * @notice Returns the amount of guard and notary signatures present in the Attestation.\n     */\n    function agentSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        (guardSigs, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of guard signatures present in the Attestation.\n     */\n    function guardSignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 guardSigs)\n    {\n        (guardSigs, ) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns the amount of notary signatures present in the Attestation.\n     */\n    function notarySignatures(bytes29 _view)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (uint8 notarySigs)\n    {\n        (, notarySigs) = _agentSignatures(_view);\n    }\n\n    /**\n     * @notice Returns signature of the i-th Guard on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function guardSignature(bytes29 _view, uint256 _guardIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, ) = _agentSignatures(_view);\n        require(_guardIndex \u003c guardSigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE + _guardIndex * ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /**\n     * @notice Returns signature of the i-th Notary on AttestationData,\n     * @dev Will revert if index is out of range.\n     */\n    function notarySignature(bytes29 _view, uint256 _notaryIndex)\n        internal\n        pure\n        onlyAttestation(_view)\n        returns (bytes29)\n    {\n        (uint8 guardSigs, uint8 notarySigs) = _agentSignatures(_view);\n        require(_notaryIndex \u003c notarySigs, \"Out of range\");\n        return\n            _view.slice({\n                _index: OFFSET_FIRST_SIGNATURE +\n                    (_notaryIndex + guardSigs) *\n                    ByteString.SIGNATURE_LENGTH,\n                _len: ByteString.SIGNATURE_LENGTH,\n                newType: SynapseTypes.SIGNATURE\n            });\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           PRIVATE HELPERS                            ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    /**\n     * @dev Returns the amount of guard and notary signatures present in the Attestation.\n     * Doesn't check the pointer type - to be used in functions that perform the typecheck.\n     */\n    function _agentSignatures(bytes29 _view)\n        private\n        pure\n        returns (uint8 guardSigs, uint8 notarySigs)\n    {\n        // Read both amounts at once\n        uint16 combinedAmounts = uint16(_view.indexUint({ _index: OFFSET_AGENT_SIGS, _bytes: 2 }));\n        // First 8 bits is the amount of guard signatures\n        guardSigs = uint8(combinedAmounts \u003e\u003e 8);\n        // Last 8 bits is the amount of notary signatures\n        notarySigs = uint8(combinedAmounts \u0026 0xFF);\n    }\n\n    /**\n     * @dev Returns the amount of signatures in the \"signatures\" payload.\n     * Reverts, if payload length is not exactly 65 * N bytes.\n     * Reverts, if amount of signatures does not fit in `uint8`.\n     */\n    function _amountSignatures(bytes29 _sigsView) private pure returns (uint8 amount) {\n        uint256 length = _sigsView.len();\n        uint256 _amount = length / ByteString.SIGNATURE_LENGTH;\n        require(_amount * ByteString.SIGNATURE_LENGTH == length, \"!signaturesLength\");\n        require(_amount \u003c type(uint8).max, \"Too many signatures\");\n        amount = uint8(_amount);\n    }\n}\n\n// \n/**\n * @notice Exposes Attestation methods for testing against golang.\n */\ncontract AttestationHarness {\n    using Attestation for bytes;\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint256 internal requestedIndex;\n\n    function setIndex(uint256 index) external {\n        requestedIndex = index;\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                               GETTERS                                ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function castToAttestation(uint40, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        // Walkaround to get the forge coverage working on libraries, see\n        // https://github.com/foundry-rs/foundry/pull/3128#issuecomment-1241245086\n        bytes29 _view = Attestation.castToAttestation(_payload);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestationData(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).attestationData();\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function guardSignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).guardSignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function notarySignature(uint40 _type, bytes memory _payload)\n        public\n        view\n        returns (uint40, bytes memory)\n    {\n        bytes29 _view = _payload.ref(_type).notarySignature(requestedIndex);\n        return (_view.typeOf(), _view.clone());\n    }\n\n    function attestedOrigin(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedOrigin();\n    }\n\n    function attestedDestination(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedDestination();\n    }\n\n    function attestedNonce(uint40 _type, bytes memory _payload) public pure returns (uint32) {\n        return _payload.ref(_type).attestedNonce();\n    }\n\n    function attestedDomains(uint40 _type, bytes memory _payload) public pure returns (uint64) {\n        return _payload.ref(_type).attestedDomains();\n    }\n\n    function attestedKey(uint40 _type, bytes memory _payload) public pure returns (uint96) {\n        return _payload.ref(_type).attestedKey();\n    }\n\n    function attestedRoot(uint40 _type, bytes memory _payload) public pure returns (bytes32) {\n        return _payload.ref(_type).attestedRoot();\n    }\n\n    function agentSignatures(uint40 _type, bytes memory _payload)\n        public\n        pure\n        returns (uint8, uint8)\n    {\n        return _payload.ref(_type).agentSignatures();\n    }\n\n    function guardSignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).guardSignatures();\n    }\n\n    function notarySignatures(uint40 _type, bytes memory _payload) public pure returns (uint8) {\n        return _payload.ref(_type).notarySignatures();\n    }\n\n    function isAttestation(bytes memory _payload) public pure returns (bool) {\n        return _payload.castToAttestation().isAttestation();\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                              FORMATTERS                              ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    // solhint-disable-next-line ordering\n    function formatAttestation(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return Attestation.formatAttestation(_data, _guardSignatures, _notarySignatures);\n    }\n\n    function formatAttestationFromViews(\n        bytes memory _data,\n        bytes memory _guardSignatures,\n        bytes memory _notarySignatures\n    ) public view returns (bytes memory) {\n        return\n            Attestation.formatAttestation({\n                _dataView: _data.ref(0),\n                _guardSigsView: _guardSignatures.ref(0),\n                _notarySigsView: _notarySignatures.ref(0)\n            });\n    }\n\n    function formatAttestationData(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_origin, _destination, _nonce, _root);\n    }\n\n    function attestationDomains(uint32 _origin, uint32 _destination) public pure returns (uint64) {\n        return Attestation.attestationDomains(_origin, _destination);\n    }\n\n    function attestationKey(\n        uint32 _origin,\n        uint32 _destination,\n        uint32 _nonce\n    ) public pure returns (uint96) {\n        return Attestation.attestationKey(_origin, _destination, _nonce);\n    }\n\n    function unpackDomains(uint64 _attestationDomains) public pure returns (uint32, uint32) {\n        return Attestation.unpackDomains(_attestationDomains);\n    }\n\n    function unpackKey(uint96 _attestationKey) public pure returns (uint64 domains, uint32 nonce) {\n        return Attestation.unpackKey(_attestationKey);\n    }\n\n    /*╔══════════════════════════════════════════════════════════════════════╗*\\\n    ▏*║                           CONSTANT GETTERS                           ║*▕\n    \\*╚══════════════════════════════════════════════════════════════════════╝*/\n\n    function attestationDataLength() public pure returns (uint256) {\n        return Attestation.ATTESTATION_DATA_LENGTH;\n    }\n\n    function offsetOrigin() public pure returns (uint256) {\n        return Attestation.OFFSET_ORIGIN;\n    }\n\n    function offsetDestination() public pure returns (uint256) {\n        return Attestation.OFFSET_DESTINATION;\n    }\n\n    function offsetNonce() public pure returns (uint256) {\n        return Attestation.OFFSET_NONCE;\n    }\n\n    function offsetRoot() public pure returns (uint256) {\n        return Attestation.OFFSET_ROOT;\n    }\n\n    function offsetAgentSignatures() public pure returns (uint256) {\n        return Attestation.OFFSET_AGENT_SIGS;\n    }\n\n    function offsetFirstSignature() public pure returns (uint256) {\n        return Attestation.OFFSET_FIRST_SIGNATURE;\n    }\n}","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:35508:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:35508:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:35508:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2952:38;;2988:2;2952:38;;;;;168:25:1;;;156:2;141:18;2952:38:0;;;;;;;;3209:46;;3119:2;3209:46;;3346:57;;;:::i;3267:56::-;;;:::i;3469:59::-;;3512:16;3469:59;;3039:37;;3074:2;3039:37;;2540:94;;;;;;;;388:66:1;376:79;;;358:98;;346:2;331:18;2540:94:0;204:258:1;3346:57:0;3031:2;3303:20;3031:2;3119;3303:20;:::i;:::-;3383;;;;:::i;:::-;3346:57;:::o;3267:56::-;3303:20;3074:2;3119;467:279:1;532:9;;;553:10;;;550:190;;;596:77;593:1;586:88;697:4;694:1;687:15;725:4;722:1;715:15;550:190;467:279;;;;:::o","abiDefinition":[{"inputs":[],"name":"BITS_EMPTY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BITS_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LOW_96_BITS_MASK","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LEN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_LOC","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SHIFT_TYPE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"BITS_TYPE":{"details":"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BITS_EMPTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITS_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOW_96_BITS_MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_LOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"BITS_TYPE\":{\"details\":\"Memory layout for bytes29 [000..005)   type     5 bytes    Type flag for the pointer [005..017)   loc     12 bytes    Memory address of underlying bytes [017..029)   len     12 bytes    Length of underlying bytes [029..032)   empty    3 bytes    Not used\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.t.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.t.sol\":{\"keccak256\":\"0x197271cacf44fd889b254b99e78ceada93f38ee1128ba06e0ccbd5491dee31ad\",\"urls\":[\"bzz-raw://69c561a7522bd48a02038c330f3271b7507f95b065d8f28100e185eab8f8732d\",\"dweb:/ipfs/QmUbw3H7DNd2QcUa65BXtHqWazZwSRheVNnATnUGpkWZiU\"]}},\"version\":1}"},"hashes":{"BITS_EMPTY()":"97b8ad4a","BITS_LEN()":"eb740628","BITS_LOC()":"fb734584","BITS_TYPE()":"10153fce","LOW_96_BITS_MASK()":"b602d173","NULL()":"f26be3fc","SHIFT_LEN()":"1136e7ea","SHIFT_LOC()":"1bfe17ce","SHIFT_TYPE()":"13090c5a"}}}