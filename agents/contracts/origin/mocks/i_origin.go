// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	mock "github.com/stretchr/testify/mock"

	origin "github.com/synapsecns/sanguine/agents/contracts/origin"

	types "github.com/ethereum/go-ethereum/core/types"
)

// IOrigin is an autogenerated mock type for the IOrigin type
type IOrigin struct {
	mock.Mock
}

// AddGuard provides a mock function with given fields: opts, _guard
func (_m *IOrigin) AddGuard(opts *bind.TransactOpts, _guard common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _guard)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _guard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _guard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNotary provides a mock function with given fields: opts, _domain, _notary
func (_m *IOrigin) AddNotary(opts *bind.TransactOpts, _domain uint32, _notary common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _domain, _notary)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _domain, _notary)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, common.Address) error); ok {
		r1 = rf(opts, _domain, _notary)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Address provides a mock function with given fields:
func (_m *IOrigin) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AllAgents provides a mock function with given fields: opts, _domain
func (_m *IOrigin) AllAgents(opts *bind.CallOpts, _domain uint32) ([]common.Address, error) {
	ret := _m.Called(opts, _domain)

	var r0 []common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) []common.Address); ok {
		r0 = rf(opts, _domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, _domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllDomains provides a mock function with given fields: opts
func (_m *IOrigin) AllDomains(opts *bind.CallOpts) ([]uint32, error) {
	ret := _m.Called(opts)

	var r0 []uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []uint32); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint32)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AmountAgents provides a mock function with given fields: opts, _domain
func (_m *IOrigin) AmountAgents(opts *bind.CallOpts, _domain uint32) (*big.Int, error) {
	ret := _m.Called(opts, _domain)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) *big.Int); ok {
		r0 = rf(opts, _domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, _domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AmountDomains provides a mock function with given fields: opts
func (_m *IOrigin) AmountDomains(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Dispatch provides a mock function with given fields: opts, _destination, _recipient, _optimisticSeconds, _tips, _messageBody
func (_m *IOrigin) Dispatch(opts *bind.TransactOpts, _destination uint32, _recipient [32]byte, _optimisticSeconds uint32, _tips []byte, _messageBody []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _destination, _recipient, _optimisticSeconds, _tips, _messageBody)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, [32]byte, uint32, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, _destination, _recipient, _optimisticSeconds, _tips, _messageBody)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, [32]byte, uint32, []byte, []byte) error); ok {
		r1 = rf(opts, _destination, _recipient, _optimisticSeconds, _tips, _messageBody)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterAgentAdded provides a mock function with given fields: opts, domain, account
func (_m *IOrigin) FilterAgentAdded(opts *bind.FilterOpts, domain []uint32, account []common.Address) (*origin.OriginAgentAddedIterator, error) {
	ret := _m.Called(opts, domain, account)

	var r0 *origin.OriginAgentAddedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) *origin.OriginAgentAddedIterator); ok {
		r0 = rf(opts, domain, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginAgentAddedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, []common.Address) error); ok {
		r1 = rf(opts, domain, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterAgentRemoved provides a mock function with given fields: opts, domain, account
func (_m *IOrigin) FilterAgentRemoved(opts *bind.FilterOpts, domain []uint32, account []common.Address) (*origin.OriginAgentRemovedIterator, error) {
	ret := _m.Called(opts, domain, account)

	var r0 *origin.OriginAgentRemovedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) *origin.OriginAgentRemovedIterator); ok {
		r0 = rf(opts, domain, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginAgentRemovedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, []common.Address) error); ok {
		r1 = rf(opts, domain, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterAttestationAccepted provides a mock function with given fields: opts
func (_m *IOrigin) FilterAttestationAccepted(opts *bind.FilterOpts) (*origin.OriginAttestationAcceptedIterator, error) {
	ret := _m.Called(opts)

	var r0 *origin.OriginAttestationAcceptedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *origin.OriginAttestationAcceptedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginAttestationAcceptedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterCorrectFraudReport provides a mock function with given fields: opts, guard
func (_m *IOrigin) FilterCorrectFraudReport(opts *bind.FilterOpts, guard []common.Address) (*origin.OriginCorrectFraudReportIterator, error) {
	ret := _m.Called(opts, guard)

	var r0 *origin.OriginCorrectFraudReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *origin.OriginCorrectFraudReportIterator); ok {
		r0 = rf(opts, guard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginCorrectFraudReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, guard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDispatch provides a mock function with given fields: opts, messageHash, nonce, destination
func (_m *IOrigin) FilterDispatch(opts *bind.FilterOpts, messageHash [][32]byte, nonce []uint32, destination []uint32) (*origin.OriginDispatchIterator, error) {
	ret := _m.Called(opts, messageHash, nonce, destination)

	var r0 *origin.OriginDispatchIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []uint32, []uint32) *origin.OriginDispatchIterator); ok {
		r0 = rf(opts, messageHash, nonce, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginDispatchIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []uint32, []uint32) error); ok {
		r1 = rf(opts, messageHash, nonce, destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDomainActivated provides a mock function with given fields: opts, domain
func (_m *IOrigin) FilterDomainActivated(opts *bind.FilterOpts, domain []uint32) (*origin.OriginDomainActivatedIterator, error) {
	ret := _m.Called(opts, domain)

	var r0 *origin.OriginDomainActivatedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) *origin.OriginDomainActivatedIterator); ok {
		r0 = rf(opts, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginDomainActivatedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32) error); ok {
		r1 = rf(opts, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDomainDeactivated provides a mock function with given fields: opts, domain
func (_m *IOrigin) FilterDomainDeactivated(opts *bind.FilterOpts, domain []uint32) (*origin.OriginDomainDeactivatedIterator, error) {
	ret := _m.Called(opts, domain)

	var r0 *origin.OriginDomainDeactivatedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) *origin.OriginDomainDeactivatedIterator); ok {
		r0 = rf(opts, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginDomainDeactivatedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32) error); ok {
		r1 = rf(opts, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterFraudAttestation provides a mock function with given fields: opts
func (_m *IOrigin) FilterFraudAttestation(opts *bind.FilterOpts) (*origin.OriginFraudAttestationIterator, error) {
	ret := _m.Called(opts)

	var r0 *origin.OriginFraudAttestationIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *origin.OriginFraudAttestationIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginFraudAttestationIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterGuardSlashed provides a mock function with given fields: opts, guard, reporter
func (_m *IOrigin) FilterGuardSlashed(opts *bind.FilterOpts, guard []common.Address, reporter []common.Address) (*origin.OriginGuardSlashedIterator, error) {
	ret := _m.Called(opts, guard, reporter)

	var r0 *origin.OriginGuardSlashedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *origin.OriginGuardSlashedIterator); ok {
		r0 = rf(opts, guard, reporter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginGuardSlashedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, guard, reporter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterIncorrectReport provides a mock function with given fields: opts, guard
func (_m *IOrigin) FilterIncorrectReport(opts *bind.FilterOpts, guard []common.Address) (*origin.OriginIncorrectReportIterator, error) {
	ret := _m.Called(opts, guard)

	var r0 *origin.OriginIncorrectReportIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *origin.OriginIncorrectReportIterator); ok {
		r0 = rf(opts, guard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginIncorrectReportIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, guard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInitialized provides a mock function with given fields: opts
func (_m *IOrigin) FilterInitialized(opts *bind.FilterOpts) (*origin.OriginInitializedIterator, error) {
	ret := _m.Called(opts)

	var r0 *origin.OriginInitializedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *origin.OriginInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginInitializedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNotarySlashed provides a mock function with given fields: opts, notary, guard, reporter
func (_m *IOrigin) FilterNotarySlashed(opts *bind.FilterOpts, notary []common.Address, guard []common.Address, reporter []common.Address) (*origin.OriginNotarySlashedIterator, error) {
	ret := _m.Called(opts, notary, guard, reporter)

	var r0 *origin.OriginNotarySlashedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address, []common.Address) *origin.OriginNotarySlashedIterator); ok {
		r0 = rf(opts, notary, guard, reporter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginNotarySlashedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, notary, guard, reporter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IOrigin) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*origin.OriginOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *origin.OriginOwnershipTransferredIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *origin.OriginOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginOwnershipTransferredIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgent provides a mock function with given fields: opts, _domain, _agentIndex
func (_m *IOrigin) GetAgent(opts *bind.CallOpts, _domain uint32, _agentIndex *big.Int) (common.Address, error) {
	ret := _m.Called(opts, _domain, _agentIndex)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, *big.Int) common.Address); ok {
		r0 = rf(opts, _domain, _agentIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, *big.Int) error); ok {
		r1 = rf(opts, _domain, _agentIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDomain provides a mock function with given fields: opts, _domainIndex
func (_m *IOrigin) GetDomain(opts *bind.CallOpts, _domainIndex *big.Int) (uint32, error) {
	ret := _m.Called(opts, _domainIndex)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) uint32); ok {
		r0 = rf(opts, _domainIndex)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, _domainIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHistoricalRoot provides a mock function with given fields: opts, _destination, _nonce
func (_m *IOrigin) GetHistoricalRoot(opts *bind.CallOpts, _destination uint32, _nonce uint32) ([32]byte, error) {
	ret := _m.Called(opts, _destination, _nonce)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, uint32) [32]byte); ok {
		r0 = rf(opts, _destination, _nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, uint32) error); ok {
		r1 = rf(opts, _destination, _nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Initialize provides a mock function with given fields: opts
func (_m *IOrigin) Initialize(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsActiveAgent provides a mock function with given fields: opts, _domain, _account
func (_m *IOrigin) IsActiveAgent(opts *bind.CallOpts, _domain uint32, _account common.Address) (bool, error) {
	ret := _m.Called(opts, _domain, _account)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, common.Address) bool); ok {
		r0 = rf(opts, _domain, _account)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, common.Address) error); ok {
		r1 = rf(opts, _domain, _account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsActiveAgent0 provides a mock function with given fields: opts, _account
func (_m *IOrigin) IsActiveAgent0(opts *bind.CallOpts, _account common.Address) (bool, error) {
	ret := _m.Called(opts, _account)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) bool); ok {
		r0 = rf(opts, _account)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, _account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsActiveDomain provides a mock function with given fields: opts, _domain
func (_m *IOrigin) IsActiveDomain(opts *bind.CallOpts, _domain uint32) (bool, error) {
	ret := _m.Called(opts, _domain)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) bool); ok {
		r0 = rf(opts, _domain)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, _domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalDomain provides a mock function with given fields: opts
func (_m *IOrigin) LocalDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MAXMESSAGEBODYBYTES provides a mock function with given fields: opts
func (_m *IOrigin) MAXMESSAGEBODYBYTES(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Nonce provides a mock function with given fields: opts, _destination
func (_m *IOrigin) Nonce(opts *bind.CallOpts, _destination uint32) (uint32, error) {
	ret := _m.Called(opts, _destination)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) uint32); ok {
		r0 = rf(opts, _destination)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, _destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *IOrigin) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseAgentAdded provides a mock function with given fields: log
func (_m *IOrigin) ParseAgentAdded(log types.Log) (*origin.OriginAgentAdded, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginAgentAdded
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginAgentAdded); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginAgentAdded)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseAgentRemoved provides a mock function with given fields: log
func (_m *IOrigin) ParseAgentRemoved(log types.Log) (*origin.OriginAgentRemoved, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginAgentRemoved
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginAgentRemoved); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginAgentRemoved)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseAttestationAccepted provides a mock function with given fields: log
func (_m *IOrigin) ParseAttestationAccepted(log types.Log) (*origin.OriginAttestationAccepted, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginAttestationAccepted
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginAttestationAccepted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginAttestationAccepted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseCorrectFraudReport provides a mock function with given fields: log
func (_m *IOrigin) ParseCorrectFraudReport(log types.Log) (*origin.OriginCorrectFraudReport, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginCorrectFraudReport
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginCorrectFraudReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginCorrectFraudReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseDispatch provides a mock function with given fields: log
func (_m *IOrigin) ParseDispatch(log types.Log) (*origin.OriginDispatch, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginDispatch
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginDispatch); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginDispatch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseDomainActivated provides a mock function with given fields: log
func (_m *IOrigin) ParseDomainActivated(log types.Log) (*origin.OriginDomainActivated, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginDomainActivated
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginDomainActivated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginDomainActivated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseDomainDeactivated provides a mock function with given fields: log
func (_m *IOrigin) ParseDomainDeactivated(log types.Log) (*origin.OriginDomainDeactivated, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginDomainDeactivated
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginDomainDeactivated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginDomainDeactivated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseFraudAttestation provides a mock function with given fields: log
func (_m *IOrigin) ParseFraudAttestation(log types.Log) (*origin.OriginFraudAttestation, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginFraudAttestation
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginFraudAttestation); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginFraudAttestation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseGuardSlashed provides a mock function with given fields: log
func (_m *IOrigin) ParseGuardSlashed(log types.Log) (*origin.OriginGuardSlashed, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginGuardSlashed
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginGuardSlashed); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginGuardSlashed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseIncorrectReport provides a mock function with given fields: log
func (_m *IOrigin) ParseIncorrectReport(log types.Log) (*origin.OriginIncorrectReport, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginIncorrectReport
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginIncorrectReport); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginIncorrectReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInitialized provides a mock function with given fields: log
func (_m *IOrigin) ParseInitialized(log types.Log) (*origin.OriginInitialized, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginInitialized
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginInitialized)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNotarySlashed provides a mock function with given fields: log
func (_m *IOrigin) ParseNotarySlashed(log types.Log) (*origin.OriginNotarySlashed, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginNotarySlashed
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginNotarySlashed); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginNotarySlashed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *IOrigin) ParseOwnershipTransferred(log types.Log) (*origin.OriginOwnershipTransferred, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginOwnershipTransferred
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginOwnershipTransferred)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Parser provides a mock function with given fields:
func (_m *IOrigin) Parser() origin.Parser {
	ret := _m.Called()

	var r0 origin.Parser
	if rf, ok := ret.Get(0).(func() origin.Parser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(origin.Parser)
		}
	}

	return r0
}

// RemoveGuard provides a mock function with given fields: opts, _guard
func (_m *IOrigin) RemoveGuard(opts *bind.TransactOpts, _guard common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _guard)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _guard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _guard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNotary provides a mock function with given fields: opts, _domain, _notary
func (_m *IOrigin) RemoveNotary(opts *bind.TransactOpts, _domain uint32, _notary common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _domain, _notary)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _domain, _notary)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, common.Address) error); ok {
		r1 = rf(opts, _domain, _notary)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *IOrigin) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Root provides a mock function with given fields: opts, _destination
func (_m *IOrigin) Root(opts *bind.CallOpts, _destination uint32) ([32]byte, error) {
	ret := _m.Called(opts, _destination)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) [32]byte); ok {
		r0 = rf(opts, _destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, _destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SYNAPSEDOMAIN provides a mock function with given fields: opts
func (_m *IOrigin) SYNAPSEDOMAIN(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSystemRouter provides a mock function with given fields: opts, _systemRouter
func (_m *IOrigin) SetSystemRouter(opts *bind.TransactOpts, _systemRouter common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _systemRouter)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _systemRouter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _systemRouter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SlashAgent provides a mock function with given fields: opts, arg0, _callOrigin, _caller, _info
func (_m *IOrigin) SlashAgent(opts *bind.TransactOpts, arg0 *big.Int, _callOrigin uint32, _caller uint8, _info origin.SystemContractAgentInfo) (*types.Transaction, error) {
	ret := _m.Called(opts, arg0, _callOrigin, _caller, _info)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, uint32, uint8, origin.SystemContractAgentInfo) *types.Transaction); ok {
		r0 = rf(opts, arg0, _callOrigin, _caller, _info)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, uint32, uint8, origin.SystemContractAgentInfo) error); ok {
		r1 = rf(opts, arg0, _callOrigin, _caller, _info)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitAttestation provides a mock function with given fields: opts, _attestation
func (_m *IOrigin) SubmitAttestation(opts *bind.TransactOpts, _attestation []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _attestation)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte) *types.Transaction); ok {
		r0 = rf(opts, _attestation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte) error); ok {
		r1 = rf(opts, _attestation)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitReport provides a mock function with given fields: opts, _report
func (_m *IOrigin) SubmitReport(opts *bind.TransactOpts, _report []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _report)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []byte) *types.Transaction); ok {
		r0 = rf(opts, _report)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []byte) error); ok {
		r1 = rf(opts, _report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuggestAttestation provides a mock function with given fields: opts, _destination
func (_m *IOrigin) SuggestAttestation(opts *bind.CallOpts, _destination uint32) ([]byte, error) {
	ret := _m.Called(opts, _destination)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) []byte); ok {
		r0 = rf(opts, _destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, _destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuggestAttestations provides a mock function with given fields: opts
func (_m *IOrigin) SuggestAttestations(opts *bind.CallOpts) ([][]byte, error) {
	ret := _m.Called(opts)

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [][]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncAgents provides a mock function with given fields: opts, arg0, _callOrigin, _caller, _requestID, _removeExisting, _infos
func (_m *IOrigin) SyncAgents(opts *bind.TransactOpts, arg0 *big.Int, _callOrigin uint32, _caller uint8, _requestID *big.Int, _removeExisting bool, _infos []origin.SystemContractAgentInfo) (*types.Transaction, error) {
	ret := _m.Called(opts, arg0, _callOrigin, _caller, _requestID, _removeExisting, _infos)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, uint32, uint8, *big.Int, bool, []origin.SystemContractAgentInfo) *types.Transaction); ok {
		r0 = rf(opts, arg0, _callOrigin, _caller, _requestID, _removeExisting, _infos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, uint32, uint8, *big.Int, bool, []origin.SystemContractAgentInfo) error); ok {
		r1 = rf(opts, arg0, _callOrigin, _caller, _requestID, _removeExisting, _infos)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SystemRouter provides a mock function with given fields: opts
func (_m *IOrigin) SystemRouter(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *IOrigin) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VERSION provides a mock function with given fields: opts
func (_m *IOrigin) VERSION(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	var r0 uint8
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchAgentAdded provides a mock function with given fields: opts, sink, domain, account
func (_m *IOrigin) WatchAgentAdded(opts *bind.WatchOpts, sink chan<- *origin.OriginAgentAdded, domain []uint32, account []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, domain, account)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginAgentAdded, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, domain, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginAgentAdded, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, domain, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchAgentRemoved provides a mock function with given fields: opts, sink, domain, account
func (_m *IOrigin) WatchAgentRemoved(opts *bind.WatchOpts, sink chan<- *origin.OriginAgentRemoved, domain []uint32, account []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, domain, account)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginAgentRemoved, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, domain, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginAgentRemoved, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, domain, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchAttestationAccepted provides a mock function with given fields: opts, sink
func (_m *IOrigin) WatchAttestationAccepted(opts *bind.WatchOpts, sink chan<- *origin.OriginAttestationAccepted) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginAttestationAccepted) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginAttestationAccepted) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchCorrectFraudReport provides a mock function with given fields: opts, sink, guard
func (_m *IOrigin) WatchCorrectFraudReport(opts *bind.WatchOpts, sink chan<- *origin.OriginCorrectFraudReport, guard []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, guard)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginCorrectFraudReport, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, guard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginCorrectFraudReport, []common.Address) error); ok {
		r1 = rf(opts, sink, guard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchDispatch provides a mock function with given fields: opts, sink, messageHash, nonce, destination
func (_m *IOrigin) WatchDispatch(opts *bind.WatchOpts, sink chan<- *origin.OriginDispatch, messageHash [][32]byte, nonce []uint32, destination []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, messageHash, nonce, destination)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginDispatch, [][32]byte, []uint32, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, messageHash, nonce, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginDispatch, [][32]byte, []uint32, []uint32) error); ok {
		r1 = rf(opts, sink, messageHash, nonce, destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchDomainActivated provides a mock function with given fields: opts, sink, domain
func (_m *IOrigin) WatchDomainActivated(opts *bind.WatchOpts, sink chan<- *origin.OriginDomainActivated, domain []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, domain)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginDomainActivated, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginDomainActivated, []uint32) error); ok {
		r1 = rf(opts, sink, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchDomainDeactivated provides a mock function with given fields: opts, sink, domain
func (_m *IOrigin) WatchDomainDeactivated(opts *bind.WatchOpts, sink chan<- *origin.OriginDomainDeactivated, domain []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, domain)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginDomainDeactivated, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, domain)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginDomainDeactivated, []uint32) error); ok {
		r1 = rf(opts, sink, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchFraudAttestation provides a mock function with given fields: opts, sink
func (_m *IOrigin) WatchFraudAttestation(opts *bind.WatchOpts, sink chan<- *origin.OriginFraudAttestation) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginFraudAttestation) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginFraudAttestation) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchGuardSlashed provides a mock function with given fields: opts, sink, guard, reporter
func (_m *IOrigin) WatchGuardSlashed(opts *bind.WatchOpts, sink chan<- *origin.OriginGuardSlashed, guard []common.Address, reporter []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, guard, reporter)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginGuardSlashed, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, guard, reporter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginGuardSlashed, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, guard, reporter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchIncorrectReport provides a mock function with given fields: opts, sink, guard
func (_m *IOrigin) WatchIncorrectReport(opts *bind.WatchOpts, sink chan<- *origin.OriginIncorrectReport, guard []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, guard)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginIncorrectReport, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, guard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginIncorrectReport, []common.Address) error); ok {
		r1 = rf(opts, sink, guard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInitialized provides a mock function with given fields: opts, sink
func (_m *IOrigin) WatchInitialized(opts *bind.WatchOpts, sink chan<- *origin.OriginInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNotarySlashed provides a mock function with given fields: opts, sink, notary, guard, reporter
func (_m *IOrigin) WatchNotarySlashed(opts *bind.WatchOpts, sink chan<- *origin.OriginNotarySlashed, notary []common.Address, guard []common.Address, reporter []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, notary, guard, reporter)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginNotarySlashed, []common.Address, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, notary, guard, reporter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginNotarySlashed, []common.Address, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, notary, guard, reporter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IOrigin) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *origin.OriginOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewIOrigin interface {
	mock.TestingT
	Cleanup(func())
}

// NewIOrigin creates a new instance of IOrigin. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewIOrigin(t mockConstructorTestingTNewIOrigin) *IOrigin {
	mock := &IOrigin{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
