// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	mock "github.com/stretchr/testify/mock"

	origin "github.com/synapsecns/sanguine/agents/contracts/origin"

	types "github.com/ethereum/go-ethereum/core/types"
)

// IOrigin is an autogenerated mock type for the IOrigin type
type IOrigin struct {
	mock.Mock
}

// AcceptOwnership provides a mock function with given fields: opts
func (_m *IOrigin) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Address provides a mock function with given fields:
func (_m *IOrigin) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AgentManager provides a mock function with given fields: opts
func (_m *IOrigin) AgentManager(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AgentStatus provides a mock function with given fields: opts, agent
func (_m *IOrigin) AgentStatus(opts *bind.CallOpts, agent common.Address) (origin.AgentStatus, error) {
	ret := _m.Called(opts, agent)

	var r0 origin.AgentStatus
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) origin.AgentStatus); ok {
		r0 = rf(opts, agent)
	} else {
		r0 = ret.Get(0).(origin.AgentStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, agent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInitialized provides a mock function with given fields: opts
func (_m *IOrigin) FilterInitialized(opts *bind.FilterOpts) (*origin.OriginInitializedIterator, error) {
	ret := _m.Called(opts)

	var r0 *origin.OriginInitializedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *origin.OriginInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginInitializedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferStarted provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IOrigin) FilterOwnershipTransferStarted(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*origin.OriginOwnershipTransferStartedIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *origin.OriginOwnershipTransferStartedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *origin.OriginOwnershipTransferStartedIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginOwnershipTransferStartedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IOrigin) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*origin.OriginOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *origin.OriginOwnershipTransferredIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *origin.OriginOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginOwnershipTransferredIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterSent provides a mock function with given fields: opts, messageHash, nonce, destination
func (_m *IOrigin) FilterSent(opts *bind.FilterOpts, messageHash [][32]byte, nonce []uint32, destination []uint32) (*origin.OriginSentIterator, error) {
	ret := _m.Called(opts, messageHash, nonce, destination)

	var r0 *origin.OriginSentIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []uint32, []uint32) *origin.OriginSentIterator); ok {
		r0 = rf(opts, messageHash, nonce, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginSentIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []uint32, []uint32) error); ok {
		r1 = rf(opts, messageHash, nonce, destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterStateSaved provides a mock function with given fields: opts
func (_m *IOrigin) FilterStateSaved(opts *bind.FilterOpts) (*origin.OriginStateSavedIterator, error) {
	ret := _m.Called(opts)

	var r0 *origin.OriginStateSavedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *origin.OriginStateSavedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginStateSavedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterTipWithdrawalCompleted provides a mock function with given fields: opts
func (_m *IOrigin) FilterTipWithdrawalCompleted(opts *bind.FilterOpts) (*origin.OriginTipWithdrawalCompletedIterator, error) {
	ret := _m.Called(opts)

	var r0 *origin.OriginTipWithdrawalCompletedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *origin.OriginTipWithdrawalCompletedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginTipWithdrawalCompletedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasOracle provides a mock function with given fields: opts
func (_m *IOrigin) GasOracle(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgent provides a mock function with given fields: opts, index
func (_m *IOrigin) GetAgent(opts *bind.CallOpts, index *big.Int) (struct {
	Agent  common.Address
	Status origin.AgentStatus
}, error) {
	ret := _m.Called(opts, index)

	var r0 struct {
		Agent  common.Address
		Status origin.AgentStatus
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) struct {
		Agent  common.Address
		Status origin.AgentStatus
	}); ok {
		r0 = rf(opts, index)
	} else {
		r0 = ret.Get(0).(struct {
			Agent  common.Address
			Status origin.AgentStatus
		})
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMinimumTipsValue provides a mock function with given fields: opts, destination, paddedRequest, contentLength
func (_m *IOrigin) GetMinimumTipsValue(opts *bind.CallOpts, destination uint32, paddedRequest *big.Int, contentLength *big.Int) (*big.Int, error) {
	ret := _m.Called(opts, destination, paddedRequest, contentLength)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) *big.Int); ok {
		r0 = rf(opts, destination, paddedRequest, contentLength)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, destination, paddedRequest, contentLength)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Inbox provides a mock function with given fields: opts
func (_m *IOrigin) Inbox(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Initialize provides a mock function with given fields: opts
func (_m *IOrigin) Initialize(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsValidState provides a mock function with given fields: opts, statePayload
func (_m *IOrigin) IsValidState(opts *bind.CallOpts, statePayload []byte) (bool, error) {
	ret := _m.Called(opts, statePayload)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, []byte) bool); ok {
		r0 = rf(opts, statePayload)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, []byte) error); ok {
		r1 = rf(opts, statePayload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestDisputeStatus provides a mock function with given fields: opts, agentIndex
func (_m *IOrigin) LatestDisputeStatus(opts *bind.CallOpts, agentIndex uint32) (origin.DisputeStatus, error) {
	ret := _m.Called(opts, agentIndex)

	var r0 origin.DisputeStatus
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) origin.DisputeStatus); ok {
		r0 = rf(opts, agentIndex)
	} else {
		r0 = ret.Get(0).(origin.DisputeStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, agentIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalDomain provides a mock function with given fields: opts
func (_m *IOrigin) LocalDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Multicall provides a mock function with given fields: opts, calls
func (_m *IOrigin) Multicall(opts *bind.TransactOpts, calls []origin.MultiCallableCall) (*types.Transaction, error) {
	ret := _m.Called(opts, calls)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []origin.MultiCallableCall) *types.Transaction); ok {
		r0 = rf(opts, calls)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []origin.MultiCallableCall) error); ok {
		r1 = rf(opts, calls)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenDispute provides a mock function with given fields: opts, guardIndex, notaryIndex
func (_m *IOrigin) OpenDispute(opts *bind.TransactOpts, guardIndex uint32, notaryIndex uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, guardIndex, notaryIndex)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, uint32) *types.Transaction); ok {
		r0 = rf(opts, guardIndex, notaryIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, uint32) error); ok {
		r1 = rf(opts, guardIndex, notaryIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *IOrigin) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInitialized provides a mock function with given fields: log
func (_m *IOrigin) ParseInitialized(log types.Log) (*origin.OriginInitialized, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginInitialized
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginInitialized)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferStarted provides a mock function with given fields: log
func (_m *IOrigin) ParseOwnershipTransferStarted(log types.Log) (*origin.OriginOwnershipTransferStarted, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginOwnershipTransferStarted
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginOwnershipTransferStarted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginOwnershipTransferStarted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *IOrigin) ParseOwnershipTransferred(log types.Log) (*origin.OriginOwnershipTransferred, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginOwnershipTransferred
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginOwnershipTransferred)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseSent provides a mock function with given fields: log
func (_m *IOrigin) ParseSent(log types.Log) (*origin.OriginSent, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginSent
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginSent); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginSent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseStateSaved provides a mock function with given fields: log
func (_m *IOrigin) ParseStateSaved(log types.Log) (*origin.OriginStateSaved, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginStateSaved
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginStateSaved); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginStateSaved)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseTipWithdrawalCompleted provides a mock function with given fields: log
func (_m *IOrigin) ParseTipWithdrawalCompleted(log types.Log) (*origin.OriginTipWithdrawalCompleted, error) {
	ret := _m.Called(log)

	var r0 *origin.OriginTipWithdrawalCompleted
	if rf, ok := ret.Get(0).(func(types.Log) *origin.OriginTipWithdrawalCompleted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*origin.OriginTipWithdrawalCompleted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Parser provides a mock function with given fields:
func (_m *IOrigin) Parser() origin.Parser {
	ret := _m.Called()

	var r0 origin.Parser
	if rf, ok := ret.Get(0).(func() origin.Parser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(origin.Parser)
		}
	}

	return r0
}

// PendingOwner provides a mock function with given fields: opts
func (_m *IOrigin) PendingOwner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *IOrigin) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolveDispute provides a mock function with given fields: opts, slashedIndex, rivalIndex
func (_m *IOrigin) ResolveDispute(opts *bind.TransactOpts, slashedIndex uint32, rivalIndex uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, slashedIndex, rivalIndex)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, uint32) *types.Transaction); ok {
		r0 = rf(opts, slashedIndex, rivalIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, uint32) error); ok {
		r1 = rf(opts, slashedIndex, rivalIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendBaseMessage provides a mock function with given fields: opts, destination, recipient, optimisticPeriod, paddedRequest, content
func (_m *IOrigin) SendBaseMessage(opts *bind.TransactOpts, destination uint32, recipient [32]byte, optimisticPeriod uint32, paddedRequest *big.Int, content []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, destination, recipient, optimisticPeriod, paddedRequest, content)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, [32]byte, uint32, *big.Int, []byte) *types.Transaction); ok {
		r0 = rf(opts, destination, recipient, optimisticPeriod, paddedRequest, content)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, [32]byte, uint32, *big.Int, []byte) error); ok {
		r1 = rf(opts, destination, recipient, optimisticPeriod, paddedRequest, content)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendManagerMessage provides a mock function with given fields: opts, destination, optimisticPeriod, payload
func (_m *IOrigin) SendManagerMessage(opts *bind.TransactOpts, destination uint32, optimisticPeriod uint32, payload []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, destination, optimisticPeriod, payload)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, uint32, []byte) *types.Transaction); ok {
		r0 = rf(opts, destination, optimisticPeriod, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, uint32, []byte) error); ok {
		r1 = rf(opts, destination, optimisticPeriod, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StatesAmount provides a mock function with given fields: opts
func (_m *IOrigin) StatesAmount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuggestLatestState provides a mock function with given fields: opts
func (_m *IOrigin) SuggestLatestState(opts *bind.CallOpts) ([]byte, error) {
	ret := _m.Called(opts)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuggestState provides a mock function with given fields: opts, nonce
func (_m *IOrigin) SuggestState(opts *bind.CallOpts, nonce uint32) ([]byte, error) {
	ret := _m.Called(opts, nonce)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) []byte); ok {
		r0 = rf(opts, nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SynapseDomain provides a mock function with given fields: opts
func (_m *IOrigin) SynapseDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *IOrigin) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: opts
func (_m *IOrigin) Version(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	var r0 string
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInitialized provides a mock function with given fields: opts, sink
func (_m *IOrigin) WatchInitialized(opts *bind.WatchOpts, sink chan<- *origin.OriginInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferStarted provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IOrigin) WatchOwnershipTransferStarted(opts *bind.WatchOpts, sink chan<- *origin.OriginOwnershipTransferStarted, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginOwnershipTransferStarted, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginOwnershipTransferStarted, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IOrigin) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *origin.OriginOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchSent provides a mock function with given fields: opts, sink, messageHash, nonce, destination
func (_m *IOrigin) WatchSent(opts *bind.WatchOpts, sink chan<- *origin.OriginSent, messageHash [][32]byte, nonce []uint32, destination []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, messageHash, nonce, destination)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginSent, [][32]byte, []uint32, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, messageHash, nonce, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginSent, [][32]byte, []uint32, []uint32) error); ok {
		r1 = rf(opts, sink, messageHash, nonce, destination)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchStateSaved provides a mock function with given fields: opts, sink
func (_m *IOrigin) WatchStateSaved(opts *bind.WatchOpts, sink chan<- *origin.OriginStateSaved) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginStateSaved) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginStateSaved) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchTipWithdrawalCompleted provides a mock function with given fields: opts, sink
func (_m *IOrigin) WatchTipWithdrawalCompleted(opts *bind.WatchOpts, sink chan<- *origin.OriginTipWithdrawalCompleted) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *origin.OriginTipWithdrawalCompleted) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *origin.OriginTipWithdrawalCompleted) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawTips provides a mock function with given fields: opts, recipient, amount
func (_m *IOrigin) WithdrawTips(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, recipient, amount)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, recipient, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, *big.Int) error); ok {
		r1 = rf(opts, recipient, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewIOrigin interface {
	mock.TestingT
	Cleanup(func())
}

// NewIOrigin creates a new instance of IOrigin. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewIOrigin(t mockConstructorTestingTNewIOrigin) *IOrigin {
	mock := &IOrigin{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
