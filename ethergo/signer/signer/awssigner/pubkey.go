package awssigner

import (
	"context"
	"crypto/ecdsa"
	"encoding/asn1"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/kms"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

// PubKeyData is the public key data.
type PubKeyData struct {
	// rawPubKey is the public key
	rawPubKey []byte
	// ecdsaKey is the key
	ecdsaKey *ecdsa.PublicKey
	// address is the signing address derived from the pubkey
	address common.Address
}

// getPublicKey fetches the pub key from the kms provider.
func (signingHandler *Signer) getPublicKey(ctx context.Context) (*PubKeyData, error) {
	pubKey, err := signingHandler.client.GetPublicKey(ctx, &kms.GetPublicKeyInput{
		KeyId: aws.String(signingHandler.keyID),
	})

	if err != nil {
		return nil, fmt.Errorf("could not fetch public key: %w", err)
	}

	var asn1pubk asn1EcPublicKey
	_, err = asn1.Unmarshal(pubKey.PublicKey, &asn1pubk)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshall asn: %w", err)
	}

	unmarshalledKey, err := crypto.UnmarshalPubkey(asn1pubk.PublicKey.Bytes)
	if err != nil {
		return nil, fmt.Errorf("could not get public key from asn: %w", err)
	}

	address := crypto.PubkeyToAddress(*unmarshalledKey)

	return &PubKeyData{rawPubKey: asn1pubk.PublicKey.Bytes, ecdsaKey: unmarshalledKey, address: address}, nil
}

// asn1EcPublicKeyInfo contains the public key info.
type asn1EcPublicKeyInfo struct {
	// Algorithm is the algorithm used for the key (see: https://en.wikipedia.org/wiki/ASN.1#Packed_Encoding_Rules)
	Algorithm asn1.ObjectIdentifier
	// Parameters is a list of der encoded parameters (see: https://luca.ntop.org/Teaching/Appunti/asn1.html)
	Parameters asn1.ObjectIdentifier
}

// asn1EcPublicKey contains the public info for the ecc key.
type asn1EcPublicKey struct {
	// EcPublicKeyInfo is the public key info the secp256k1 key generated by kms
	EcPublicKeyInfo asn1EcPublicKeyInfo
	// PublicKey is the raw public key
	PublicKey asn1.BitString
}
