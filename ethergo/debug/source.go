// Package debug is a common contract store for local stacktraces and remote stacktraces.
package debug

import (
	"context"
	"encoding/hex"
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/pkg/errors"
	"github.com/synapsecns/sanguine/ethergo/chain"
	"github.com/synapsecns/sanguine/ethergo/contracts"
	"github.com/tenderly/tenderly-cli/providers"
	"github.com/tenderly/tenderly-cli/stacktrace"
)

// ContractSource is a contract source for tenderly to pull from.
type ContractSource struct {
	// localContracts
	localContracts map[string]*MappedContract
	// structMux handles parallel map writes
	structMux sync.RWMutex
}

// NewContractSource creates a new contract source store.
func NewContractSource() *ContractSource {
	return &ContractSource{localContracts: make(map[string]*MappedContract)}
}

// MappedContract is the contract map.
type MappedContract struct {
	*providers.Contract
	// DeployedSourceMap is the currently deployed source map
	DeployedSourceMap *stacktrace.SourceMap
	// ContractType is the raw contract type
	ContractType contracts.ContractType
}

// AddContract adds a contract to the deploy.
//
//nolint:staticcheck
func (c *ContractSource) AddContract(ctx context.Context, chn chain.Chain, contractType contracts.ContractType, contract contracts.DeployedContract) (resultingContract *providers.Contract, err error) {
	if contract.DeployTx() == nil {
		return nil, fmt.Errorf("deploy tx missing for contract %s (owner: %s)", contract.DeployTx().Hash().String(), contract.Owner().String())
	}

	deployedCode, err := chn.CodeAt(ctx, contract.Address(), nil)
	if err != nil {
		return nil, fmt.Errorf("could not get deployed code for contract: %s: %w", contract.Address(), err)
	}

	contractInfo := contractType.ContractInfo()

	//nolint:forcetypeassert
	resultingContract = &providers.Contract{
		// TODO this should be derived from the type constant
		Name:     contractType.ContractName(),
		Abi:      contractInfo.Info.AbiDefinition,
		Bytecode: contractType.ContractInfo().Code,
		// this should be fetched from the network
		DeployedBytecode: hexutil.Encode(deployedCode),
		// TODO, this needs to be included with go:embed or a file go:generated by
		Compiler: providers.ContractCompiler{
			Version: contractType.ContractInfo().Info.CompilerVersion,
		},
		SourceMap:         hex.EncodeToString([]byte(contractInfo.Info.SrcMap.(string))),
		DeployedSourceMap: contractType.ContractInfo().Info.SrcMapRuntime,
		Source:            contractType.ContractInfo().Info.Source,
		Networks: map[string]providers.ContractNetwork{
			strconv.Itoa(int(chn.GetChainID())): {
				// TODO, maybe fill thse in?
				Events:          nil,
				Links:           nil,
				Address:         contract.Address().String(),
				TransactionHash: contract.DeployTx().Hash().String(),
			},
		},
		UpdatedAt: time.Now(),
	}

	sourceMap, err := providers.ParseContract(resultingContract)
	if err != nil {
		return nil, fmt.Errorf("could not produce source map: %w", err)
	}

	c.structMux.Lock()
	c.localContracts[contract.Address().String()] = &MappedContract{
		Contract:          resultingContract,
		DeployedSourceMap: &sourceMap,
		ContractType:      contractType,
	}
	c.structMux.Unlock()

	return resultingContract, errors.Wrap(err, "could not get contract")
}

// GetContract gets the raw contract address.
func (c *ContractSource) GetContract(id string) (*MappedContract, error) {
	c.structMux.RLock()
	contract, ok := c.localContracts[id]
	c.structMux.RUnlock()
	if !ok {
		return nil, fmt.Errorf("could not get contract with id: %s", id)
	}
	return contract, nil
}

// Get gets the stacktrace.
func (c *ContractSource) Get(id string) (*stacktrace.ContractDetails, error) {
	c.structMux.RLock()
	contract, ok := c.localContracts[id]
	c.structMux.RUnlock()
	if !ok {
		return nil, fmt.Errorf("could not get contract with id: %s", id)
	}

	parsedBytecode, err := providers.ParseBytecode(contract.DeployedBytecode)
	if err != nil {
		return nil, fmt.Errorf("could not parse byte code: %w", err)
	}

	if contract.DeployedSourceMap == nil {
		return nil, errors.New("could not get source map")
	}

	return &stacktrace.ContractDetails{
		ID:   stacktrace.ContractID(id),
		Name: contract.Name,
		Hash: id,
		// this is a bit of a misnomer, if you look at the actual providers they're parsing the
		// deployed bytecode and using htat here as we do
		Bytecode:         parsedBytecode,
		DeployedByteCode: contract.DeployedBytecode,
		Abi:              contract.Abi,
		Source:           contract.Source,
		SourceMap:        *contract.DeployedSourceMap,
		ProjectID:        "",
	}, nil
}

var _ stacktrace.ContractSource = &ContractSource{}
