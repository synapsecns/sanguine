{"solidity/SynapseRouterV2.sol:ActionLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f2f0c2e703038d9bcd0b65eac503583c9ca7b6f45cee488f9fd58559c4e3634264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f2f0c2e703038d9bcd0b65eac503583c9ca7b6f45cee488f9fd58559c4e3634264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"8396:808:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;8396:808:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"8396:808:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for dealing with bit masks which describe what set of Actions is available.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for dealing with bit masks which describe what set of Actions is available.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"ActionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:Address":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122066a6d6aeb1acd9ca5c808c53e53abbefe76d936e1f108dd2373ffefa64a0166b64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122066a6d6aeb1acd9ca5c808c53e53abbefe76d936e1f108dd2373ffefa64a0166b64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"12189:8061:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;12189:8061:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"12189:8061:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Collection of functions related to the address type","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"Address\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:Arrays":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a26b66c076f23e7401008ec92d9a72ab6fcaddf8d33e1f0eb46e0b80b6cf100864736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a26b66c076f23e7401008ec92d9a72ab6fcaddf8d33e1f0eb46e0b80b6cf100864736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"46630:4315:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;46630:4315:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"46630:4315:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"count","type":"uint256"}],"name":"ArrayLengthInvalid","type":"error"}],"userDoc":{"kind":"user","methods":{},"notice":"Arrays library offers helper functions for working with arrays and array of arrays","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ArrayLengthInvalid\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Arrays library offers helper functions for working with arrays and array of arrays\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"Arrays\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:DefaultAdapter":{"code":"0x608060405234801561001057600080fd5b506117b6806100206000396000f3fe6080604052600436106100225760003560e01c806324a98f111461002e57600080fd5b3661002957005b600080fd5b61004161003c366004611382565b610053565b60405190815260200160405180910390f35b6000610062868686868661006c565b9695505050505050565b60008061007a86858561011a565b905061008886868684610233565b955060006100978786846102d1565b90506100a58787838561032b565b92507fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8616016100ee576100ee8184610512565b61010f73ffffffffffffffffffffffffffffffffffffffff86168985610596565b505095945050505050565b6040805160808101825260008082526020820181905291810182905260608101919091528273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036101a3576040517f0b839a1f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818060200190518101906101b7919061148d565b602081015190915073ffffffffffffffffffffffffffffffffffffffff161580156101f557506003815160038111156101f2576101f2611512565b14155b1561022c576040517f76ecffc000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b9392505050565b60007fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff86160161028f5761027e838360016106f0565b905061028a81856107c2565b6102c9565b508334156102c9576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b949350505050565b60007fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8416016103235761031c848360006106f0565b905061022c565b509092915050565b600060038251600381111561034257610342611512565b0361034e5750826102c9565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8416906370a0823190602401602060405180830381865afa1580156103b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103dc9190611541565b60208301519091506104069073ffffffffffffffffffffffffffffffffffffffff87169086610860565b60008251600381111561041b5761041b611512565b036104355761043082602001518386866109dc565b61046f565b60018251600381111561044a5761044a611512565b0361045f576104308260200151838686610ba6565b61046f8260200151838686610d55565b6040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152819073ffffffffffffffffffffffffffffffffffffffff8516906370a0823190602401602060405180830381865afa1580156104db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ff9190611541565b6105099190611589565b95945050505050565b6040517f2e1a7d4d0000000000000000000000000000000000000000000000000000000081526004810182905273ffffffffffffffffffffffffffffffffffffffff831690632e1a7d4d90602401600060405180830381600087803b15801561057a57600080fd5b505af115801561058e573d6000803e3d6000fd5b505050505050565b3073ffffffffffffffffffffffffffffffffffffffff8316036105b857505050565b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8416016106ca5760008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d806000811461064f576040519150601f19603f3d011682016040523d82523d6000602084013e610654565b606091505b50509050806106c4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f455448207472616e73666572206661696c65640000000000000000000000000060448201526064015b60405180910390fd5b50505050565b6106eb73ffffffffffffffffffffffffffffffffffffffff84168383610ecd565b505050565b600060038351600381111561070757610707611512565b0361071357508261022c565b826020015173ffffffffffffffffffffffffffffffffffffffff166382b8660083610742578460600151610748565b84604001515b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815260ff9091166004820152602401602060405180830381865afa15801561079e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c991906115a2565b3481146107fb576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8173ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561084357600080fd5b505af1158015610857573d6000803e3d6000fd5b50505050505050565b6040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa1580156108d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fb9190611541565b61090591906115bf565b60405173ffffffffffffffffffffffffffffffffffffffff85166024820152604481018290529091506106c49085907f095ea7b300000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152610f23565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff909116600482015273ffffffffffffffffffffffffffffffffffffffff82811691908616906382b8660090602401602060405180830381865afa158015610a54573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7891906115a2565b73ffffffffffffffffffffffffffffffffffffffff1614610ac5576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080840151606085015191517f9169558600000000000000000000000000000000000000000000000000000000815260ff91821660048201529116602482015260448101839052600060648201527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608482015273ffffffffffffffffffffffffffffffffffffffff85169063916955869060a4015b6020604051808303816000875af1158015610b7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b9f9190611541565b5050505050565b6000610bb18561102f565b90506000610bbe86611100565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610c25576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008267ffffffffffffffff811115610c4057610c40611304565b604051908082528060200260200182016040528015610c69578160200160208202803683370190505b5090508481876040015160ff1681518110610c8657610c866115d2565b60209081029190910101526040517f4d49e87d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff881690634d49e87d90610d089084906000907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90600401611601565b6020604051808303816000875af1158015610d27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4b9190611541565b5050505050505050565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff909116600482015273ffffffffffffffffffffffffffffffffffffffff82811691908616906382b8660090602401602060405180830381865afa158015610dcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df191906115a2565b73ffffffffffffffffffffffffffffffffffffffff1614610e3e576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60608301516040517f3e3a15600000000000000000000000000000000000000000000000000000000081526004810184905260ff9091166024820152600060448201527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff606482015273ffffffffffffffffffffffffffffffffffffffff851690633e3a156090608401610b5c565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526106eb9084907fa9059cbb000000000000000000000000000000000000000000000000000000009060640161095a565b6000610f85826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff1661117d9092919063ffffffff16565b8051909150156106eb5780806020019051810190610fa3919061164e565b6106eb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106bb565b6000805b6040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff8216600482015273ffffffffffffffffffffffffffffffffffffffff8416906382b8660090602401602060405180830381865afa9250505080156110da575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526110d7918101906115a2565b60015b6110e9578060ff1691506110fa565b506110f381611670565b9050611033565b50919050565b60008173ffffffffffffffffffffffffffffffffffffffff16635fd65f0f6040518163ffffffff1660e01b815260040160e060405180830381865afa15801561114d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611171919061168f565b98975050505050505050565b60606102c984846000858573ffffffffffffffffffffffffffffffffffffffff85163b611206576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106bb565b6000808673ffffffffffffffffffffffffffffffffffffffff16858760405161122f9190611713565b60006040518083038185875af1925050503d806000811461126c576040519150601f19603f3d011682016040523d82523d6000602084013e611271565b606091505b509150915061128182828661128c565b979650505050505050565b6060831561129b57508161022c565b8251156112ab5782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106bb919061172f565b73ffffffffffffffffffffffffffffffffffffffff8116811461130157600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561137a5761137a611304565b604052919050565b600080600080600060a0868803121561139a57600080fd5b85356113a5816112df565b94506020868101356113b6816112df565b94506040870135935060608701356113cd816112df565b9250608087013567ffffffffffffffff808211156113ea57600080fd5b818901915089601f8301126113fe57600080fd5b81358181111561141057611410611304565b611440847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611333565b91508082528a8482850101111561145657600080fd5b80848401858401376000848284010152508093505050509295509295909350565b805160ff8116811461148857600080fd5b919050565b60006080828403121561149f57600080fd5b6040516080810181811067ffffffffffffffff821117156114c2576114c2611304565b6040528251600481106114d457600080fd5b815260208301516114e4816112df565b60208201526114f560408401611477565b604082015261150660608401611477565b60608201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60006020828403121561155357600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561159c5761159c61155a565b92915050565b6000602082840312156115b457600080fd5b815161022c816112df565b8082018082111561159c5761159c61155a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b606080825284519082018190526000906020906080840190828801845b8281101561163a5781518452928401929084019060010161161e565b505050908301949094525060400152919050565b60006020828403121561166057600080fd5b8151801515811461022c57600080fd5b600060ff821660ff81036116865761168661155a565b60010192915050565b600080600080600080600060e0888a0312156116aa57600080fd5b875196506020880151955060408801519450606088015193506080880151925060a0880151915060c08801516116df816112df565b8091505092959891949750929550565b60005b8381101561170a5781810151838201526020016116f2565b50506000910152565b600082516117258184602087016116ef565b9190910192915050565b602081526000825180602084015261174e8160408501602087016116ef565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fea2646970667358221220c9dcd0c0465024964615cf3eb09a30cd865bd2daa7b4331fea5836144a34108a64736f6c63430008110033","runtime-code":"0x6080604052600436106100225760003560e01c806324a98f111461002e57600080fd5b3661002957005b600080fd5b61004161003c366004611382565b610053565b60405190815260200160405180910390f35b6000610062868686868661006c565b9695505050505050565b60008061007a86858561011a565b905061008886868684610233565b955060006100978786846102d1565b90506100a58787838561032b565b92507fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8616016100ee576100ee8184610512565b61010f73ffffffffffffffffffffffffffffffffffffffff86168985610596565b505095945050505050565b6040805160808101825260008082526020820181905291810182905260608101919091528273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16036101a3576040517f0b839a1f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818060200190518101906101b7919061148d565b602081015190915073ffffffffffffffffffffffffffffffffffffffff161580156101f557506003815160038111156101f2576101f2611512565b14155b1561022c576040517f76ecffc000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b9392505050565b60007fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff86160161028f5761027e838360016106f0565b905061028a81856107c2565b6102c9565b508334156102c9576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b949350505050565b60007fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8416016103235761031c848360006106f0565b905061022c565b509092915050565b600060038251600381111561034257610342611512565b0361034e5750826102c9565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8416906370a0823190602401602060405180830381865afa1580156103b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103dc9190611541565b60208301519091506104069073ffffffffffffffffffffffffffffffffffffffff87169086610860565b60008251600381111561041b5761041b611512565b036104355761043082602001518386866109dc565b61046f565b60018251600381111561044a5761044a611512565b0361045f576104308260200151838686610ba6565b61046f8260200151838686610d55565b6040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152819073ffffffffffffffffffffffffffffffffffffffff8516906370a0823190602401602060405180830381865afa1580156104db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ff9190611541565b6105099190611589565b95945050505050565b6040517f2e1a7d4d0000000000000000000000000000000000000000000000000000000081526004810182905273ffffffffffffffffffffffffffffffffffffffff831690632e1a7d4d90602401600060405180830381600087803b15801561057a57600080fd5b505af115801561058e573d6000803e3d6000fd5b505050505050565b3073ffffffffffffffffffffffffffffffffffffffff8316036105b857505050565b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8416016106ca5760008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d806000811461064f576040519150601f19603f3d011682016040523d82523d6000602084013e610654565b606091505b50509050806106c4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f455448207472616e73666572206661696c65640000000000000000000000000060448201526064015b60405180910390fd5b50505050565b6106eb73ffffffffffffffffffffffffffffffffffffffff84168383610ecd565b505050565b600060038351600381111561070757610707611512565b0361071357508261022c565b826020015173ffffffffffffffffffffffffffffffffffffffff166382b8660083610742578460600151610748565b84604001515b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815260ff9091166004820152602401602060405180830381865afa15801561079e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c991906115a2565b3481146107fb576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8173ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561084357600080fd5b505af1158015610857573d6000803e3d6000fd5b50505050505050565b6040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa1580156108d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fb9190611541565b61090591906115bf565b60405173ffffffffffffffffffffffffffffffffffffffff85166024820152604481018290529091506106c49085907f095ea7b300000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152610f23565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff909116600482015273ffffffffffffffffffffffffffffffffffffffff82811691908616906382b8660090602401602060405180830381865afa158015610a54573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7891906115a2565b73ffffffffffffffffffffffffffffffffffffffff1614610ac5576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080840151606085015191517f9169558600000000000000000000000000000000000000000000000000000000815260ff91821660048201529116602482015260448101839052600060648201527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608482015273ffffffffffffffffffffffffffffffffffffffff85169063916955869060a4015b6020604051808303816000875af1158015610b7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b9f9190611541565b5050505050565b6000610bb18561102f565b90506000610bbe86611100565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610c25576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008267ffffffffffffffff811115610c4057610c40611304565b604051908082528060200260200182016040528015610c69578160200160208202803683370190505b5090508481876040015160ff1681518110610c8657610c866115d2565b60209081029190910101526040517f4d49e87d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff881690634d49e87d90610d089084906000907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90600401611601565b6020604051808303816000875af1158015610d27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4b9190611541565b5050505050505050565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff909116600482015273ffffffffffffffffffffffffffffffffffffffff82811691908616906382b8660090602401602060405180830381865afa158015610dcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df191906115a2565b73ffffffffffffffffffffffffffffffffffffffff1614610e3e576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60608301516040517f3e3a15600000000000000000000000000000000000000000000000000000000081526004810184905260ff9091166024820152600060448201527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff606482015273ffffffffffffffffffffffffffffffffffffffff851690633e3a156090608401610b5c565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526106eb9084907fa9059cbb000000000000000000000000000000000000000000000000000000009060640161095a565b6000610f85826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff1661117d9092919063ffffffff16565b8051909150156106eb5780806020019051810190610fa3919061164e565b6106eb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106bb565b6000805b6040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff8216600482015273ffffffffffffffffffffffffffffffffffffffff8416906382b8660090602401602060405180830381865afa9250505080156110da575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526110d7918101906115a2565b60015b6110e9578060ff1691506110fa565b506110f381611670565b9050611033565b50919050565b60008173ffffffffffffffffffffffffffffffffffffffff16635fd65f0f6040518163ffffffff1660e01b815260040160e060405180830381865afa15801561114d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611171919061168f565b98975050505050505050565b60606102c984846000858573ffffffffffffffffffffffffffffffffffffffff85163b611206576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106bb565b6000808673ffffffffffffffffffffffffffffffffffffffff16858760405161122f9190611713565b60006040518083038185875af1925050503d806000811461126c576040519150601f19603f3d011682016040523d82523d6000602084013e611271565b606091505b509150915061128182828661128c565b979650505050505050565b6060831561129b57508161022c565b8251156112ab5782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106bb919061172f565b73ffffffffffffffffffffffffffffffffffffffff8116811461130157600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561137a5761137a611304565b604052919050565b600080600080600060a0868803121561139a57600080fd5b85356113a5816112df565b94506020868101356113b6816112df565b94506040870135935060608701356113cd816112df565b9250608087013567ffffffffffffffff808211156113ea57600080fd5b818901915089601f8301126113fe57600080fd5b81358181111561141057611410611304565b611440847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611333565b91508082528a8482850101111561145657600080fd5b80848401858401376000848284010152508093505050509295509295909350565b805160ff8116811461148857600080fd5b919050565b60006080828403121561149f57600080fd5b6040516080810181811067ffffffffffffffff821117156114c2576114c2611304565b6040528251600481106114d457600080fd5b815260208301516114e4816112df565b60208201526114f560408401611477565b604082015261150660608401611477565b60608201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60006020828403121561155357600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561159c5761159c61155a565b92915050565b6000602082840312156115b457600080fd5b815161022c816112df565b8082018082111561159c5761159c61155a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b606080825284519082018190526000906020906080840190828801845b8281101561163a5781518452928401929084019060010161161e565b505050908301949094525060400152919050565b60006020828403121561166057600080fd5b8151801515811461022c57600080fd5b600060ff821660ff81036116865761168661155a565b60010192915050565b600080600080600080600060e0888a0312156116aa57600080fd5b875196506020880151955060408801519450606088015193506080880151925060a0880151915060c08801516116df816112df565b8091505092959891949750929550565b60005b8381101561170a5781810151838201526020016116f2565b50506000910152565b600082516117258184602087016116ef565b9190910192915050565b602081526000825180602084015261174e8160408501602087016116ef565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016040019291505056fea2646970667358221220c9dcd0c0465024964615cf3eb09a30cd865bd2daa7b4331fea5836144a34108a64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"79100:12420:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"79100:12420:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;79464:295;;;;;;:::i;:::-;;:::i;:::-;;;2161:25:1;;;2149:2;2134:18;79464:295:0;;;;;;;;79653:17;79689:63;79702:9;79713:7;79722:8;79732;79742:9;79689:12;:63::i;:::-;79682:70;79464:295;-1:-1:-1;;;;;;79464:295:0:o;79917:1827::-;80107:17;80342:27;80372:42;80385:7;80394:8;80404:9;80372:12;:42::i;:::-;80342:72;;80486:53;80503:7;80512:8;80522;80532:6;80486:16;:53::i;:::-;80476:63;;80701:19;80723:45;80742:7;80751:8;80761:6;80723:18;:45::i;:::-;80701:67;;81042:58;81061:7;81070:8;81080:11;81093:6;81042:18;:58::i;:::-;81030:70;-1:-1:-1;81314:41:0;;;;;81310:171;;81436:34;81447:11;81460:9;81436:10;:34::i;:::-;81689:48;:26;;;81716:9;81727;81689:26;:48::i;:::-;80126:1618;;79917:1827;;;;;;;:::o;81813:522::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;82001:8:0;81990:19;;:7;:19;;;81986:49;;82018:17;;;;;;;;;;;;;;81986:49;82122:9;82111:38;;;;;;;;;;;;:::i;:::-;82243:11;;;;82102:47;;-1:-1:-1;82243:25:0;;;:62;;;;-1:-1:-1;82289:16:0;82272:13;;:33;;;;;;;;:::i;:::-;;;82243:62;82239:89;;;82314:14;;;;;;;;;;;;;;82239:89;81813:522;;;;;:::o;82465:914::-;82629:22;82762:40;;;;;82758:615;;83002:76;83029:8;83047:6;83072:4;83002:18;:76::i;:::-;82985:93;;83156:34;83165:14;83181:8;83156;:34::i;:::-;82758:615;;;-1:-1:-1;83238:7:0;83320:9;:14;83316:46;;83343:19;;;;;;;;;;;;;;83316:46;82465:914;;;;;;:::o;83479:614::-;83624:19;83712:41;;;;;83708:379;;83947:76;83974:7;83991:6;84016:5;83947:18;:76::i;:::-;83933:90;;83708:379;;;-1:-1:-1;84068:8:0;;83479:614;-1:-1:-1;;83479:614:0:o;84201:1307::-;84370:17;84470:16;84453:13;;:33;;;;;;;;:::i;:::-;;84449:1053;;-1:-1:-1;84578:8:0;84449:1053;;;84675:44;;;;;84713:4;84675:44;;;3521:74:1;84675:29:0;;;;;;3494:18:1;;84675:44:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;84848:11;;;;84663:56;;-1:-1:-1;84810:60:0;;:37;;;;84861:8;84810:37;:60::i;:::-;84905:11;84888:13;;:28;;;;;;;;:::i;:::-;;84884:417;;84936:49;84942:6;:11;;;84955:6;84963:8;84973:11;84936:5;:49::i;:::-;84884:417;;;85027:19;85010:13;;:36;;;;;;;;:::i;:::-;;85006:295;;85066:57;85080:6;:11;;;85093:6;85101:8;85111:11;85066:13;:57::i;85006:295::-;85226:60;85243:6;:11;;;85256:6;85264:8;85274:11;85226:16;:60::i;:::-;85435:44;;;;;85473:4;85435:44;;;3521:74:1;85482:9:0;;85435:29;;;;;;3494:18:1;;85435:44:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:56;;;;:::i;:::-;85423:68;84201:1307;-1:-1:-1;;;;;84201:1307:0:o;90702:146::-;90812:29;;;;;;;;2161:25:1;;;90812:21:0;;;;;;2134:18:1;;90812:29:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;90702:146;;:::o;76944:593::-;77149:4;77135:19;;;;77131:32;;76944:593;;;:::o;77131:32::-;77176:20;;;;;77172:359;;77356:12;77374:2;:7;;77389:5;77374:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;77355:44;;;77421:7;77413:39;;;;;;;4529:2:1;77413:39:0;;;4511:21:1;4568:2;4548:18;;;4541:30;4607:21;4587:18;;;4580:49;4646:18;;77413:39:0;;;;;;;;;77198:265;76944:593;;;:::o;77172:359::-;77483:37;:26;;;77510:2;77514:5;77483:26;:37::i;:::-;76944:593;;;:::o;90910:608::-;91057:12;91102:16;91085:13;;:33;;;;;;;;:::i;:::-;;91081:431;;-1:-1:-1;91244:5:0;91081:431;;;91403:6;:11;;;91390:34;;;91425:15;:61;;91467:6;:19;;;91425:61;;;91443:6;:21;;;91425:61;91390:97;;;;;;;;;;4847:4:1;4835:17;;;91390:97:0;;;4817:36:1;4790:18;;91390:97:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;90430:230::-;90511:9;90501:6;:19;90497:51;;90529:19;;;;;;;;;;;;;;90497:51;90623:4;90616:20;;;90644:6;90616:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;90430:230;;:::o;64935:310::-;65084:39;;;;;65108:4;65084:39;;;5355:34:1;65084:15:0;5425::1;;;5405:18;;;5398:43;65061:20:0;;65126:5;;65084:15;;;;;5267:18:1;;65084:39:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:47;;;;:::i;:::-;65168:69;;5786:42:1;5774:55;;65168:69:0;;;5756:74:1;5846:18;;;5839:34;;;65061:70:0;;-1:-1:-1;65141:97:0;;65161:5;;65191:22;;5729:18:1;;65168:69:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;65141:19;:97::i;85929:605::-;86165:19;;;;86137:48;;;;;4847:4:1;4835:17;;;86137:48:0;;;4817:36:1;86137:60:0;;;;;:27;;;;;;4790:18:1;;86137:48:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:60;;;86133:95;;86206:22;;;;;;;;;;;;;;86133:95;86359:21;;;;;86408:19;;;;86305:222;;;;;6173:4:1;6161:17;;;86305:222:0;;;6143:36:1;6215:17;;6195:18;;;6188:45;6249:18;;;6242:34;;;86474:1:0;6292:18:1;;;6285:34;86499:17:0;6335:19:1;;;6328:35;86305:23:0;;;;;;6115:19:1;;86305:222:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;85929:605;;;;:::o;86689:659::-;86848:17;86868:23;86886:4;86868:17;:23::i;:::-;86848:43;;86901:15;86919:21;86935:4;86919:15;:21::i;:::-;86901:39;;87011:8;87000:19;;:7;:19;;;86996:54;;87028:22;;;;;;;;;;;;;;86996:54;87060:24;87101:9;87087:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;87087:24:0;;87060:51;;87154:8;87121:7;87129:6;:21;;;87121:30;;;;;;;;;;:::i;:::-;;;;;;;;;;:41;87239:102;;;;;:39;;;;;;:102;;87289:7;;87309:1;;87322:17;;87239:102;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;86838:510;;;86689:659;;;;:::o;87508:603::-;87755:19;;;;87727:48;;;;;4847:4:1;4835:17;;;87727:48:0;;;4817:36:1;87727:60:0;;;;;:27;;;;;;4790:18:1;;87727:48:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:60;;;87723:95;;87796:22;;;;;;;;;;;;;;87723:95;88007:19;;;;87895:209;;;;;;;;7588:25:1;;;7661:4;7649:17;;;7629:18;;;7622:45;88051:1:0;7683:18:1;;;7676:34;88076:17:0;7726:18:1;;;7719:34;87895:50:0;;;;;;7560:19:1;;87895:209:0;7353:406:1;63614:205:0;63753:58;;5786:42:1;5774:55;;63753:58:0;;;5756:74:1;5846:18;;;5839:34;;;63726:86:0;;63746:5;;63776:23;;5729:18:1;;63753:58:0;5582:297:1;66120:706:0;66539:23;66565:69;66593:4;66565:69;;;;;;;;;;;;;;;;;66573:5;66565:27;;;;:69;;;;;:::i;:::-;66648:17;;66539:95;;-1:-1:-1;66648:21:0;66644:176;;66743:10;66732:30;;;;;;;;;;;;:::i;:::-;66724:85;;;;;;;8248:2:1;66724:85:0;;;8230:21:1;8287:2;8267:18;;;8260:30;8326:34;8306:18;;;8299:62;8397:12;8377:18;;;8370:40;8427:19;;66724:85:0;8046:406:1;88699::0;88763:17;;88864:235;88915:34;;;;;4847:4:1;4835:17;;88915:34:0;;;4817:36:1;88915:27:0;;;;;;4790:18:1;;88915:34:0;;;;;;;;;;;;;;;;;;-1:-1:-1;88915:34:0;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;88911:178;;89046:5;89034:17;;;;89069:5;;88911:178;88950:20;88888:7;;;:::i;:::-;;;88864:235;;;;88699:406;;;:::o;88472:160::-;88534:15;88606:4;88585:38;;;:40;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;88561:64;88472:160;-1:-1:-1;;;;;;;;88472:160:0:o;15856:223::-;15989:12;16020:52;16042:6;16050:4;16056:1;16059:12;15989;13460:19;;;;17223:60;;;;;;;9872:2:1;17223:60:0;;;9854:21:1;9911:2;9891:18;;;9884:30;9950:31;9930:18;;;9923:59;9999:18;;17223:60:0;9670:353:1;17223:60:0;17295:12;17309:23;17336:6;:11;;17355:5;17362:4;17336:31;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;17294:73;;;;17384:51;17401:7;17410:10;17422:12;17384:16;:51::i;:::-;17377:58;16943:499;-1:-1:-1;;;;;;;16943:499:0:o;19556:692::-;19702:12;19730:7;19726:516;;;-1:-1:-1;19760:10:0;19753:17;;19726:516;19871:17;;:21;19867:365;;20065:10;20059:17;20125:15;20112:10;20108:2;20104:19;20097:44;19867:365;20204:12;20197:20;;;;;;;;;;;:::i;14:154:1:-;100:42;93:5;89:54;82:5;79:65;69:93;;158:1;155;148:12;69:93;14:154;:::o;173:184::-;225:77;222:1;215:88;322:4;319:1;312:15;346:4;343:1;336:15;362:334;433:2;427:9;489:2;479:13;;494:66;475:86;463:99;;592:18;577:34;;613:22;;;574:62;571:88;;;639:18;;:::i;:::-;675:2;668:22;362:334;;-1:-1:-1;362:334:1:o;701:1309::-;805:6;813;821;829;837;890:3;878:9;869:7;865:23;861:33;858:53;;;907:1;904;897:12;858:53;946:9;933:23;965:31;990:5;965:31;:::i;:::-;1015:5;-1:-1:-1;1039:2:1;1078:18;;;1065:32;1106:33;1065:32;1106:33;:::i;:::-;1158:7;-1:-1:-1;1212:2:1;1197:18;;1184:32;;-1:-1:-1;1268:2:1;1253:18;;1240:32;1281:33;1240:32;1281:33;:::i;:::-;1333:7;-1:-1:-1;1391:3:1;1376:19;;1363:33;1415:18;1445:14;;;1442:34;;;1472:1;1469;1462:12;1442:34;1510:6;1499:9;1495:22;1485:32;;1555:7;1548:4;1544:2;1540:13;1536:27;1526:55;;1577:1;1574;1567:12;1526:55;1613:2;1600:16;1635:2;1631;1628:10;1625:36;;;1641:18;;:::i;:::-;1683:112;1791:2;1722:66;1715:4;1711:2;1707:13;1703:86;1699:95;1683:112;:::i;:::-;1670:125;;1818:2;1811:5;1804:17;1858:7;1853:2;1848;1844;1840:11;1836:20;1833:33;1830:53;;;1879:1;1876;1869:12;1830:53;1934:2;1929;1925;1921:11;1916:2;1909:5;1905:14;1892:45;1978:1;1973:2;1968;1961:5;1957:14;1953:23;1946:34;;1999:5;1989:15;;;;;701:1309;;;;;;;;:::o;2197:160::-;2274:13;;2327:4;2316:16;;2306:27;;2296:55;;2347:1;2344;2337:12;2296:55;2197:160;;;:::o;2362:819::-;2462:6;2515:3;2503:9;2494:7;2490:23;2486:33;2483:53;;;2532:1;2529;2522:12;2483:53;2565:2;2559:9;2607:3;2599:6;2595:16;2677:6;2665:10;2662:22;2641:18;2629:10;2626:34;2623:62;2620:88;;;2688:18;;:::i;:::-;2724:2;2717:22;2761:16;;2806:1;2796:12;;2786:40;;2822:1;2819;2812:12;2786:40;2835:21;;2901:2;2886:18;;2880:25;2914:33;2880:25;2914:33;:::i;:::-;2975:2;2963:15;;2956:32;3021:47;3064:2;3049:18;;3021:47;:::i;:::-;3016:2;3008:6;3004:15;2997:72;3102:47;3145:2;3134:9;3130:18;3102:47;:::i;:::-;3097:2;3085:15;;3078:72;3089:6;2362:819;-1:-1:-1;;;2362:819:1:o;3186:184::-;3238:77;3235:1;3228:88;3335:4;3332:1;3325:15;3359:4;3356:1;3349:15;3606:184;3676:6;3729:2;3717:9;3708:7;3704:23;3700:32;3697:52;;;3745:1;3742;3735:12;3697:52;-1:-1:-1;3768:16:1;;3606:184;-1:-1:-1;3606:184:1:o;3795:::-;3847:77;3844:1;3837:88;3944:4;3941:1;3934:15;3968:4;3965:1;3958:15;3984:128;4051:9;;;4072:11;;;4069:37;;;4086:18;;:::i;:::-;3984:128;;;;:::o;4864:251::-;4934:6;4987:2;4975:9;4966:7;4962:23;4958:32;4955:52;;;5003:1;5000;4993:12;4955:52;5035:9;5029:16;5054:31;5079:5;5054:31;:::i;5452:125::-;5517:9;;;5538:10;;;5535:36;;;5551:18;;:::i;6374:184::-;6426:77;6423:1;6416:88;6523:4;6520:1;6513:15;6547:4;6544:1;6537:15;6563:785;6817:2;6829:21;;;6899:13;;6802:18;;;6921:22;;;6769:4;;6997;;6974:3;6959:19;;;7024:15;;;6769:4;7067:169;7081:6;7078:1;7075:13;7067:169;;;7142:13;;7130:26;;7176:12;;;;7211:15;;;;7103:1;7096:9;7067:169;;;-1:-1:-1;;;7272:18:1;;;7265:34;;;;-1:-1:-1;7330:2:1;7315:18;7308:34;7253:3;6563:785;-1:-1:-1;6563:785:1:o;7764:277::-;7831:6;7884:2;7872:9;7863:7;7859:23;7855:32;7852:52;;;7900:1;7897;7890:12;7852:52;7932:9;7926:16;7985:5;7978:13;7971:21;7964:5;7961:32;7951:60;;8007:1;8004;7997:12;8457:175;8494:3;8538:4;8531:5;8527:16;8567:4;8558:7;8555:17;8552:43;;8575:18;;:::i;:::-;8624:1;8611:15;;8457:175;-1:-1:-1;;8457:175:1:o;8637:621::-;8761:6;8769;8777;8785;8793;8801;8809;8862:3;8850:9;8841:7;8837:23;8833:33;8830:53;;;8879:1;8876;8869:12;8830:53;8908:9;8902:16;8892:26;;8958:2;8947:9;8943:18;8937:25;8927:35;;9002:2;8991:9;8987:18;8981:25;8971:35;;9046:2;9035:9;9031:18;9025:25;9015:35;;9090:3;9079:9;9075:19;9069:26;9059:36;;9135:3;9124:9;9120:19;9114:26;9104:36;;9183:3;9172:9;9168:19;9162:26;9197:31;9222:5;9197:31;:::i;:::-;9247:5;9237:15;;;8637:621;;;;;;;;;;:::o;10028:250::-;10113:1;10123:113;10137:6;10134:1;10131:13;10123:113;;;10213:11;;;10207:18;10194:11;;;10187:39;10159:2;10152:10;10123:113;;;-1:-1:-1;;10270:1:1;10252:16;;10245:27;10028:250::o;10283:287::-;10412:3;10450:6;10444:13;10466:66;10525:6;10520:3;10513:4;10505:6;10501:17;10466:66;:::i;:::-;10548:16;;;;;10283:287;-1:-1:-1;;10283:287:1:o;10575:455::-;10724:2;10713:9;10706:21;10687:4;10756:6;10750:13;10799:6;10794:2;10783:9;10779:18;10772:34;10815:79;10887:6;10882:2;10871:9;10867:18;10862:2;10854:6;10850:15;10815:79;:::i;:::-;10946:2;10934:15;10951:66;10930:88;10915:104;;;;11021:2;10911:113;;10575:455;-1:-1:-1;;10575:455:1:o","abiDefinition":[{"inputs":[],"name":"MsgValueIncorrect","type":"error"},{"inputs":[],"name":"PoolNotFound","type":"error"},{"inputs":[],"name":"TokenAddressMismatch","type":"error"},{"inputs":[],"name":"TokensIdentical","type":"error"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"name":"adapterSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}],"userDoc":{"kind":"user","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"notice":"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient."}},"version":1},"developerDoc":{"kind":"dev","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"details":"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.","params":{"amountIn":"Amount of tokens to sell","rawParams":"Additional swap parameters","recipient":"Address to receive the swapped token","tokenIn":"Token to sell (use ETH_ADDRESS to start from native ETH)","tokenOut":"Token to buy (use ETH_ADDRESS to end with native ETH)"},"returns":{"amountOut":"  Amount of bought tokens"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MsgValueIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAddressMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokensIdentical\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"name\":\"adapterSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"details\":\"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.\",\"params\":{\"amountIn\":\"Amount of tokens to sell\",\"rawParams\":\"Additional swap parameters\",\"recipient\":\"Address to receive the swapped token\",\"tokenIn\":\"Token to sell (use ETH_ADDRESS to start from native ETH)\",\"tokenOut\":\"Token to buy (use ETH_ADDRESS to end with native ETH)\"},\"returns\":{\"amountOut\":\"  Amount of bought tokens\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"notice\":\"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"DefaultAdapter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"adapterSwap(address,address,uint256,address,bytes)":"24a98f11"}},"solidity/SynapseRouterV2.sol:DefaultRouter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"MsgValueIncorrect","type":"error"},{"inputs":[],"name":"PoolNotFound","type":"error"},{"inputs":[],"name":"TokenAddressMismatch","type":"error"},{"inputs":[],"name":"TokensIdentical","type":"error"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"name":"adapterSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}],"userDoc":{"kind":"user","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"notice":"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient."}},"notice":"Base contract for all Synapse Routers, that is able to natively work with Default Pools due to the fact that it inherits from DefaultAdapter.","version":1},"developerDoc":{"kind":"dev","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"details":"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.","params":{"amountIn":"Amount of tokens to sell","rawParams":"Additional swap parameters","recipient":"Address to receive the swapped token","tokenIn":"Token to sell (use ETH_ADDRESS to start from native ETH)","tokenOut":"Token to buy (use ETH_ADDRESS to end with native ETH)"},"returns":{"amountOut":"  Amount of bought tokens"}}},"title":"DefaultRouter","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MsgValueIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAddressMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokensIdentical\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"name\":\"adapterSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"details\":\"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.\",\"params\":{\"amountIn\":\"Amount of tokens to sell\",\"rawParams\":\"Additional swap parameters\",\"recipient\":\"Address to receive the swapped token\",\"tokenIn\":\"Token to sell (use ETH_ADDRESS to start from native ETH)\",\"tokenOut\":\"Token to buy (use ETH_ADDRESS to end with native ETH)\"},\"returns\":{\"amountOut\":\"  Amount of bought tokens\"}}},\"title\":\"DefaultRouter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"notice\":\"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient.\"}},\"notice\":\"Base contract for all Synapse Routers, that is able to natively work with Default Pools due to the fact that it inherits from DefaultAdapter.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"DefaultRouter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"adapterSwap(address,address,uint256,address,bytes)":"24a98f11"}},"solidity/SynapseRouterV2.sol:EnumerableMap":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122076dd1db60671830f4f33275bcc3394b8dfa502ad306c7cfb35ad9b5b9d661de464736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122076dd1db60671830f4f33275bcc3394b8dfa502ad306c7cfb35ad9b5b9d661de464736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"54238:6777:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;54238:6777:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"54238:6777:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing an enumerable variant of Solidity's https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`] type. Maps have the following properties: - Entries are added, removed, and checked for existence in constant time (O(1)). - Entries are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableMap for EnumerableMap.UintToAddressMap;     // Declare a set state variable     EnumerableMap.UintToAddressMap private myMap; } ``` As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are supported.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing an enumerable variant of Solidity's https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`] type. Maps have the following properties: - Entries are added, removed, and checked for existence in constant time (O(1)). - Entries are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableMap for EnumerableMap.UintToAddressMap;     // Declare a set state variable     EnumerableMap.UintToAddressMap private myMap; } ``` As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are supported.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"EnumerableMap\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:EnumerableSet":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200a141b9612aa319129b811f2d73db44e94c615da02ccc8ab036293080db57a4464736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200a141b9612aa319129b811f2d73db44e94c615da02ccc8ab036293080db57a4464736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"21939:11368:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;21939:11368:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"21939:11368:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"EnumerableSet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:IBridgeModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"isSwap","type":"bool"}],"name":"calculateFeeAmount","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"destQuery","type":"tuple"}],"name":"delegateBridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"bridgeTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getMaxBridgedAmount","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"symbol","type":"string"}],"name":"symbolToToken","outputs":[{"internalType":"address","name":"token","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"tokenToActionMask","outputs":[{"internalType":"uint256","name":"actionMask","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"tokenToSymbol","outputs":[{"internalType":"string","name":"symbol","type":"string"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"calculateFeeAmount(address,uint256,bool)":{"notice":"Calculates the fee amount for bridging a token to this chain."},"delegateBridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes))":{"notice":"Performs a bridging transaction on behalf of the sender, assuming they already have `token`."},"getBridgeTokens()":{"notice":"Returns the list of all supported bridge tokens and their bridge symbols. - Bridge symbol is consistent across all chains for a given token and their bridge. - Bridge symbol doesn't have to be the same as the token symbol on this chain."},"getMaxBridgedAmount(address)":{"notice":"Gets the maximum amount of tokens user can bridge from this chain."},"symbolToToken(string)":{"notice":"Returns the address of the bridge token for a given bridge symbol. - Bridge symbol is consistent across all chains for a given token and their bridge. - Bridge symbol doesn't have to be the same as the token symbol on this chain."},"tokenToActionMask(address)":{"notice":"Returns the action mask associated with bridging a token to this chain. Action mask is a bitmask of the actions that could be performed with the token atomically with the incoming bridge transaction to this chain. See Structs.sol for the list of actions."},"tokenToSymbol(address)":{"notice":"Returns the bridge symbol of a given bridge token. - Bridge symbol is consistent across all chains for a given token and their bridge. - Bridge symbol doesn't have to be the same as the token symbol on this chain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"calculateFeeAmount(address,uint256,bool)":{"details":"Will revert if the token is not supported.","params":{"amount":"Amount of tokens to be bridged","isSwap":"Whether the user provided swap details for converting the bridge token                     to the final token on this chain","token":"Address of the bridge token"},"returns":{"fee":"        Fee amount"}},"delegateBridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes))":{"details":"This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens. This will revert if delegatecall is not used.","params":{"amount":"Amount of the tokens for the bridge transaction","chainId":"Destination chain id","destQuery":"Destination swap query. Empty struct indicates no swap is required","to":"Address to receive tokens on destination chain","token":"Address of the bridge token"}},"getBridgeTokens()":{"returns":{"bridgeTokens":"Supported bridge tokens and their bridge symbols"}},"getMaxBridgedAmount(address)":{"params":{"token":"Address of the bridge token"},"returns":{"amount":"     Max amount of tokens user can bridge from this chain"}},"symbolToToken(string)":{"details":"Will return address(0) if the token is not supported.","params":{"symbol":"Symbol of the supported bridge token used by the token's bridge"},"returns":{"token":"      Address of the bridge token"}},"tokenToActionMask(address)":{"details":"Will return 0 (empty mask) if the token is not supported.","params":{"token":"Address of the bridge token"},"returns":{"actionMask":" Action mask for the bridge token"}},"tokenToSymbol(address)":{"details":"Will return empty string if the token is not supported.","params":{"token":"Address of the bridge token"},"returns":{"symbol":"     Symbol of the supported bridge token used by the token's bridge"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSwap\",\"type\":\"bool\"}],\"name\":\"calculateFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"destQuery\",\"type\":\"tuple\"}],\"name\":\"delegateBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"bridgeTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMaxBridgedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"symbolToToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenToActionMask\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actionMask\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenToSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculateFeeAmount(address,uint256,bool)\":{\"details\":\"Will revert if the token is not supported.\",\"params\":{\"amount\":\"Amount of tokens to be bridged\",\"isSwap\":\"Whether the user provided swap details for converting the bridge token                     to the final token on this chain\",\"token\":\"Address of the bridge token\"},\"returns\":{\"fee\":\"        Fee amount\"}},\"delegateBridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes))\":{\"details\":\"This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens. This will revert if delegatecall is not used.\",\"params\":{\"amount\":\"Amount of the tokens for the bridge transaction\",\"chainId\":\"Destination chain id\",\"destQuery\":\"Destination swap query. Empty struct indicates no swap is required\",\"to\":\"Address to receive tokens on destination chain\",\"token\":\"Address of the bridge token\"}},\"getBridgeTokens()\":{\"returns\":{\"bridgeTokens\":\"Supported bridge tokens and their bridge symbols\"}},\"getMaxBridgedAmount(address)\":{\"params\":{\"token\":\"Address of the bridge token\"},\"returns\":{\"amount\":\"     Max amount of tokens user can bridge from this chain\"}},\"symbolToToken(string)\":{\"details\":\"Will return address(0) if the token is not supported.\",\"params\":{\"symbol\":\"Symbol of the supported bridge token used by the token's bridge\"},\"returns\":{\"token\":\"      Address of the bridge token\"}},\"tokenToActionMask(address)\":{\"details\":\"Will return 0 (empty mask) if the token is not supported.\",\"params\":{\"token\":\"Address of the bridge token\"},\"returns\":{\"actionMask\":\" Action mask for the bridge token\"}},\"tokenToSymbol(address)\":{\"details\":\"Will return empty string if the token is not supported.\",\"params\":{\"token\":\"Address of the bridge token\"},\"returns\":{\"symbol\":\"     Symbol of the supported bridge token used by the token's bridge\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculateFeeAmount(address,uint256,bool)\":{\"notice\":\"Calculates the fee amount for bridging a token to this chain.\"},\"delegateBridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes))\":{\"notice\":\"Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\"},\"getBridgeTokens()\":{\"notice\":\"Returns the list of all supported bridge tokens and their bridge symbols. - Bridge symbol is consistent across all chains for a given token and their bridge. - Bridge symbol doesn't have to be the same as the token symbol on this chain.\"},\"getMaxBridgedAmount(address)\":{\"notice\":\"Gets the maximum amount of tokens user can bridge from this chain.\"},\"symbolToToken(string)\":{\"notice\":\"Returns the address of the bridge token for a given bridge symbol. - Bridge symbol is consistent across all chains for a given token and their bridge. - Bridge symbol doesn't have to be the same as the token symbol on this chain.\"},\"tokenToActionMask(address)\":{\"notice\":\"Returns the action mask associated with bridging a token to this chain. Action mask is a bitmask of the actions that could be performed with the token atomically with the incoming bridge transaction to this chain. See Structs.sol for the list of actions.\"},\"tokenToSymbol(address)\":{\"notice\":\"Returns the bridge symbol of a given bridge token. - Bridge symbol is consistent across all chains for a given token and their bridge. - Bridge symbol doesn't have to be the same as the token symbol on this chain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IBridgeModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"calculateFeeAmount(address,uint256,bool)":"0d25aafe","delegateBridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes))":"436f3aa5","getBridgeTokens()":"9c1d060e","getMaxBridgedAmount(address)":"04b1ac29","symbolToToken(string)":"a5bc29c2","tokenToActionMask(address)":"98b57505","tokenToSymbol(address)":"0ba36121"}},"solidity/SynapseRouterV2.sol:IDefaultExtendedPool":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"uint256","name":"minToMint","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"addLiquidity","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"calculateRemoveLiquidity","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenAmount","type":"uint256"},{"internalType":"uint8","name":"tokenIndex","type":"uint8"}],"name":"calculateRemoveLiquidityOneToken","outputs":[{"internalType":"uint256","name":"availableTokenAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"}],"name":"calculateSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAPrecise","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"index","type":"uint8"}],"name":"getToken","outputs":[{"internalType":"address","name":"token","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"index","type":"uint8"}],"name":"getTokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenAmount","type":"uint256"},{"internalType":"uint8","name":"tokenIndex","type":"uint8"},{"internalType":"uint256","name":"minAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidityOneToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"},{"internalType":"uint256","name":"minDy","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"swapStorage","outputs":[{"internalType":"uint256","name":"initialA","type":"uint256"},{"internalType":"uint256","name":"futureA","type":"uint256"},{"internalType":"uint256","name":"initialATime","type":"uint256"},{"internalType":"uint256","name":"futureATime","type":"uint256"},{"internalType":"uint256","name":"swapFee","type":"uint256"},{"internalType":"uint256","name":"adminFee","type":"uint256"},{"internalType":"address","name":"lpToken","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"}],\"name\":\"calculateRemoveLiquidityOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPrecise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialATime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureATime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IDefaultExtendedPool\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"addLiquidity(uint256[],uint256,uint256)":"4d49e87d","calculateRemoveLiquidity(uint256)":"f2fad2b6","calculateRemoveLiquidityOneToken(uint256,uint8)":"342a87a1","calculateSwap(uint8,uint8,uint256)":"a95b089f","getAPrecise()":"0ba81959","getToken(uint8)":"82b86600","getTokenBalance(uint8)":"91ceb3eb","removeLiquidityOneToken(uint256,uint8,uint256,uint256)":"3e3a1560","swap(uint8,uint8,uint256,uint256,uint256)":"91695586","swapStorage()":"5fd65f0f"}},"solidity/SynapseRouterV2.sol:IDefaultPool":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"}],"name":"calculateSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"index","type":"uint8"}],"name":"getToken","outputs":[{"internalType":"address","name":"token","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"},{"internalType":"uint256","name":"minDy","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IDefaultPool\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"calculateSwap(uint8,uint8,uint256)":"a95b089f","getToken(uint8)":"82b86600","swap(uint8,uint8,uint256,uint256,uint256)":"91695586"}},"solidity/SynapseRouterV2.sol:IERC20":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC20 standard as defined in the EIP.","events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 standard as defined in the EIP.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IERC20\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/SynapseRouterV2.sol:IRouterAdapter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"name":"adapterSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"notice":"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient."}},"version":1},"developerDoc":{"kind":"dev","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"details":"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.","params":{"amountIn":"Amount of tokens to sell","rawParams":"Additional swap parameters","recipient":"Address to receive the swapped token","tokenIn":"Token to sell (use ETH_ADDRESS to start from native ETH)","tokenOut":"Token to buy (use ETH_ADDRESS to end with native ETH)"},"returns":{"amountOut":"  Amount of bought tokens"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"name\":\"adapterSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"details\":\"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.\",\"params\":{\"amountIn\":\"Amount of tokens to sell\",\"rawParams\":\"Additional swap parameters\",\"recipient\":\"Address to receive the swapped token\",\"tokenIn\":\"Token to sell (use ETH_ADDRESS to start from native ETH)\",\"tokenOut\":\"Token to buy (use ETH_ADDRESS to end with native ETH)\"},\"returns\":{\"amountOut\":\"  Amount of bought tokens\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"notice\":\"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IRouterAdapter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"adapterSwap(address,address,uint256,address,bytes)":"24a98f11"}},"solidity/SynapseRouterV2.sol:IRouterV2":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"originQuery","type":"tuple"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"destQuery","type":"tuple"}],"name":"bridgeViaSynapse","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"internalType":"address","name":"bridgeModule","type":"address"}],"name":"connectBridgeModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"name":"disconnectBridgeModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"bridgeTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"internalType":"struct DestRequest","name":"request","type":"tuple"},{"internalType":"address","name":"tokenOut","type":"address"}],"name":"getDestinationAmountOut","outputs":[{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"destQuery","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOut","type":"address"}],"name":"getDestinationBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"destTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"string","name":"tokenSymbol","type":"string"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"name":"getOriginAmountOut","outputs":[{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"originQuery","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"}],"name":"getOriginBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"originTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSupportedTokens","outputs":[{"internalType":"address[]","name":"supportedTokens","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"name":"idToModule","outputs":[{"internalType":"address","name":"bridgeModule","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"bridgeModule","type":"address"}],"name":"moduleToId","outputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"setAllowance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ISwapQuoterV2","name":"_swapQuoter","type":"address"}],"name":"setSwapQuoter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"query","type":"tuple"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"internalType":"address","name":"bridgeModule","type":"address"}],"name":"updateBridgeModule","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))":{"notice":"Initiate a bridge transaction with an optional swap on both origin and destination chains."},"connectBridgeModule(bytes32,address)":{"notice":"Whitelists a new bridge module for users to route through"},"disconnectBridgeModule(bytes32)":{"notice":"Disconnects a whitelisted bridge module"},"getBridgeTokens()":{"notice":"Gets all bridge tokens for supported bridge modules"},"getDestinationAmountOut((string,uint256),address)":{"notice":"Finds the best path between every supported bridge token from the given list and `tokenOut`, treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token."},"getDestinationBridgeTokens(address)":{"notice":"Gets the list of all bridge tokens (and their symbols), such that destination swap from a bridge token to `tokenOut` is possible."},"getOriginAmountOut(address,string,uint256)":{"notice":"Finds the best path between `tokenIn` and every supported bridge token from the given list, treating the swap as \"origin swap\", without putting any restrictions on the swap."},"getOriginBridgeTokens(address)":{"notice":"Gets the list of all bridge tokens (and their symbols), such that origin swap from `tokenIn` to a bridge token is possible."},"getSupportedTokens()":{"notice":"Gets the list of all tokens that can be swapped into bridge tokens on this chain."},"idToModule(bytes32)":{"notice":"Gets the address associated with the given bridge module ID"},"moduleToId(address)":{"notice":"Gets the module ID associated with the given bridge module address"},"setAllowance(address,address,uint256)":{"notice":"Sets a custom allowance for the given token."},"setSwapQuoter(address)":{"notice":"Sets the Swap Quoter address to get the swap quotes from."},"swap(address,address,uint256,(address,address,uint256,uint256,bytes))":{"notice":"Perform a swap using the supplied parameters."},"updateBridgeModule(bytes32,address)":{"notice":"Updates a whitelisted bridge module"}},"version":1},"developerDoc":{"kind":"dev","methods":{"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))":{"details":"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens. `token` is always a token user is sending. In case token requires a wrapper token to be bridge, use underlying address for `token` instead of the wrapper one. `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut should always use the underlying address. In other words, the concept of wrapper token is fully abstracted away from the end user. `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut(). Alternatively one could use an external adapter for more complex swaps on the origin chain. `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut(). Complex swaps on destination chain are not supported for the time being. Check contract description above for more details.","params":{"amount":"Amount of the initial tokens for the bridge transaction","chainId":"Destination chain id","destQuery":"Destination swap query. Empty struct indicates no swap is required","moduleId":"Bridge module id to delegate bridge call","originQuery":"Origin swap query. Empty struct indicates no swap is required","to":"Address to receive tokens on destination chain","token":"Initial token for the bridge transaction to be pulled from the user"}},"connectBridgeModule(bytes32,address)":{"details":"Reverts if not router owner","params":{"bridgeModule":"Bridge module address","moduleId":"Unique bridge module ID"}},"disconnectBridgeModule(bytes32)":{"details":"Reverts if not router owner","params":{"moduleId":"Unique bridge module ID"}},"getBridgeTokens()":{"details":"Intended for off-chain queries.","returns":{"bridgeTokens":"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address"}},"getDestinationAmountOut((string,uint256),address)":{"details":"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap. For the time being, only swaps through the Synapse-supported pools are available on destination chain.","params":{"request":"Struct with following information:                 - symbol: unique token ID consistent among all chains                 - amountIn: amount of bridge token to start with, before the bridge fee is applied","tokenOut":"Token user wants to receive on destination chain"},"returns":{"destQuery":" Structs that could be used as `destQuery` in SynapseRouter.                      minAmountOut and deadline fields will need to be adjusted based on the user settings."}},"getDestinationBridgeTokens(address)":{"details":"Intended for off-chain queries.","params":{"tokenOut":"Token address to swap to on destination chain"},"returns":{"destTokens":"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address"}},"getOriginAmountOut(address,string,uint256)":{"details":"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported. The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter. Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.","params":{"amountIn":"Amount of tokens user wants to bridge/swap","tokenIn":"Initial token that user wants to bridge/swap","tokenSymbol":"Symbol representing bridge tokens"},"returns":{"originQuery":"   Structs that could be used as `originQuery` in SynapseRouter.                          minAmountOut and deadline fields will need to be adjusted based on the user settings."}},"getOriginBridgeTokens(address)":{"details":"Intended for off-chain queries.","params":{"tokenIn":"Token address to swap from on origin chain"},"returns":{"originTokens":"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address"}},"getSupportedTokens()":{"details":"Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.Intended for off-chain queries.","returns":{"supportedTokens":"Supported token addresses that can be swapped for bridge tokens"}},"idToModule(bytes32)":{"params":{"moduleId":"Unique bridge module ID"},"returns":{"bridgeModule":"Bridge module address"}},"moduleToId(address)":{"params":{"bridgeModule":"Bridge module address"},"returns":{"moduleId":"Unique bridge module ID"}},"setAllowance(address,address,uint256)":{"details":"Reverts if not router owner. To be used for the wrapper token setups."},"setSwapQuoter(address)":{"params":{"_swapQuoter":"Swap Quoter"}},"swap(address,address,uint256,(address,address,uint256,uint256,bytes))":{"details":"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If query.tokenOut is ERC20, the tokens will be transferred to the recipient.","params":{"amount":"Amount of tokens to swap","query":"Query with the swap parameters (see BridgeStructs.sol)","to":"Address to receive swapped tokens","token":"Token to swap"},"returns":{"amountOut":"   Amount of swapped tokens received by the user"}},"updateBridgeModule(bytes32,address)":{"details":"Reverts if not router owner","params":{"bridgeModule":"New bridge module address to update to","moduleId":"Unique bridge module ID"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"destQuery\",\"type\":\"tuple\"}],\"name\":\"bridgeViaSynapse\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"connectBridgeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"disconnectBridgeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"bridgeTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct DestRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getDestinationAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"destQuery\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getDestinationBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"destTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getOriginAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getOriginBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"originTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"supportedTokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"idToModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"moduleToId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapQuoterV2\",\"name\":\"_swapQuoter\",\"type\":\"address\"}],\"name\":\"setSwapQuoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"updateBridgeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))\":{\"details\":\"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens. `token` is always a token user is sending. In case token requires a wrapper token to be bridge, use underlying address for `token` instead of the wrapper one. `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut should always use the underlying address. In other words, the concept of wrapper token is fully abstracted away from the end user. `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut(). Alternatively one could use an external adapter for more complex swaps on the origin chain. `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut(). Complex swaps on destination chain are not supported for the time being. Check contract description above for more details.\",\"params\":{\"amount\":\"Amount of the initial tokens for the bridge transaction\",\"chainId\":\"Destination chain id\",\"destQuery\":\"Destination swap query. Empty struct indicates no swap is required\",\"moduleId\":\"Bridge module id to delegate bridge call\",\"originQuery\":\"Origin swap query. Empty struct indicates no swap is required\",\"to\":\"Address to receive tokens on destination chain\",\"token\":\"Initial token for the bridge transaction to be pulled from the user\"}},\"connectBridgeModule(bytes32,address)\":{\"details\":\"Reverts if not router owner\",\"params\":{\"bridgeModule\":\"Bridge module address\",\"moduleId\":\"Unique bridge module ID\"}},\"disconnectBridgeModule(bytes32)\":{\"details\":\"Reverts if not router owner\",\"params\":{\"moduleId\":\"Unique bridge module ID\"}},\"getBridgeTokens()\":{\"details\":\"Intended for off-chain queries.\",\"returns\":{\"bridgeTokens\":\"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address\"}},\"getDestinationAmountOut((string,uint256),address)\":{\"details\":\"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap. For the time being, only swaps through the Synapse-supported pools are available on destination chain.\",\"params\":{\"request\":\"Struct with following information:                 - symbol: unique token ID consistent among all chains                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\",\"tokenOut\":\"Token user wants to receive on destination chain\"},\"returns\":{\"destQuery\":\" Structs that could be used as `destQuery` in SynapseRouter.                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\"}},\"getDestinationBridgeTokens(address)\":{\"details\":\"Intended for off-chain queries.\",\"params\":{\"tokenOut\":\"Token address to swap to on destination chain\"},\"returns\":{\"destTokens\":\"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address\"}},\"getOriginAmountOut(address,string,uint256)\":{\"details\":\"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported. The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter. Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\",\"params\":{\"amountIn\":\"Amount of tokens user wants to bridge/swap\",\"tokenIn\":\"Initial token that user wants to bridge/swap\",\"tokenSymbol\":\"Symbol representing bridge tokens\"},\"returns\":{\"originQuery\":\"   Structs that could be used as `originQuery` in SynapseRouter.                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\"}},\"getOriginBridgeTokens(address)\":{\"details\":\"Intended for off-chain queries.\",\"params\":{\"tokenIn\":\"Token address to swap from on origin chain\"},\"returns\":{\"originTokens\":\"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address\"}},\"getSupportedTokens()\":{\"details\":\"Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.Intended for off-chain queries.\",\"returns\":{\"supportedTokens\":\"Supported token addresses that can be swapped for bridge tokens\"}},\"idToModule(bytes32)\":{\"params\":{\"moduleId\":\"Unique bridge module ID\"},\"returns\":{\"bridgeModule\":\"Bridge module address\"}},\"moduleToId(address)\":{\"params\":{\"bridgeModule\":\"Bridge module address\"},\"returns\":{\"moduleId\":\"Unique bridge module ID\"}},\"setAllowance(address,address,uint256)\":{\"details\":\"Reverts if not router owner. To be used for the wrapper token setups.\"},\"setSwapQuoter(address)\":{\"params\":{\"_swapQuoter\":\"Swap Quoter\"}},\"swap(address,address,uint256,(address,address,uint256,uint256,bytes))\":{\"details\":\"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\",\"params\":{\"amount\":\"Amount of tokens to swap\",\"query\":\"Query with the swap parameters (see BridgeStructs.sol)\",\"to\":\"Address to receive swapped tokens\",\"token\":\"Token to swap\"},\"returns\":{\"amountOut\":\"   Amount of swapped tokens received by the user\"}},\"updateBridgeModule(bytes32,address)\":{\"details\":\"Reverts if not router owner\",\"params\":{\"bridgeModule\":\"New bridge module address to update to\",\"moduleId\":\"Unique bridge module ID\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))\":{\"notice\":\"Initiate a bridge transaction with an optional swap on both origin and destination chains.\"},\"connectBridgeModule(bytes32,address)\":{\"notice\":\"Whitelists a new bridge module for users to route through\"},\"disconnectBridgeModule(bytes32)\":{\"notice\":\"Disconnects a whitelisted bridge module\"},\"getBridgeTokens()\":{\"notice\":\"Gets all bridge tokens for supported bridge modules\"},\"getDestinationAmountOut((string,uint256),address)\":{\"notice\":\"Finds the best path between every supported bridge token from the given list and `tokenOut`, treating the swap as \\\"destination swap\\\", limiting possible actions to those available for every bridge token.\"},\"getDestinationBridgeTokens(address)\":{\"notice\":\"Gets the list of all bridge tokens (and their symbols), such that destination swap from a bridge token to `tokenOut` is possible.\"},\"getOriginAmountOut(address,string,uint256)\":{\"notice\":\"Finds the best path between `tokenIn` and every supported bridge token from the given list, treating the swap as \\\"origin swap\\\", without putting any restrictions on the swap.\"},\"getOriginBridgeTokens(address)\":{\"notice\":\"Gets the list of all bridge tokens (and their symbols), such that origin swap from `tokenIn` to a bridge token is possible.\"},\"getSupportedTokens()\":{\"notice\":\"Gets the list of all tokens that can be swapped into bridge tokens on this chain.\"},\"idToModule(bytes32)\":{\"notice\":\"Gets the address associated with the given bridge module ID\"},\"moduleToId(address)\":{\"notice\":\"Gets the module ID associated with the given bridge module address\"},\"setAllowance(address,address,uint256)\":{\"notice\":\"Sets a custom allowance for the given token.\"},\"setSwapQuoter(address)\":{\"notice\":\"Sets the Swap Quoter address to get the swap quotes from.\"},\"swap(address,address,uint256,(address,address,uint256,uint256,bytes))\":{\"notice\":\"Perform a swap using the supplied parameters.\"},\"updateBridgeModule(bytes32,address)\":{\"notice\":\"Updates a whitelisted bridge module\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IRouterV2\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))":"c95fafd2","connectBridgeModule(bytes32,address)":"b3bce952","disconnectBridgeModule(bytes32)":"b68e4302","getBridgeTokens()":"9c1d060e","getDestinationAmountOut((string,uint256),address)":"7de31c74","getDestinationBridgeTokens(address)":"1d04879b","getOriginAmountOut(address,string,uint256)":"f533941d","getOriginBridgeTokens(address)":"3e811a5c","getSupportedTokens()":"d3c7c2c7","idToModule(bytes32)":"53e2e8e7","moduleToId(address)":"9f2671fa","setAllowance(address,address,uint256)":"da46098c","setSwapQuoter(address)":"804b3dff","swap(address,address,uint256,(address,address,uint256,uint256,bytes))":"b5d1cdd4","updateBridgeModule(bytes32,address)":"70a1cdc9"}},"solidity/SynapseRouterV2.sol:ISwapQuoterV1":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"allPools","outputs":[{"components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"lpToken","type":"address"},{"components":[{"internalType":"bool","name":"isWeth","type":"bool"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct PoolToken[]","name":"tokens","type":"tuple[]"}],"internalType":"struct Pool[]","name":"pools","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"calculateAddLiquidity","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"calculateRemoveLiquidity","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"}],"name":"calculateSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"tokenAmount","type":"uint256"},{"internalType":"uint8","name":"tokenIndex","type":"uint8"}],"name":"calculateWithdrawOneToken","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"defaultPoolCalc","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"actionMask","type":"uint256"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct LimitedToken[]","name":"bridgeTokensIn","type":"tuple[]"},{"internalType":"address","name":"tokenOut","type":"address"}],"name":"findConnectedTokens","outputs":[{"internalType":"uint256","name":"amountFound","type":"uint256"},{"internalType":"bool[]","name":"isConnected","type":"bool[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"actionMask","type":"uint256"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct LimitedToken","name":"tokenIn","type":"tuple"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"name":"getAmountOut","outputs":[{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"query","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"name":"poolInfo","outputs":[{"internalType":"uint256","name":"numTokens","type":"uint256"},{"internalType":"address","name":"lpToken","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"name":"poolTokens","outputs":[{"components":[{"internalType":"bool","name":"isWeth","type":"bool"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct PoolToken[]","name":"tokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"poolsAmount","outputs":[{"internalType":"uint256","name":"amtPools","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"weth","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"allPools()":{"notice":"Returns a list of all supported pools."},"calculateAddLiquidity(address,uint256[])":{"notice":"Returns the exact quote for adding liquidity to a given pool in a form of a single token."},"calculateRemoveLiquidity(address,uint256)":{"notice":"Returns the exact quote for withdrawing pools tokens in a balanced way."},"calculateSwap(address,uint8,uint8,uint256)":{"notice":"Returns the exact quote for swapping between two given tokens."},"calculateWithdrawOneToken(address,uint256,uint8)":{"notice":"Returns the exact quote for withdrawing a single pool token."},"defaultPoolCalc()":{"notice":"Address of deployed calculator contract for DefaultPool, which is able to calculate EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do)."},"findConnectedTokens((uint256,address)[],address)":{"notice":"Checks if a swap is possible between every bridge token in the given list and tokenOut. Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap."},"getAmountOut((uint256,address),address,uint256)":{"notice":"Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools. - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow), `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()). - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow, `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token, e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens. \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter. \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings."},"poolInfo(address)":{"notice":"Returns the number of tokens the given pool supports and the pool's LP token."},"poolTokens(address)":{"notice":"Returns a list of pool tokens for the given pool."},"poolsAmount()":{"notice":"Returns the amount of supported pools."},"weth()":{"notice":"Address of WETH token used in the pools. Represents wrapped version of chain's native currency, e.g. WETH on Ethereum, WBNB on BSC, etc."}},"notice":"Interface for the SwapQuoterV1 version with updated pragma and enriched docs.","version":1},"developerDoc":{"kind":"dev","methods":{"calculateAddLiquidity(address,uint256[])":{"details":"The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`, which gives an ESTIMATE: it doesn't take the trade fees into account. We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this. We also need the exact quotes for adding liquidity to the pools. Note: the function might revert instead of returning 0 for incorrect requests. Make sure to take that into account."},"calculateRemoveLiquidity(address,uint256)":{"details":"Exposes IDefaultPool.calculateRemoveLiquidity(amount);"},"calculateSwap(address,uint8,uint8,uint256)":{"details":"Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);"},"calculateWithdrawOneToken(address,uint256,uint8)":{"details":"Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);"},"findConnectedTokens((uint256,address)[],address)":{"params":{"bridgeTokensIn":"List of structs with following information:                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                         - token         Bridge token address to swap from","tokenOut":"Token address to swap to"},"returns":{"amountFound":"    Amount of tokens from the list that are swappable to tokenOut","isConnected":"    List of bool values, specifying whether a token from the list is swappable to tokenOut"}},"getAmountOut((uint256,address),address,uint256)":{"details":"If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered. Three potential outcomes are available: 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens). 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found. 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found. The exact composition of the returned struct for every case is documented in the return parameter documentation.","params":{"amountIn":"Amount of tokens to swap from","tokenIn":"Struct with following information:                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                 - token         Token address to swap from","tokenOut":"Token address to swap to"},"returns":{"query":"  Struct representing trade path between tokenIn and tokenOut:                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,                 or tokens are identical. Address of SynapseRouter otherwise.                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,                 if no path is found, or tokens are identical."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"allPools\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct PoolToken[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Pool[]\",\"name\":\"pools\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"calculateAddLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"}],\"name\":\"calculateWithdrawOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPoolCalc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"actionMask\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct LimitedToken[]\",\"name\":\"bridgeTokensIn\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"findConnectedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountFound\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isConnected\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"actionMask\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct LimitedToken\",\"name\":\"tokenIn\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct PoolToken[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amtPools\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculateAddLiquidity(address,uint256[])\":{\"details\":\"The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`, which gives an ESTIMATE: it doesn't take the trade fees into account. We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \\\"swaps\\\" on Mainnet, hence we do this. We also need the exact quotes for adding liquidity to the pools. Note: the function might revert instead of returning 0 for incorrect requests. Make sure to take that into account.\"},\"calculateRemoveLiquidity(address,uint256)\":{\"details\":\"Exposes IDefaultPool.calculateRemoveLiquidity(amount);\"},\"calculateSwap(address,uint8,uint8,uint256)\":{\"details\":\"Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\"},\"calculateWithdrawOneToken(address,uint256,uint8)\":{\"details\":\"Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\"},\"findConnectedTokens((uint256,address)[],address)\":{\"params\":{\"bridgeTokensIn\":\"List of structs with following information:                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                         - token         Bridge token address to swap from\",\"tokenOut\":\"Token address to swap to\"},\"returns\":{\"amountFound\":\"    Amount of tokens from the list that are swappable to tokenOut\",\"isConnected\":\"    List of bool values, specifying whether a token from the list is swappable to tokenOut\"}},\"getAmountOut((uint256,address),address,uint256)\":{\"details\":\"If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered. Three potential outcomes are available: 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens). 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found. 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found. The exact composition of the returned struct for every case is documented in the return parameter documentation.\",\"params\":{\"amountIn\":\"Amount of tokens to swap from\",\"tokenIn\":\"Struct with following information:                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                 - token         Token address to swap from\",\"tokenOut\":\"Token address to swap to\"},\"returns\":{\"query\":\"  Struct representing trade path between tokenIn and tokenOut:                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,                 or tokens are identical. Address of SynapseRouter otherwise.                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,                 if no path is found, or tokens are identical.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allPools()\":{\"notice\":\"Returns a list of all supported pools.\"},\"calculateAddLiquidity(address,uint256[])\":{\"notice\":\"Returns the exact quote for adding liquidity to a given pool in a form of a single token.\"},\"calculateRemoveLiquidity(address,uint256)\":{\"notice\":\"Returns the exact quote for withdrawing pools tokens in a balanced way.\"},\"calculateSwap(address,uint8,uint8,uint256)\":{\"notice\":\"Returns the exact quote for swapping between two given tokens.\"},\"calculateWithdrawOneToken(address,uint256,uint8)\":{\"notice\":\"Returns the exact quote for withdrawing a single pool token.\"},\"defaultPoolCalc()\":{\"notice\":\"Address of deployed calculator contract for DefaultPool, which is able to calculate EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\"},\"findConnectedTokens((uint256,address)[],address)\":{\"notice\":\"Checks if a swap is possible between every bridge token in the given list and tokenOut. Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\"},\"getAmountOut((uint256,address),address,uint256)\":{\"notice\":\"Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools. - If this is a request for the swap to be performed immediately (or the \\\"origin swap\\\" in the bridge workflow), `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()). - If this is a request for the swap to be performed as the \\\"destination swap\\\" in the bridge workflow, `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token, e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens. \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter. \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\"},\"poolInfo(address)\":{\"notice\":\"Returns the number of tokens the given pool supports and the pool's LP token.\"},\"poolTokens(address)\":{\"notice\":\"Returns a list of pool tokens for the given pool.\"},\"poolsAmount()\":{\"notice\":\"Returns the amount of supported pools.\"},\"weth()\":{\"notice\":\"Address of WETH token used in the pools. Represents wrapped version of chain's native currency, e.g. WETH on Ethereum, WBNB on BSC, etc.\"}},\"notice\":\"Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"ISwapQuoterV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"allPools()":"c5c63e65","calculateAddLiquidity(address,uint256[])":"4d864496","calculateRemoveLiquidity(address,uint256)":"7c61e561","calculateSwap(address,uint8,uint8,uint256)":"798af720","calculateWithdrawOneToken(address,uint256,uint8)":"ccc1bbc1","defaultPoolCalc()":"65170fa2","findConnectedTokens((uint256,address)[],address)":"a08129ce","getAmountOut((uint256,address),address,uint256)":"e6b00009","poolInfo(address)":"9a7b5f11","poolTokens(address)":"a9126169","poolsAmount()":"ba7d536e","weth()":"3fc8cef3"}},"solidity/SynapseRouterV2.sol:ISwapQuoterV2":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"allPools","outputs":[{"components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"lpToken","type":"address"},{"components":[{"internalType":"bool","name":"isWeth","type":"bool"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct PoolToken[]","name":"tokens","type":"tuple[]"}],"internalType":"struct Pool[]","name":"pools","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"actionMask","type":"uint256"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct LimitedToken","name":"tokenIn","type":"tuple"},{"internalType":"address","name":"tokenOut","type":"address"}],"name":"areConnectedTokens","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"calculateAddLiquidity","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"calculateRemoveLiquidity","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"}],"name":"calculateSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"tokenAmount","type":"uint256"},{"internalType":"uint8","name":"tokenIndex","type":"uint8"}],"name":"calculateWithdrawOneToken","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"defaultPoolCalc","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"actionMask","type":"uint256"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct LimitedToken[]","name":"bridgeTokensIn","type":"tuple[]"},{"internalType":"address","name":"tokenOut","type":"address"}],"name":"findConnectedTokens","outputs":[{"internalType":"uint256","name":"amountFound","type":"uint256"},{"internalType":"bool[]","name":"isConnected","type":"bool[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"actionMask","type":"uint256"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct LimitedToken","name":"tokenIn","type":"tuple"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"name":"getAmountOut","outputs":[{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"query","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"name":"poolInfo","outputs":[{"internalType":"uint256","name":"numTokens","type":"uint256"},{"internalType":"address","name":"lpToken","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"name":"poolTokens","outputs":[{"components":[{"internalType":"bool","name":"isWeth","type":"bool"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct PoolToken[]","name":"tokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"poolsAmount","outputs":[{"internalType":"uint256","name":"amtPools","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"synapseRouter_","type":"address"}],"name":"setSynapseRouter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"weth","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"allPools()":{"notice":"Returns a list of all supported pools."},"areConnectedTokens((uint256,address),address)":{"notice":"Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools. Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask: - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow), `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).  For this case, all pools added to SwapQuoterV2 will be considered for the swap. - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow, `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token, e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens. As for the pools considered for the swap, there are two cases: - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow), all pools added to SwapQuoterV2 will be considered for the swap. - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow, only the whitelisted pool for tokenIn.token will be considered for the swap."},"calculateAddLiquidity(address,uint256[])":{"notice":"Returns the exact quote for adding liquidity to a given pool in a form of a single token."},"calculateRemoveLiquidity(address,uint256)":{"notice":"Returns the exact quote for withdrawing pools tokens in a balanced way."},"calculateSwap(address,uint8,uint8,uint256)":{"notice":"Returns the exact quote for swapping between two given tokens."},"calculateWithdrawOneToken(address,uint256,uint8)":{"notice":"Returns the exact quote for withdrawing a single pool token."},"defaultPoolCalc()":{"notice":"Address of deployed calculator contract for DefaultPool, which is able to calculate EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do)."},"findConnectedTokens((uint256,address)[],address)":{"notice":"Checks if a swap is possible between every bridge token in the given list and tokenOut. Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap."},"getAmountOut((uint256,address),address,uint256)":{"notice":"Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools. - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow), `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()). - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow, `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token, e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens. \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter. \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings."},"poolInfo(address)":{"notice":"Returns the number of tokens the given pool supports and the pool's LP token."},"poolTokens(address)":{"notice":"Returns a list of pool tokens for the given pool."},"poolsAmount()":{"notice":"Returns the amount of supported pools."},"setSynapseRouter(address)":{"notice":"Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing swaps through Default Pools (or handling ETH). Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter could handle the requests with the new SynapseRouter as external \"Router Adapter\"."},"weth()":{"notice":"Address of WETH token used in the pools. Represents wrapped version of chain's native currency, e.g. WETH on Ethereum, WBNB on BSC, etc."}},"version":1},"developerDoc":{"kind":"dev","methods":{"calculateAddLiquidity(address,uint256[])":{"details":"The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`, which gives an ESTIMATE: it doesn't take the trade fees into account. We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this. We also need the exact quotes for adding liquidity to the pools. Note: the function might revert instead of returning 0 for incorrect requests. Make sure to take that into account."},"calculateRemoveLiquidity(address,uint256)":{"details":"Exposes IDefaultPool.calculateRemoveLiquidity(amount);"},"calculateSwap(address,uint8,uint8,uint256)":{"details":"Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);"},"calculateWithdrawOneToken(address,uint256,uint8)":{"details":"Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);"},"findConnectedTokens((uint256,address)[],address)":{"params":{"bridgeTokensIn":"List of structs with following information:                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                         - token         Bridge token address to swap from","tokenOut":"Token address to swap to"},"returns":{"amountFound":"    Amount of tokens from the list that are swappable to tokenOut","isConnected":"    List of bool values, specifying whether a token from the list is swappable to tokenOut"}},"getAmountOut((uint256,address),address,uint256)":{"details":"If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered. Three potential outcomes are available: 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens). 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found. 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found. The exact composition of the returned struct for every case is documented in the return parameter documentation.","params":{"amountIn":"Amount of tokens to swap from","tokenIn":"Struct with following information:                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                 - token         Token address to swap from","tokenOut":"Token address to swap to"},"returns":{"query":"  Struct representing trade path between tokenIn and tokenOut:                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,                 or tokens are identical. Address of SynapseRouter otherwise.                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,                 if no path is found, or tokens are identical."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"allPools\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct PoolToken[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Pool[]\",\"name\":\"pools\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"actionMask\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct LimitedToken\",\"name\":\"tokenIn\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"areConnectedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"calculateAddLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"}],\"name\":\"calculateWithdrawOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPoolCalc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"actionMask\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct LimitedToken[]\",\"name\":\"bridgeTokensIn\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"findConnectedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountFound\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isConnected\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"actionMask\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct LimitedToken\",\"name\":\"tokenIn\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct PoolToken[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amtPools\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"synapseRouter_\",\"type\":\"address\"}],\"name\":\"setSynapseRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculateAddLiquidity(address,uint256[])\":{\"details\":\"The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`, which gives an ESTIMATE: it doesn't take the trade fees into account. We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \\\"swaps\\\" on Mainnet, hence we do this. We also need the exact quotes for adding liquidity to the pools. Note: the function might revert instead of returning 0 for incorrect requests. Make sure to take that into account.\"},\"calculateRemoveLiquidity(address,uint256)\":{\"details\":\"Exposes IDefaultPool.calculateRemoveLiquidity(amount);\"},\"calculateSwap(address,uint8,uint8,uint256)\":{\"details\":\"Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\"},\"calculateWithdrawOneToken(address,uint256,uint8)\":{\"details\":\"Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\"},\"findConnectedTokens((uint256,address)[],address)\":{\"params\":{\"bridgeTokensIn\":\"List of structs with following information:                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                         - token         Bridge token address to swap from\",\"tokenOut\":\"Token address to swap to\"},\"returns\":{\"amountFound\":\"    Amount of tokens from the list that are swappable to tokenOut\",\"isConnected\":\"    List of bool values, specifying whether a token from the list is swappable to tokenOut\"}},\"getAmountOut((uint256,address),address,uint256)\":{\"details\":\"If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered. Three potential outcomes are available: 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens). 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found. 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found. The exact composition of the returned struct for every case is documented in the return parameter documentation.\",\"params\":{\"amountIn\":\"Amount of tokens to swap from\",\"tokenIn\":\"Struct with following information:                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut                 - token         Token address to swap from\",\"tokenOut\":\"Token address to swap to\"},\"returns\":{\"query\":\"  Struct representing trade path between tokenIn and tokenOut:                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,                 or tokens are identical. Address of SynapseRouter otherwise.                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,                 if no path is found, or tokens are identical.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allPools()\":{\"notice\":\"Returns a list of all supported pools.\"},\"areConnectedTokens((uint256,address),address)\":{\"notice\":\"Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools. Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask: - If this is a request for the swap to be performed immediately (or the \\\"origin swap\\\" in the bridge workflow), `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).  For this case, all pools added to SwapQuoterV2 will be considered for the swap. - If this is a request for the swap to be performed as the \\\"destination swap\\\" in the bridge workflow, `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token, e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens. As for the pools considered for the swap, there are two cases: - If this is a request for the swap to be performed immediately (or the \\\"origin swap\\\" in the bridge workflow), all pools added to SwapQuoterV2 will be considered for the swap. - If this is a request for the swap to be performed as the \\\"destination swap\\\" in the bridge workflow, only the whitelisted pool for tokenIn.token will be considered for the swap.\"},\"calculateAddLiquidity(address,uint256[])\":{\"notice\":\"Returns the exact quote for adding liquidity to a given pool in a form of a single token.\"},\"calculateRemoveLiquidity(address,uint256)\":{\"notice\":\"Returns the exact quote for withdrawing pools tokens in a balanced way.\"},\"calculateSwap(address,uint8,uint8,uint256)\":{\"notice\":\"Returns the exact quote for swapping between two given tokens.\"},\"calculateWithdrawOneToken(address,uint256,uint8)\":{\"notice\":\"Returns the exact quote for withdrawing a single pool token.\"},\"defaultPoolCalc()\":{\"notice\":\"Address of deployed calculator contract for DefaultPool, which is able to calculate EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\"},\"findConnectedTokens((uint256,address)[],address)\":{\"notice\":\"Checks if a swap is possible between every bridge token in the given list and tokenOut. Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\"},\"getAmountOut((uint256,address),address,uint256)\":{\"notice\":\"Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools. - If this is a request for the swap to be performed immediately (or the \\\"origin swap\\\" in the bridge workflow), `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()). - If this is a request for the swap to be performed as the \\\"destination swap\\\" in the bridge workflow, `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token, e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens. \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter. \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\"},\"poolInfo(address)\":{\"notice\":\"Returns the number of tokens the given pool supports and the pool's LP token.\"},\"poolTokens(address)\":{\"notice\":\"Returns a list of pool tokens for the given pool.\"},\"poolsAmount()\":{\"notice\":\"Returns the amount of supported pools.\"},\"setSynapseRouter(address)\":{\"notice\":\"Allows to set the SynapseRouter contract, which is used as \\\"Router Adapter\\\" for doing swaps through Default Pools (or handling ETH). Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter could handle the requests with the new SynapseRouter as external \\\"Router Adapter\\\".\"},\"weth()\":{\"notice\":\"Address of WETH token used in the pools. Represents wrapped version of chain's native currency, e.g. WETH on Ethereum, WBNB on BSC, etc.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"ISwapQuoterV2\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"allPools()":"c5c63e65","areConnectedTokens((uint256,address),address)":"285078fc","calculateAddLiquidity(address,uint256[])":"4d864496","calculateRemoveLiquidity(address,uint256)":"7c61e561","calculateSwap(address,uint8,uint8,uint256)":"798af720","calculateWithdrawOneToken(address,uint256,uint8)":"ccc1bbc1","defaultPoolCalc()":"65170fa2","findConnectedTokens((uint256,address)[],address)":"a08129ce","getAmountOut((uint256,address),address,uint256)":"e6b00009","poolInfo(address)":"9a7b5f11","poolTokens(address)":"a9126169","poolsAmount()":"ba7d536e","setSynapseRouter(address)":"446bac69","weth()":"3fc8cef3"}},"solidity/SynapseRouterV2.sol:IWETH9":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"wad","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"IWETH9\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"deposit()":"d0e30db0","withdraw(uint256)":"2e1a7d4d"}},"solidity/SynapseRouterV2.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/SynapseRouterV2.sol:SafeERC20":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206b970769f18a9b7f66a34ebe5506d065a5867642184e7f5e456173c975e5bc8b64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206b970769f18a9b7f66a34ebe5506d065a5867642184e7f5e456173c975e5bc8b64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"63558:3270:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;63558:3270:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"63558:3270:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.","kind":"dev","methods":{},"title":"SafeERC20","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\",\"kind\":\"dev\",\"methods\":{},\"title\":\"SafeERC20\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"SafeERC20\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:SwapQueryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122025ce66cc54bdbf742df79150788eacb4aff8f6818b1eff240e12aea5718410ef64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122025ce66cc54bdbf742df79150788eacb4aff8f6818b1eff240e12aea5718410ef64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"5978:1048:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;5978:1048:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"5978:1048:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"SwapQueryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseRouterV2.sol:SynapseRouterV2":{"code":"0x60806040523480156200001157600080fd5b506200001d3362000023565b62000073565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b614b4f80620000836000396000f3fe6080604052600436106101635760003560e01c80639c1d060e116100c0578063c95fafd211610074578063da46098c11610059578063da46098c1461039d578063f2fde38b146103bd578063f533941d146103dd57600080fd5b8063c95fafd214610368578063d3c7c2c71461037b57600080fd5b8063b3bce952116100a5578063b3bce95214610315578063b5d1cdd414610335578063b68e43021461034857600080fd5b80639c1d060e146102e05780639f2671fa146102f557600080fd5b806370a1cdc9116101175780637de31c74116100fc5780637de31c7414610275578063804b3dff146102a25780638da5cb5b146102c257600080fd5b806370a1cdc91461023e578063715018a61461026057600080fd5b806334474c8c1161014857806334474c8c146101c65780633e811a5c146101fe57806353e2e8e71461021e57600080fd5b80631d04879b1461016f57806324a98f11146101a557600080fd5b3661016a57005b600080fd5b34801561017b57600080fd5b5061018f61018a366004613d51565b6103fd565b60405161019c9190613dbe565b60405180910390f35b6101b86101b3366004613fa8565b610410565b60405190815260200161019c565b3480156101d257600080fd5b506001546101e6906001600160a01b031681565b6040516001600160a01b03909116815260200161019c565b34801561020a57600080fd5b5061018f610219366004613d51565b610429565b34801561022a57600080fd5b506101e6610239366004614027565b610436565b34801561024a57600080fd5b5061025e610259366004614040565b610482565b005b34801561026c57600080fd5b5061025e6105c6565b34801561028157600080fd5b50610295610290366004614070565b61062c565b60405161019c9190614138565b3480156102ae57600080fd5b5061025e6102bd366004613d51565b61085c565b3480156102ce57600080fd5b506000546001600160a01b03166101e6565b3480156102ec57600080fd5b5061018f610937565b34801561030157600080fd5b506101b8610310366004613d51565b610a84565b34801561032157600080fd5b5061025e610330366004614040565b610b22565b6101b86103433660046141cf565b610c56565b34801561035457600080fd5b5061025e610363366004614027565b610cad565b61025e61037636600461423b565b610d80565b34801561038757600080fd5b50610390610e6c565b60405161019c91906142e1565b3480156103a957600080fd5b5061025e6103b836600461432e565b611243565b3480156103c957600080fd5b5061025e6103d8366004613d51565b6112b6565b3480156103e957600080fd5b506102956103f836600461436f565b611398565b606061040a82600061157c565b92915050565b600061041f8686868686611a34565b9695505050505050565b606061040a82600161157c565b600061044182611ac8565b610477576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61040a600283611ad5565b6000546001600160a01b031633146104e15760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b6001600160a01b038116610521576040517f5920be2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61052a82611ac8565b610560576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061056d600284611ad5565b905061057b60028484611ae1565b50604080516001600160a01b0380841682528416602082015284917fbe59b1ad7b24549601b98854029a8be9cd632ee55e4472692aa2542e668496e0910160405180910390a2505050565b6000546001600160a01b031633146106205760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b61062a6000611aff565b565b6106706040518060a0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160008152602001606081525090565b60008060006106828660000151611b67565b919450925090506001600160a01b03831661069f5750505061040a565b6000856001600160a01b0316846001600160a01b0316148061076f57506001600160a01b03861673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14801561076f5750600160009054906101000a90046001600160a01b03166001600160a01b0316633fc8cef36040518163ffffffff1660e01b8152600401602060405180830381865afa158015610736573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061075a91906143c8565b6001600160a01b0316846001600160a01b0316145b159050600061078483868a6020015185611cd2565b90508060000361079857505050505061040a565b6040805180820182528581526001600160a01b038781166020830190815260015493517fe6b00009000000000000000000000000000000000000000000000000000000008152835160048201529051821660248201528a82166044820152606481018590529192169063e6b0000990608401600060405180830381865afa158015610827573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261084f9190810190614415565b9998505050505050505050565b6000546001600160a01b031633146108b65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b600154604080516001600160a01b03928316815291831660208301527f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c68910160405180910390a1600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091179055565b606060006109456002611d89565b905060008167ffffffffffffffff81111561096257610962613e5b565b60405190808252806020026020018201604052801561099557816020015b60608152602001906001900390816109805790505b5090506000805b83811015610a715760006109b1600283611d94565b915050806001600160a01b0316639c1d060e6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156109f2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610a1a91908101906144f9565b848381518110610a2c57610a2c614608565b6020026020010181905250838281518110610a4957610a49614608565b60200260200101515183610a5d9190614666565b92505080610a6a90614679565b905061099c565b50610a7c8282611db0565b935050505090565b600080610a916002611d89565b905060005b81811015610ae457600080610aac600284611d94565b91509150856001600160a01b0316816001600160a01b031603610ad157509250610ae4565b505080610add90614679565b9050610a96565b5081610b1c576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b6000546001600160a01b03163314610b7c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b811580610b9057506001600160a01b038116155b15610bc7576040517f5920be2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610bd082611ac8565b15610c07576040517f4b42265600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610c1360028383611ae1565b506040516001600160a01b038216815282907fc92d33ac2d951a5a8265420d37e1664f111f74de9207f89f4c772142ec3aa5e39060200160405180910390a25050565b6000610c6b82516001600160a01b0316151590565b610ca1576040517fb50001b400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61041f85858585611f0a565b6000546001600160a01b03163314610d075760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b610d1081611ac8565b610d46576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610d51600282612087565b5060405181907f594a6e72239daa84da65d4bbeb00fa0ccb8c579b2fd6b5601c82baf0614894cc90600090a250565b6000610d8b86610436565b9050610da083516001600160a01b0316151590565b15610dbb57610db130868686611f0a565b9095509350610dc9565b610dc6308686612093565b93505b600063436f3aa560e01b8989888887604051602401610dec959493929190614693565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091529050610e606001600160a01b03831682612278565b50505050505050505050565b60606000600160009054906101000a90046001600160a01b03166001600160a01b031663c5c63e656040518163ffffffff1660e01b8152600401600060405180830381865afa158015610ec3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610eeb91908101906146e0565b9050600081516001610efd9190614666565b67ffffffffffffffff811115610f1557610f15613e5b565b604051908082528060200260200182016040528015610f4857816020015b6060815260200190600190039081610f335790505b5090506000610f5d610f58610937565b61229d565b82845181518110610f7057610f70614608565b602002602001018190525081835181518110610f8e57610f8e614608565b60200260200101515181610fa29190614666565b905060005b8351811015611184576000848281518110610fc457610fc4614608565b6020026020010151905080604001515167ffffffffffffffff811115610fec57610fec613e5b565b604051908082528060200260200182016040528015611015578160200160208202803683370190505b5084838151811061102857611028614608565b6020026020010181905250600061106682602001518688518151811061105057611050614608565b602002602001015161234990919063ffffffff16565b905060005b826040015151811015611135578260400151818151811061108e5761108e614608565b6020026020010151602001518685815181106110ac576110ac614608565b602002602001015182815181106110c5576110c5614608565b60200260200101906001600160a01b031690816001600160a01b03168152505081611125576111228360400151828151811061110357611103614608565b6020026020010151602001518789518151811061105057611050614608565b91505b61112e81614679565b905061106b565b508061115e5784838151811061114d5761114d614608565b602002602001016060815250611171565b60408201515161116e9085614666565b93505b50508061117d90614679565b9050610fa7565b50611197611192838361239b565b6124a0565b935061121a600160009054906101000a90046001600160a01b03166001600160a01b0316633fc8cef36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111ef573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121391906143c8565b8590612349565b1561123d57610a7c8473eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee61261c565b50505090565b6000546001600160a01b0316331461129d5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b6112b16001600160a01b0384168383612719565b505050565b6000546001600160a01b031633146113105760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b6001600160a01b03811661138c5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016104d8565b61139581611aff565b50565b6113dc6040518060a0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160008152602001606081525090565b6000806113e885611b67565b919350909150506001600160a01b038216611404575050611575565b6000604051806040016040528061141a60001990565b81526001600160a01b038981166020928301526001546040517fe6b00009000000000000000000000000000000000000000000000000000000008152845160048201529284015182166024840152868216604484015260648301899052929350600092169063e6b0000990608401600060405180830381865afa1580156114a5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114cd9190810190614415565b6040517f04b1ac290000000000000000000000000000000000000000000000000000000081526001600160a01b0386811660048301529192506000918516906304b1ac2990602401602060405180830381865afa158015611532573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115569190614882565b9050808260400151111561156e575050505050611575565b5093505050505b9392505050565b6060600061158a6002611d89565b905060008167ffffffffffffffff8111156115a7576115a7613e5b565b6040519080825280602002602001820160405280156115da57816020015b60608152602001906001900390816115c55790505b5090506000805b83811015611a295760006115f6600283611d94565b9150506000816001600160a01b0316639c1d060e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611639573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261166191908101906144f9565b9050600080825167ffffffffffffffff81111561168057611680613e5b565b6040519080825280602002602001820160405280156116a9578160200160208202803683370190505b50905060005b83518110156118ed5760008b611797576040518060400160405280876001600160a01b03166398b575058886815181106116eb576116eb614608565b6020026020010151602001516040518263ffffffff1660e01b815260040161172291906001600160a01b0391909116815260200190565b602060405180830381865afa15801561173f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117639190614882565b815260200186848151811061177a5761177a614608565b6020026020010151602001516001600160a01b03168152506117be565b60405180604001604052806117ab60001990565b81526020018e6001600160a01b03168152505b905060008c6117cd578d6117ec565b8583815181106117df576117df614608565b6020026020010151602001515b6001546040517f285078fc0000000000000000000000000000000000000000000000000000000081528451600482015260208501516001600160a01b039081166024830152808416604483015292935091169063285078fc90606401602060405180830381865afa158015611865573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611889919061489b565b84848151811061189b5761189b614608565b6020026020010190151590811515815250508383815181106118bf576118bf614608565b6020026020010151156118da57846118d681614679565b9550505b5050806118e690614679565b90506116af565b508167ffffffffffffffff81111561190757611907613e5b565b60405190808252806020026020018201604052801561194d57816020015b6040805180820190915260608152600060208201528152602001906001900390816119255790505b5087868151811061196057611960614608565b60209081029190910101526119758287614666565b95506000805b8451811015611a125782818151811061199657611996614608565b602002602001015115611a02578481815181106119b5576119b5614608565b60200260200101518988815181106119cf576119cf614608565b602002602001015183815181106119e8576119e8614608565b602002602001018190525081806119fe90614679565b9250505b611a0b81614679565b905061197b565b50505050505080611a2290614679565b90506115e1565b5061041f8282611db0565b600080611a428685856128c7565b9050611a50868686846129b2565b95506000611a5f878684612a3b565b9050611a6d87878385612a81565b92507fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03861601611aa957611aa98184612c41565b611abd6001600160a01b0386168985612cb8565b505095945050505050565b600061040a600283612dba565b60006115758383612dc6565b6000611af784846001600160a01b038516612e36565b949350505050565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600080600080611b776002611d89565b905060005b81811015611cc9576000611b91600283611d94565b6040517fa5bc29c20000000000000000000000000000000000000000000000000000000081529092506001600160a01b038316915063a5bc29c290611bda908a906004016148b6565b602060405180830381865afa158015611bf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c1b91906143c8565b95506001600160a01b03861615611cb8576040517f98b575050000000000000000000000000000000000000000000000000000000081526001600160a01b0387811660048301528216906398b5750590602401602060405180830381865afa158015611c8b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611caf9190614882565b94509250611cc9565b50611cc281614679565b9050611b7c565b50509193909250565b6040517f0d25aafe0000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301526024820184905282151560448301526000918291871690630d25aafe90606401602060405180830381865afa158015611d45573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d699190614882565b905083811015611d8057611d7d81856148c9565b91505b50949350505050565b600061040a82612e53565b6000808080611da38686612e5e565b9097909650945050505050565b60608167ffffffffffffffff811115611dcb57611dcb613e5b565b604051908082528060200260200182016040528015611e1157816020015b604080518082019091526060815260006020820152815260200190600190039081611de95790505b5090506000805b8451811015611ec65760005b858281518110611e3657611e36614608565b602002602001015151811015611eb557858281518110611e5857611e58614608565b60200260200101518181518110611e7157611e71614608565b6020026020010151848481518110611e8b57611e8b614608565b60200260200101819052508280611ea190614679565b93505080611eae90614679565b9050611e24565b50611ebf81614679565b9050611e18565b50828114611f03576040517f3726b986000000000000000000000000000000000000000000000000000000008152600481018290526024016104d8565b5092915050565b6000808260600151421115611f4b576040517f559895a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8251611f58908686612093565b602084015184519195509250306001600160a01b03821603611f8c57611f85878787868860800151611a34565b915061203f565b611f9f6001600160a01b03841688612e89565b9150806001600160a01b03166324a98f1134898989888a608001516040518763ffffffff1660e01b8152600401611fda9594939291906148dc565b60206040518083038185885af1158015611ff8573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061201d9190614882565b50816120326001600160a01b03851689612e89565b61203c91906148c9565b91505b836040015182101561207d576040517f42301c2300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5094509492505050565b60006115758383612f56565b6000346000036121e0576120af836001600160a01b0316612f73565b6040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301528416906370a0823190602401602060405180830381865afa15801561210e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121329190614882565b90506121496001600160a01b038416338685613019565b6040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301528291908516906370a0823190602401602060405180830381865afa1580156121ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121cf9190614882565b6121d991906148c9565b9050611575565b6001600160a01b03831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14612236576040517f2eac7efb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b34821461226f576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50349392505050565b60606115758383604051806060016040528060278152602001614af36027913961306a565b6060815167ffffffffffffffff8111156122b9576122b9613e5b565b6040519080825280602002602001820160405280156122e2578160200160208202803683370190505b50905060005b8251811015610b1c5782818151811061230357612303614608565b60200260200101516020015182828151811061232157612321614608565b6001600160a01b039092166020928302919091019091015261234281614679565b90506122e8565b6000805b8351811015611f035783818151811061236857612368614608565b60200260200101516001600160a01b0316836001600160a01b031614915081611f035761239481614679565b905061234d565b60608167ffffffffffffffff8111156123b6576123b6613e5b565b6040519080825280602002602001820160405280156123df578160200160208202803683370190505b5090506000805b8451811015611ec65760005b85828151811061240457612404614608565b60200260200101515181101561248f5785828151811061242657612426614608565b6020026020010151818151811061243f5761243f614608565b602002602001015184848151811061245957612459614608565b6001600160a01b03909216602092830291909101909101528261247b81614679565b9350508061248890614679565b90506123f2565b5061249981614679565b90506123e6565b60606000825167ffffffffffffffff8111156124be576124be613e5b565b6040519080825280602002602001820160405280156124e7578160200160208202803683370190505b5090506000805b845181101561256d57600085828151811061250b5761250b614608565b6020026020010151905061251f8482612349565b61255c578084848151811061253657612536614608565b6001600160a01b03909216602092830291909101909101528261255881614679565b9350505b5061256681614679565b90506124ee565b508067ffffffffffffffff81111561258757612587613e5b565b6040519080825280602002602001820160405280156125b0578160200160208202803683370190505b50925060005b81811015612614578281815181106125d0576125d0614608565b60200260200101518482815181106125ea576125ea614608565b6001600160a01b03909216602092830291909101909101528061260c81614679565b9150506125b6565b505050919050565b60608251600161262c9190614666565b67ffffffffffffffff81111561264457612644613e5b565b60405190808252806020026020018201604052801561266d578160200160208202803683370190505b50905060005b83518110156126d25783818151811061268e5761268e614608565b60200260200101518282815181106126a8576126a8614608565b6001600160a01b0390921660209283029190910190910152806126ca81614679565b915050612673565b508181600183516126e391906148c9565b815181106126f3576126f3614608565b60200260200101906001600160a01b031690816001600160a01b03168152505092915050565b8015806127ac57506040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015612786573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127aa9190614882565b155b61281e5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e63650000000000000000000060648201526084016104d8565b6040516001600160a01b0383166024820152604481018290526112b19084907f095ea7b300000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152613154565b604080516080810182526000808252602082018190529181018290526060810191909152826001600160a01b0316846001600160a01b031603612936576040517f0b839a1f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8180602001905181019061294a9190614927565b60208101519091506001600160a01b031615801561297b5750600381516003811115612978576129786149ac565b14155b15611575576040517f76ecffc000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03861601612a01576129f083836001613239565b90506129fc81856132fe565b611af7565b50833415611af7576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03841601612a79576121d984836000613239565b509092915050565b6000600382516003811115612a9857612a986149ac565b03612aa4575082611af7565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b038416906370a0823190602401602060405180830381865afa158015612b01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b259190614882565b6020830151909150612b42906001600160a01b038716908661338f565b600082516003811115612b5757612b576149ac565b03612b7157612b6c8260200151838686613473565b612bab565b600182516003811115612b8657612b866149ac565b03612b9b57612b6c82602001518386866135f8565b612bab8260200151838686613762565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015281906001600160a01b038516906370a0823190602401602060405180830381865afa158015612c0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c2e9190614882565b612c3891906148c9565b95945050505050565b6040517f2e1a7d4d000000000000000000000000000000000000000000000000000000008152600481018290526001600160a01b03831690632e1a7d4d90602401600060405180830381600087803b158015612c9c57600080fd5b505af1158015612cb0573d6000803e3d6000fd5b505050505050565b306001600160a01b03831603612ccd57505050565b7fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03841601612da6576000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114612d4a576040519150601f19603f3d011682016040523d82523d6000602084013e612d4f565b606091505b5050905080612da05760405162461bcd60e51b815260206004820152601360248201527f455448207472616e73666572206661696c65640000000000000000000000000060448201526064016104d8565b50505050565b6112b16001600160a01b0384168383613895565b600061157583836138de565b600081815260028301602052604081205480151580612dea5750612dea84846138de565b6115755760405162461bcd60e51b815260206004820152601e60248201527f456e756d657261626c654d61703a206e6f6e6578697374656e74206b6579000060448201526064016104d8565b60008281526002840160205260408120829055611af784846138ea565b600061040a826138f6565b60008080612e6c8585613900565b600081815260029690960160205260409095205494959350505050565b60007fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03841601612ecc57506001600160a01b0381163161040a565b6040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0383811660048301528416906370a0823190602401602060405180830381865afa158015612f2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f4f9190614882565b905061040a565b60008181526002830160205260408120819055611575838361390c565b7fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03821601612fd5576040517f7f523fe800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001600160a01b03163b600003611395576040517f7f523fe800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516001600160a01b0380851660248301528316604482015260648101829052612da09085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401612863565b60606001600160a01b0384163b6130e95760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016104d8565b600080856001600160a01b03168560405161310491906149db565b600060405180830381855af49150503d806000811461313f576040519150601f19603f3d011682016040523d82523d6000602084013e613144565b606091505b509150915061041f828286613918565b60006131a9826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166139519092919063ffffffff16565b8051909150156112b157808060200190518101906131c7919061489b565b6112b15760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016104d8565b6000600383516003811115613250576132506149ac565b0361325c575082611575565b82602001516001600160a01b03166382b866008361327e578460600151613284565b84604001515b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815260ff9091166004820152602401602060405180830381865afa1580156132da573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611af791906143c8565b348114613337576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561337257600080fd5b505af1158015613386573d6000803e3d6000fd5b50505050505050565b6040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa1580156133f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061341d9190614882565b6134279190614666565b6040516001600160a01b038516602482015260448101829052909150612da09085907f095ea7b30000000000000000000000000000000000000000000000000000000090606401612863565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff90911660048201526001600160a01b0382811691908616906382b8660090602401602060405180830381865afa1580156134de573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061350291906143c8565b6001600160a01b031614613542576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080840151606085015191517f9169558600000000000000000000000000000000000000000000000000000000815260ff918216600482015291166024820152604481018390526000606482015260001960848201526001600160a01b0385169063916955869060a4015b6020604051808303816000875af11580156135cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135f19190614882565b5050505050565b600061360385613960565b9050600061361086613a00565b9050826001600160a01b0316816001600160a01b03161461365d576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008267ffffffffffffffff81111561367857613678613e5b565b6040519080825280602002602001820160405280156136a1578160200160208202803683370190505b5090508481876040015160ff16815181106136be576136be614608565b60209081029190910101526040517f4d49e87d0000000000000000000000000000000000000000000000000000000081526001600160a01b03881690634d49e87d90613715908490600090600019906004016149f7565b6020604051808303816000875af1158015613734573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137589190614882565b5050505050505050565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff90911660048201526001600160a01b0382811691908616906382b8660090602401602060405180830381865afa1580156137cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137f191906143c8565b6001600160a01b031614613831576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60608301516040517f3e3a15600000000000000000000000000000000000000000000000000000000081526004810184905260ff90911660248201526000604482015260001960648201526001600160a01b03851690633e3a1560906084016135ae565b6040516001600160a01b0383166024820152604481018290526112b19084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401612863565b60006115758383613a70565b60006115758383613a88565b600061040a825490565b60006115758383613ad7565b60006115758383613b01565b60608315613927575081611575565b8251156139375782518084602001fd5b8160405162461bcd60e51b81526004016104d891906148b6565b6060611af78484600085613bf4565b6000805b6040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff821660048201526001600160a01b038416906382b8660090602401602060405180830381865afa9250505080156139e0575060408051601f3d908101601f191682019092526139dd918101906143c8565b60015b6139ef578060ff169150610b1c565b506139f981614a44565b9050613964565b6000816001600160a01b0316635fd65f0f6040518163ffffffff1660e01b815260040160e060405180830381865afa158015613a40573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a649190614a63565b98975050505050505050565b60008181526001830160205260408120541515611575565b6000818152600183016020526040812054613acf5750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561040a565b50600061040a565b6000826000018281548110613aee57613aee614608565b9060005260206000200154905092915050565b60008181526001830160205260408120548015613bea576000613b256001836148c9565b8554909150600090613b39906001906148c9565b9050818114613b9e576000866000018281548110613b5957613b59614608565b9060005260206000200154905080876000018481548110613b7c57613b7c614608565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613baf57613baf614ac3565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061040a565b600091505061040a565b606082471015613c6c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016104d8565b6001600160a01b0385163b613cc35760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016104d8565b600080866001600160a01b03168587604051613cdf91906149db565b60006040518083038185875af1925050503d8060008114613d1c576040519150601f19603f3d011682016040523d82523d6000602084013e613d21565b606091505b5091509150613d31828286613918565b979650505050505050565b6001600160a01b038116811461139557600080fd5b600060208284031215613d6357600080fd5b813561157581613d3c565b60005b83811015613d89578181015183820152602001613d71565b50506000910152565b60008151808452613daa816020860160208601613d6e565b601f01601f19169290920160200192915050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015613e4d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089840301855281518051878552613e2788860182613d92565b918901516001600160a01b03169489019490945294870194925090860190600101613de5565b509098975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715613ead57613ead613e5b565b60405290565b60405160a0810167ffffffffffffffff81118282101715613ead57613ead613e5b565b6040516060810167ffffffffffffffff81118282101715613ead57613ead613e5b565b604051601f8201601f1916810167ffffffffffffffff81118282101715613f2257613f22613e5b565b604052919050565b600067ffffffffffffffff821115613f4457613f44613e5b565b50601f01601f191660200190565b600082601f830112613f6357600080fd5b8135613f76613f7182613f2a565b613ef9565b818152846020838601011115613f8b57600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080600060a08688031215613fc057600080fd5b8535613fcb81613d3c565b94506020860135613fdb81613d3c565b9350604086013592506060860135613ff281613d3c565b9150608086013567ffffffffffffffff81111561400e57600080fd5b61401a88828901613f52565b9150509295509295909350565b60006020828403121561403957600080fd5b5035919050565b6000806040838503121561405357600080fd5b82359150602083013561406581613d3c565b809150509250929050565b6000806040838503121561408357600080fd5b823567ffffffffffffffff8082111561409b57600080fd5b90840190604082870312156140af57600080fd5b6140b7613e8a565b8235828111156140c657600080fd5b6140d288828601613f52565b8252506020928301358382015293505083013561406581613d3c565b60006001600160a01b03808351168452806020840151166020850152506040820151604084015260608201516060840152608082015160a06080850152611af760a0850182613d92565b60208152600061157560208301846140ee565b600060a0828403121561415d57600080fd5b614165613eb3565b9050813561417281613d3c565b8152602082013561418281613d3c565b806020830152506040820135604082015260608201356060820152608082013567ffffffffffffffff8111156141b757600080fd5b6141c384828501613f52565b60808301525092915050565b600080600080608085870312156141e557600080fd5b84356141f081613d3c565b9350602085013561420081613d3c565b925060408501359150606085013567ffffffffffffffff81111561422357600080fd5b61422f8782880161414b565b91505092959194509250565b600080600080600080600060e0888a03121561425657600080fd5b873561426181613d3c565b96506020880135955060408801359450606088013561427f81613d3c565b93506080880135925060a088013567ffffffffffffffff808211156142a357600080fd5b6142af8b838c0161414b565b935060c08a01359150808211156142c557600080fd5b506142d28a828b0161414b565b91505092959891949750929550565b6020808252825182820181905260009190848201906040850190845b818110156143225783516001600160a01b0316835292840192918401916001016142fd565b50909695505050505050565b60008060006060848603121561434357600080fd5b833561434e81613d3c565b9250602084013561435e81613d3c565b929592945050506040919091013590565b60008060006060848603121561438457600080fd5b833561438f81613d3c565b9250602084013567ffffffffffffffff8111156143ab57600080fd5b6143b786828701613f52565b925050604084013590509250925092565b6000602082840312156143da57600080fd5b815161157581613d3c565b60006143f3613f7184613f2a565b905082815283838301111561440757600080fd5b611575836020830184613d6e565b60006020828403121561442757600080fd5b815167ffffffffffffffff8082111561443f57600080fd5b9083019060a0828603121561445357600080fd5b61445b613eb3565b825161446681613d3c565b8152602083015161447681613d3c565b8060208301525060408301516040820152606083015160608201526080830151828111156144a357600080fd5b80840193505085601f8401126144b857600080fd5b6144c7868451602086016143e5565b608082015295945050505050565b600067ffffffffffffffff8211156144ef576144ef613e5b565b5060051b60200190565b6000602080838503121561450c57600080fd5b825167ffffffffffffffff8082111561452457600080fd5b818501915085601f83011261453857600080fd5b8151614546613f71826144d5565b81815260059190911b8301840190848101908883111561456557600080fd5b8585015b838110156145fb578051858111156145815760008081fd5b86016040818c03601f19018113156145995760008081fd5b6145a1613e8a565b89830151888111156145b35760008081fd5b8301603f81018e136145c55760008081fd5b6145d58e8c8301518584016143e5565b82525091810151916145e683613d3c565b808a0192909252508352918601918601614569565b5098975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561040a5761040a614637565b6000600019820361468c5761468c614637565b5060010190565b60006001600160a01b03808816835286602084015280861660408401525083606083015260a06080830152613d3160a08301846140ee565b805180151581146146db57600080fd5b919050565b6000602082840312156146f257600080fd5b815167ffffffffffffffff8082111561470a57600080fd5b818401915084601f83011261471e57600080fd5b815161472c613f71826144d5565b8082825260208201915060208360051b86010192508783111561474e57600080fd5b602085015b838110156148765780518581111561476a57600080fd5b86016060818b03601f1901121561478057600080fd5b614788613ed6565b602082015161479681613d3c565b815260408201516147a681613d3c565b60208201526060820151878111156147bd57600080fd5b8083019250508a603f8301126147d257600080fd5b60208201516147e3613f71826144d5565b81815260069190911b83016040019060208101908d83111561480457600080fd5b6040850194505b82851015614860576040858f03121561482357600080fd5b61482b613e8a565b614834866146cb565b8152602086015161484481613d3c565b806020830152508083525060208201915060408501945061480b565b6040840152505084525060209283019201614753565b50979650505050505050565b60006020828403121561489457600080fd5b5051919050565b6000602082840312156148ad57600080fd5b611575826146cb565b6020815260006115756020830184613d92565b8181038181111561040a5761040a614637565b60006001600160a01b038088168352808716602084015285604084015280851660608401525060a06080830152613d3160a0830184613d92565b805160ff811681146146db57600080fd5b60006080828403121561493957600080fd5b6040516080810181811067ffffffffffffffff8211171561495c5761495c613e5b565b60405282516004811061496e57600080fd5b8152602083015161497e81613d3c565b602082015261498f60408401614916565b60408201526149a060608401614916565b60608201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600082516149ed818460208701613d6e565b9190910192915050565b606080825284519082018190526000906020906080840190828801845b82811015614a3057815184529284019290840190600101614a14565b505050908301949094525060400152919050565b600060ff821660ff8103614a5a57614a5a614637565b60010192915050565b600080600080600080600060e0888a031215614a7e57600080fd5b875196506020880151955060408801519450606088015193506080880151925060a0880151915060c0880151614ab381613d3c565b8091505092959891949750929550565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220fa6a143f537a228bb78bd144a6be8297f48c82927bfb46f5fb3a9a4390edc38f64736f6c63430008110033","runtime-code":"0x6080604052600436106101635760003560e01c80639c1d060e116100c0578063c95fafd211610074578063da46098c11610059578063da46098c1461039d578063f2fde38b146103bd578063f533941d146103dd57600080fd5b8063c95fafd214610368578063d3c7c2c71461037b57600080fd5b8063b3bce952116100a5578063b3bce95214610315578063b5d1cdd414610335578063b68e43021461034857600080fd5b80639c1d060e146102e05780639f2671fa146102f557600080fd5b806370a1cdc9116101175780637de31c74116100fc5780637de31c7414610275578063804b3dff146102a25780638da5cb5b146102c257600080fd5b806370a1cdc91461023e578063715018a61461026057600080fd5b806334474c8c1161014857806334474c8c146101c65780633e811a5c146101fe57806353e2e8e71461021e57600080fd5b80631d04879b1461016f57806324a98f11146101a557600080fd5b3661016a57005b600080fd5b34801561017b57600080fd5b5061018f61018a366004613d51565b6103fd565b60405161019c9190613dbe565b60405180910390f35b6101b86101b3366004613fa8565b610410565b60405190815260200161019c565b3480156101d257600080fd5b506001546101e6906001600160a01b031681565b6040516001600160a01b03909116815260200161019c565b34801561020a57600080fd5b5061018f610219366004613d51565b610429565b34801561022a57600080fd5b506101e6610239366004614027565b610436565b34801561024a57600080fd5b5061025e610259366004614040565b610482565b005b34801561026c57600080fd5b5061025e6105c6565b34801561028157600080fd5b50610295610290366004614070565b61062c565b60405161019c9190614138565b3480156102ae57600080fd5b5061025e6102bd366004613d51565b61085c565b3480156102ce57600080fd5b506000546001600160a01b03166101e6565b3480156102ec57600080fd5b5061018f610937565b34801561030157600080fd5b506101b8610310366004613d51565b610a84565b34801561032157600080fd5b5061025e610330366004614040565b610b22565b6101b86103433660046141cf565b610c56565b34801561035457600080fd5b5061025e610363366004614027565b610cad565b61025e61037636600461423b565b610d80565b34801561038757600080fd5b50610390610e6c565b60405161019c91906142e1565b3480156103a957600080fd5b5061025e6103b836600461432e565b611243565b3480156103c957600080fd5b5061025e6103d8366004613d51565b6112b6565b3480156103e957600080fd5b506102956103f836600461436f565b611398565b606061040a82600061157c565b92915050565b600061041f8686868686611a34565b9695505050505050565b606061040a82600161157c565b600061044182611ac8565b610477576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61040a600283611ad5565b6000546001600160a01b031633146104e15760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b6001600160a01b038116610521576040517f5920be2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61052a82611ac8565b610560576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061056d600284611ad5565b905061057b60028484611ae1565b50604080516001600160a01b0380841682528416602082015284917fbe59b1ad7b24549601b98854029a8be9cd632ee55e4472692aa2542e668496e0910160405180910390a2505050565b6000546001600160a01b031633146106205760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b61062a6000611aff565b565b6106706040518060a0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160008152602001606081525090565b60008060006106828660000151611b67565b919450925090506001600160a01b03831661069f5750505061040a565b6000856001600160a01b0316846001600160a01b0316148061076f57506001600160a01b03861673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14801561076f5750600160009054906101000a90046001600160a01b03166001600160a01b0316633fc8cef36040518163ffffffff1660e01b8152600401602060405180830381865afa158015610736573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061075a91906143c8565b6001600160a01b0316846001600160a01b0316145b159050600061078483868a6020015185611cd2565b90508060000361079857505050505061040a565b6040805180820182528581526001600160a01b038781166020830190815260015493517fe6b00009000000000000000000000000000000000000000000000000000000008152835160048201529051821660248201528a82166044820152606481018590529192169063e6b0000990608401600060405180830381865afa158015610827573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261084f9190810190614415565b9998505050505050505050565b6000546001600160a01b031633146108b65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b600154604080516001600160a01b03928316815291831660208301527f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c68910160405180910390a1600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091179055565b606060006109456002611d89565b905060008167ffffffffffffffff81111561096257610962613e5b565b60405190808252806020026020018201604052801561099557816020015b60608152602001906001900390816109805790505b5090506000805b83811015610a715760006109b1600283611d94565b915050806001600160a01b0316639c1d060e6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156109f2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610a1a91908101906144f9565b848381518110610a2c57610a2c614608565b6020026020010181905250838281518110610a4957610a49614608565b60200260200101515183610a5d9190614666565b92505080610a6a90614679565b905061099c565b50610a7c8282611db0565b935050505090565b600080610a916002611d89565b905060005b81811015610ae457600080610aac600284611d94565b91509150856001600160a01b0316816001600160a01b031603610ad157509250610ae4565b505080610add90614679565b9050610a96565b5081610b1c576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b6000546001600160a01b03163314610b7c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b811580610b9057506001600160a01b038116155b15610bc7576040517f5920be2700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610bd082611ac8565b15610c07576040517f4b42265600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610c1360028383611ae1565b506040516001600160a01b038216815282907fc92d33ac2d951a5a8265420d37e1664f111f74de9207f89f4c772142ec3aa5e39060200160405180910390a25050565b6000610c6b82516001600160a01b0316151590565b610ca1576040517fb50001b400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61041f85858585611f0a565b6000546001600160a01b03163314610d075760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b610d1081611ac8565b610d46576040517f45a6d1a200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610d51600282612087565b5060405181907f594a6e72239daa84da65d4bbeb00fa0ccb8c579b2fd6b5601c82baf0614894cc90600090a250565b6000610d8b86610436565b9050610da083516001600160a01b0316151590565b15610dbb57610db130868686611f0a565b9095509350610dc9565b610dc6308686612093565b93505b600063436f3aa560e01b8989888887604051602401610dec959493929190614693565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091529050610e606001600160a01b03831682612278565b50505050505050505050565b60606000600160009054906101000a90046001600160a01b03166001600160a01b031663c5c63e656040518163ffffffff1660e01b8152600401600060405180830381865afa158015610ec3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610eeb91908101906146e0565b9050600081516001610efd9190614666565b67ffffffffffffffff811115610f1557610f15613e5b565b604051908082528060200260200182016040528015610f4857816020015b6060815260200190600190039081610f335790505b5090506000610f5d610f58610937565b61229d565b82845181518110610f7057610f70614608565b602002602001018190525081835181518110610f8e57610f8e614608565b60200260200101515181610fa29190614666565b905060005b8351811015611184576000848281518110610fc457610fc4614608565b6020026020010151905080604001515167ffffffffffffffff811115610fec57610fec613e5b565b604051908082528060200260200182016040528015611015578160200160208202803683370190505b5084838151811061102857611028614608565b6020026020010181905250600061106682602001518688518151811061105057611050614608565b602002602001015161234990919063ffffffff16565b905060005b826040015151811015611135578260400151818151811061108e5761108e614608565b6020026020010151602001518685815181106110ac576110ac614608565b602002602001015182815181106110c5576110c5614608565b60200260200101906001600160a01b031690816001600160a01b03168152505081611125576111228360400151828151811061110357611103614608565b6020026020010151602001518789518151811061105057611050614608565b91505b61112e81614679565b905061106b565b508061115e5784838151811061114d5761114d614608565b602002602001016060815250611171565b60408201515161116e9085614666565b93505b50508061117d90614679565b9050610fa7565b50611197611192838361239b565b6124a0565b935061121a600160009054906101000a90046001600160a01b03166001600160a01b0316633fc8cef36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111ef573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121391906143c8565b8590612349565b1561123d57610a7c8473eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee61261c565b50505090565b6000546001600160a01b0316331461129d5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b6112b16001600160a01b0384168383612719565b505050565b6000546001600160a01b031633146113105760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016104d8565b6001600160a01b03811661138c5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016104d8565b61139581611aff565b50565b6113dc6040518060a0016040528060006001600160a01b0316815260200160006001600160a01b031681526020016000815260200160008152602001606081525090565b6000806113e885611b67565b919350909150506001600160a01b038216611404575050611575565b6000604051806040016040528061141a60001990565b81526001600160a01b038981166020928301526001546040517fe6b00009000000000000000000000000000000000000000000000000000000008152845160048201529284015182166024840152868216604484015260648301899052929350600092169063e6b0000990608401600060405180830381865afa1580156114a5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114cd9190810190614415565b6040517f04b1ac290000000000000000000000000000000000000000000000000000000081526001600160a01b0386811660048301529192506000918516906304b1ac2990602401602060405180830381865afa158015611532573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115569190614882565b9050808260400151111561156e575050505050611575565b5093505050505b9392505050565b6060600061158a6002611d89565b905060008167ffffffffffffffff8111156115a7576115a7613e5b565b6040519080825280602002602001820160405280156115da57816020015b60608152602001906001900390816115c55790505b5090506000805b83811015611a295760006115f6600283611d94565b9150506000816001600160a01b0316639c1d060e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611639573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261166191908101906144f9565b9050600080825167ffffffffffffffff81111561168057611680613e5b565b6040519080825280602002602001820160405280156116a9578160200160208202803683370190505b50905060005b83518110156118ed5760008b611797576040518060400160405280876001600160a01b03166398b575058886815181106116eb576116eb614608565b6020026020010151602001516040518263ffffffff1660e01b815260040161172291906001600160a01b0391909116815260200190565b602060405180830381865afa15801561173f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117639190614882565b815260200186848151811061177a5761177a614608565b6020026020010151602001516001600160a01b03168152506117be565b60405180604001604052806117ab60001990565b81526020018e6001600160a01b03168152505b905060008c6117cd578d6117ec565b8583815181106117df576117df614608565b6020026020010151602001515b6001546040517f285078fc0000000000000000000000000000000000000000000000000000000081528451600482015260208501516001600160a01b039081166024830152808416604483015292935091169063285078fc90606401602060405180830381865afa158015611865573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611889919061489b565b84848151811061189b5761189b614608565b6020026020010190151590811515815250508383815181106118bf576118bf614608565b6020026020010151156118da57846118d681614679565b9550505b5050806118e690614679565b90506116af565b508167ffffffffffffffff81111561190757611907613e5b565b60405190808252806020026020018201604052801561194d57816020015b6040805180820190915260608152600060208201528152602001906001900390816119255790505b5087868151811061196057611960614608565b60209081029190910101526119758287614666565b95506000805b8451811015611a125782818151811061199657611996614608565b602002602001015115611a02578481815181106119b5576119b5614608565b60200260200101518988815181106119cf576119cf614608565b602002602001015183815181106119e8576119e8614608565b602002602001018190525081806119fe90614679565b9250505b611a0b81614679565b905061197b565b50505050505080611a2290614679565b90506115e1565b5061041f8282611db0565b600080611a428685856128c7565b9050611a50868686846129b2565b95506000611a5f878684612a3b565b9050611a6d87878385612a81565b92507fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03861601611aa957611aa98184612c41565b611abd6001600160a01b0386168985612cb8565b505095945050505050565b600061040a600283612dba565b60006115758383612dc6565b6000611af784846001600160a01b038516612e36565b949350505050565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600080600080611b776002611d89565b905060005b81811015611cc9576000611b91600283611d94565b6040517fa5bc29c20000000000000000000000000000000000000000000000000000000081529092506001600160a01b038316915063a5bc29c290611bda908a906004016148b6565b602060405180830381865afa158015611bf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c1b91906143c8565b95506001600160a01b03861615611cb8576040517f98b575050000000000000000000000000000000000000000000000000000000081526001600160a01b0387811660048301528216906398b5750590602401602060405180830381865afa158015611c8b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611caf9190614882565b94509250611cc9565b50611cc281614679565b9050611b7c565b50509193909250565b6040517f0d25aafe0000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301526024820184905282151560448301526000918291871690630d25aafe90606401602060405180830381865afa158015611d45573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d699190614882565b905083811015611d8057611d7d81856148c9565b91505b50949350505050565b600061040a82612e53565b6000808080611da38686612e5e565b9097909650945050505050565b60608167ffffffffffffffff811115611dcb57611dcb613e5b565b604051908082528060200260200182016040528015611e1157816020015b604080518082019091526060815260006020820152815260200190600190039081611de95790505b5090506000805b8451811015611ec65760005b858281518110611e3657611e36614608565b602002602001015151811015611eb557858281518110611e5857611e58614608565b60200260200101518181518110611e7157611e71614608565b6020026020010151848481518110611e8b57611e8b614608565b60200260200101819052508280611ea190614679565b93505080611eae90614679565b9050611e24565b50611ebf81614679565b9050611e18565b50828114611f03576040517f3726b986000000000000000000000000000000000000000000000000000000008152600481018290526024016104d8565b5092915050565b6000808260600151421115611f4b576040517f559895a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8251611f58908686612093565b602084015184519195509250306001600160a01b03821603611f8c57611f85878787868860800151611a34565b915061203f565b611f9f6001600160a01b03841688612e89565b9150806001600160a01b03166324a98f1134898989888a608001516040518763ffffffff1660e01b8152600401611fda9594939291906148dc565b60206040518083038185885af1158015611ff8573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061201d9190614882565b50816120326001600160a01b03851689612e89565b61203c91906148c9565b91505b836040015182101561207d576040517f42301c2300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5094509492505050565b60006115758383612f56565b6000346000036121e0576120af836001600160a01b0316612f73565b6040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301528416906370a0823190602401602060405180830381865afa15801561210e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121329190614882565b90506121496001600160a01b038416338685613019565b6040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301528291908516906370a0823190602401602060405180830381865afa1580156121ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121cf9190614882565b6121d991906148c9565b9050611575565b6001600160a01b03831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14612236576040517f2eac7efb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b34821461226f576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50349392505050565b60606115758383604051806060016040528060278152602001614af36027913961306a565b6060815167ffffffffffffffff8111156122b9576122b9613e5b565b6040519080825280602002602001820160405280156122e2578160200160208202803683370190505b50905060005b8251811015610b1c5782818151811061230357612303614608565b60200260200101516020015182828151811061232157612321614608565b6001600160a01b039092166020928302919091019091015261234281614679565b90506122e8565b6000805b8351811015611f035783818151811061236857612368614608565b60200260200101516001600160a01b0316836001600160a01b031614915081611f035761239481614679565b905061234d565b60608167ffffffffffffffff8111156123b6576123b6613e5b565b6040519080825280602002602001820160405280156123df578160200160208202803683370190505b5090506000805b8451811015611ec65760005b85828151811061240457612404614608565b60200260200101515181101561248f5785828151811061242657612426614608565b6020026020010151818151811061243f5761243f614608565b602002602001015184848151811061245957612459614608565b6001600160a01b03909216602092830291909101909101528261247b81614679565b9350508061248890614679565b90506123f2565b5061249981614679565b90506123e6565b60606000825167ffffffffffffffff8111156124be576124be613e5b565b6040519080825280602002602001820160405280156124e7578160200160208202803683370190505b5090506000805b845181101561256d57600085828151811061250b5761250b614608565b6020026020010151905061251f8482612349565b61255c578084848151811061253657612536614608565b6001600160a01b03909216602092830291909101909101528261255881614679565b9350505b5061256681614679565b90506124ee565b508067ffffffffffffffff81111561258757612587613e5b565b6040519080825280602002602001820160405280156125b0578160200160208202803683370190505b50925060005b81811015612614578281815181106125d0576125d0614608565b60200260200101518482815181106125ea576125ea614608565b6001600160a01b03909216602092830291909101909101528061260c81614679565b9150506125b6565b505050919050565b60608251600161262c9190614666565b67ffffffffffffffff81111561264457612644613e5b565b60405190808252806020026020018201604052801561266d578160200160208202803683370190505b50905060005b83518110156126d25783818151811061268e5761268e614608565b60200260200101518282815181106126a8576126a8614608565b6001600160a01b0390921660209283029190910190910152806126ca81614679565b915050612673565b508181600183516126e391906148c9565b815181106126f3576126f3614608565b60200260200101906001600160a01b031690816001600160a01b03168152505092915050565b8015806127ac57506040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015612786573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127aa9190614882565b155b61281e5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e63650000000000000000000060648201526084016104d8565b6040516001600160a01b0383166024820152604481018290526112b19084907f095ea7b300000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152613154565b604080516080810182526000808252602082018190529181018290526060810191909152826001600160a01b0316846001600160a01b031603612936576040517f0b839a1f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8180602001905181019061294a9190614927565b60208101519091506001600160a01b031615801561297b5750600381516003811115612978576129786149ac565b14155b15611575576040517f76ecffc000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03861601612a01576129f083836001613239565b90506129fc81856132fe565b611af7565b50833415611af7576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03841601612a79576121d984836000613239565b509092915050565b6000600382516003811115612a9857612a986149ac565b03612aa4575082611af7565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b038416906370a0823190602401602060405180830381865afa158015612b01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b259190614882565b6020830151909150612b42906001600160a01b038716908661338f565b600082516003811115612b5757612b576149ac565b03612b7157612b6c8260200151838686613473565b612bab565b600182516003811115612b8657612b866149ac565b03612b9b57612b6c82602001518386866135f8565b612bab8260200151838686613762565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015281906001600160a01b038516906370a0823190602401602060405180830381865afa158015612c0a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c2e9190614882565b612c3891906148c9565b95945050505050565b6040517f2e1a7d4d000000000000000000000000000000000000000000000000000000008152600481018290526001600160a01b03831690632e1a7d4d90602401600060405180830381600087803b158015612c9c57600080fd5b505af1158015612cb0573d6000803e3d6000fd5b505050505050565b306001600160a01b03831603612ccd57505050565b7fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03841601612da6576000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114612d4a576040519150601f19603f3d011682016040523d82523d6000602084013e612d4f565b606091505b5050905080612da05760405162461bcd60e51b815260206004820152601360248201527f455448207472616e73666572206661696c65640000000000000000000000000060448201526064016104d8565b50505050565b6112b16001600160a01b0384168383613895565b600061157583836138de565b600081815260028301602052604081205480151580612dea5750612dea84846138de565b6115755760405162461bcd60e51b815260206004820152601e60248201527f456e756d657261626c654d61703a206e6f6e6578697374656e74206b6579000060448201526064016104d8565b60008281526002840160205260408120829055611af784846138ea565b600061040a826138f6565b60008080612e6c8585613900565b600081815260029690960160205260409095205494959350505050565b60007fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03841601612ecc57506001600160a01b0381163161040a565b6040517f70a082310000000000000000000000000000000000000000000000000000000081526001600160a01b0383811660048301528416906370a0823190602401602060405180830381865afa158015612f2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f4f9190614882565b905061040a565b60008181526002830160205260408120819055611575838361390c565b7fffffffffffffffffffffffff11111111111111111111111111111111111111126001600160a01b03821601612fd5576040517f7f523fe800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001600160a01b03163b600003611395576040517f7f523fe800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516001600160a01b0380851660248301528316604482015260648101829052612da09085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401612863565b60606001600160a01b0384163b6130e95760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016104d8565b600080856001600160a01b03168560405161310491906149db565b600060405180830381855af49150503d806000811461313f576040519150601f19603f3d011682016040523d82523d6000602084013e613144565b606091505b509150915061041f828286613918565b60006131a9826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166139519092919063ffffffff16565b8051909150156112b157808060200190518101906131c7919061489b565b6112b15760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016104d8565b6000600383516003811115613250576132506149ac565b0361325c575082611575565b82602001516001600160a01b03166382b866008361327e578460600151613284565b84604001515b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815260ff9091166004820152602401602060405180830381865afa1580156132da573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611af791906143c8565b348114613337576040517f81de0bf300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561337257600080fd5b505af1158015613386573d6000803e3d6000fd5b50505050505050565b6040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b038381166024830152600091839186169063dd62ed3e90604401602060405180830381865afa1580156133f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061341d9190614882565b6134279190614666565b6040516001600160a01b038516602482015260448101829052909150612da09085907f095ea7b30000000000000000000000000000000000000000000000000000000090606401612863565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff90911660048201526001600160a01b0382811691908616906382b8660090602401602060405180830381865afa1580156134de573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061350291906143c8565b6001600160a01b031614613542576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080840151606085015191517f9169558600000000000000000000000000000000000000000000000000000000815260ff918216600482015291166024820152604481018390526000606482015260001960848201526001600160a01b0385169063916955869060a4015b6020604051808303816000875af11580156135cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135f19190614882565b5050505050565b600061360385613960565b9050600061361086613a00565b9050826001600160a01b0316816001600160a01b03161461365d576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008267ffffffffffffffff81111561367857613678613e5b565b6040519080825280602002602001820160405280156136a1578160200160208202803683370190505b5090508481876040015160ff16815181106136be576136be614608565b60209081029190910101526040517f4d49e87d0000000000000000000000000000000000000000000000000000000081526001600160a01b03881690634d49e87d90613715908490600090600019906004016149f7565b6020604051808303816000875af1158015613734573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137589190614882565b5050505050505050565b60608301516040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff90911660048201526001600160a01b0382811691908616906382b8660090602401602060405180830381865afa1580156137cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137f191906143c8565b6001600160a01b031614613831576040517f28716b9200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60608301516040517f3e3a15600000000000000000000000000000000000000000000000000000000081526004810184905260ff90911660248201526000604482015260001960648201526001600160a01b03851690633e3a1560906084016135ae565b6040516001600160a01b0383166024820152604481018290526112b19084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401612863565b60006115758383613a70565b60006115758383613a88565b600061040a825490565b60006115758383613ad7565b60006115758383613b01565b60608315613927575081611575565b8251156139375782518084602001fd5b8160405162461bcd60e51b81526004016104d891906148b6565b6060611af78484600085613bf4565b6000805b6040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff821660048201526001600160a01b038416906382b8660090602401602060405180830381865afa9250505080156139e0575060408051601f3d908101601f191682019092526139dd918101906143c8565b60015b6139ef578060ff169150610b1c565b506139f981614a44565b9050613964565b6000816001600160a01b0316635fd65f0f6040518163ffffffff1660e01b815260040160e060405180830381865afa158015613a40573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a649190614a63565b98975050505050505050565b60008181526001830160205260408120541515611575565b6000818152600183016020526040812054613acf5750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561040a565b50600061040a565b6000826000018281548110613aee57613aee614608565b9060005260206000200154905092915050565b60008181526001830160205260408120548015613bea576000613b256001836148c9565b8554909150600090613b39906001906148c9565b9050818114613b9e576000866000018281548110613b5957613b59614608565b9060005260206000200154905080876000018481548110613b7c57613b7c614608565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613baf57613baf614ac3565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061040a565b600091505061040a565b606082471015613c6c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016104d8565b6001600160a01b0385163b613cc35760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016104d8565b600080866001600160a01b03168587604051613cdf91906149db565b60006040518083038185875af1925050503d8060008114613d1c576040519150601f19603f3d011682016040523d82523d6000602084013e613d21565b606091505b5091509150613d31828286613918565b979650505050505050565b6001600160a01b038116811461139557600080fd5b600060208284031215613d6357600080fd5b813561157581613d3c565b60005b83811015613d89578181015183820152602001613d71565b50506000910152565b60008151808452613daa816020860160208601613d6e565b601f01601f19169290920160200192915050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015613e4d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089840301855281518051878552613e2788860182613d92565b918901516001600160a01b03169489019490945294870194925090860190600101613de5565b509098975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715613ead57613ead613e5b565b60405290565b60405160a0810167ffffffffffffffff81118282101715613ead57613ead613e5b565b6040516060810167ffffffffffffffff81118282101715613ead57613ead613e5b565b604051601f8201601f1916810167ffffffffffffffff81118282101715613f2257613f22613e5b565b604052919050565b600067ffffffffffffffff821115613f4457613f44613e5b565b50601f01601f191660200190565b600082601f830112613f6357600080fd5b8135613f76613f7182613f2a565b613ef9565b818152846020838601011115613f8b57600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080600060a08688031215613fc057600080fd5b8535613fcb81613d3c565b94506020860135613fdb81613d3c565b9350604086013592506060860135613ff281613d3c565b9150608086013567ffffffffffffffff81111561400e57600080fd5b61401a88828901613f52565b9150509295509295909350565b60006020828403121561403957600080fd5b5035919050565b6000806040838503121561405357600080fd5b82359150602083013561406581613d3c565b809150509250929050565b6000806040838503121561408357600080fd5b823567ffffffffffffffff8082111561409b57600080fd5b90840190604082870312156140af57600080fd5b6140b7613e8a565b8235828111156140c657600080fd5b6140d288828601613f52565b8252506020928301358382015293505083013561406581613d3c565b60006001600160a01b03808351168452806020840151166020850152506040820151604084015260608201516060840152608082015160a06080850152611af760a0850182613d92565b60208152600061157560208301846140ee565b600060a0828403121561415d57600080fd5b614165613eb3565b9050813561417281613d3c565b8152602082013561418281613d3c565b806020830152506040820135604082015260608201356060820152608082013567ffffffffffffffff8111156141b757600080fd5b6141c384828501613f52565b60808301525092915050565b600080600080608085870312156141e557600080fd5b84356141f081613d3c565b9350602085013561420081613d3c565b925060408501359150606085013567ffffffffffffffff81111561422357600080fd5b61422f8782880161414b565b91505092959194509250565b600080600080600080600060e0888a03121561425657600080fd5b873561426181613d3c565b96506020880135955060408801359450606088013561427f81613d3c565b93506080880135925060a088013567ffffffffffffffff808211156142a357600080fd5b6142af8b838c0161414b565b935060c08a01359150808211156142c557600080fd5b506142d28a828b0161414b565b91505092959891949750929550565b6020808252825182820181905260009190848201906040850190845b818110156143225783516001600160a01b0316835292840192918401916001016142fd565b50909695505050505050565b60008060006060848603121561434357600080fd5b833561434e81613d3c565b9250602084013561435e81613d3c565b929592945050506040919091013590565b60008060006060848603121561438457600080fd5b833561438f81613d3c565b9250602084013567ffffffffffffffff8111156143ab57600080fd5b6143b786828701613f52565b925050604084013590509250925092565b6000602082840312156143da57600080fd5b815161157581613d3c565b60006143f3613f7184613f2a565b905082815283838301111561440757600080fd5b611575836020830184613d6e565b60006020828403121561442757600080fd5b815167ffffffffffffffff8082111561443f57600080fd5b9083019060a0828603121561445357600080fd5b61445b613eb3565b825161446681613d3c565b8152602083015161447681613d3c565b8060208301525060408301516040820152606083015160608201526080830151828111156144a357600080fd5b80840193505085601f8401126144b857600080fd5b6144c7868451602086016143e5565b608082015295945050505050565b600067ffffffffffffffff8211156144ef576144ef613e5b565b5060051b60200190565b6000602080838503121561450c57600080fd5b825167ffffffffffffffff8082111561452457600080fd5b818501915085601f83011261453857600080fd5b8151614546613f71826144d5565b81815260059190911b8301840190848101908883111561456557600080fd5b8585015b838110156145fb578051858111156145815760008081fd5b86016040818c03601f19018113156145995760008081fd5b6145a1613e8a565b89830151888111156145b35760008081fd5b8301603f81018e136145c55760008081fd5b6145d58e8c8301518584016143e5565b82525091810151916145e683613d3c565b808a0192909252508352918601918601614569565b5098975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561040a5761040a614637565b6000600019820361468c5761468c614637565b5060010190565b60006001600160a01b03808816835286602084015280861660408401525083606083015260a06080830152613d3160a08301846140ee565b805180151581146146db57600080fd5b919050565b6000602082840312156146f257600080fd5b815167ffffffffffffffff8082111561470a57600080fd5b818401915084601f83011261471e57600080fd5b815161472c613f71826144d5565b8082825260208201915060208360051b86010192508783111561474e57600080fd5b602085015b838110156148765780518581111561476a57600080fd5b86016060818b03601f1901121561478057600080fd5b614788613ed6565b602082015161479681613d3c565b815260408201516147a681613d3c565b60208201526060820151878111156147bd57600080fd5b8083019250508a603f8301126147d257600080fd5b60208201516147e3613f71826144d5565b81815260069190911b83016040019060208101908d83111561480457600080fd5b6040850194505b82851015614860576040858f03121561482357600080fd5b61482b613e8a565b614834866146cb565b8152602086015161484481613d3c565b806020830152508083525060208201915060408501945061480b565b6040840152505084525060209283019201614753565b50979650505050505050565b60006020828403121561489457600080fd5b5051919050565b6000602082840312156148ad57600080fd5b611575826146cb565b6020815260006115756020830184613d92565b8181038181111561040a5761040a614637565b60006001600160a01b038088168352808716602084015285604084015280851660608401525060a06080830152613d3160a0830184613d92565b805160ff811681146146db57600080fd5b60006080828403121561493957600080fd5b6040516080810181811067ffffffffffffffff8211171561495c5761495c613e5b565b60405282516004811061496e57600080fd5b8152602083015161497e81613d3c565b602082015261498f60408401614916565b60408201526149a060608401614916565b60608201529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600082516149ed818460208701613d6e565b9190910192915050565b606080825284519082018190526000906020906080840190828801845b82811015614a3057815184529284019290840190600101614a14565b505050908301949094525060400152919050565b600060ff821660ff8103614a5a57614a5a614637565b60010192915050565b600080600080600080600060e0888a031215614a7e57600080fd5b875196506020880151955060408801519450606088015193506080880151925060a0880151915060c0880151614ab381613d3c565b8091505092959891949750929550565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220fa6a143f537a228bb78bd144a6be8297f48c82927bfb46f5fb3a9a4390edc38f64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"95215:13600:0:-:0;;;;;;;;;;;;-1:-1:-1;51845:32:0;20979:10;51845:18;:32::i;:::-;95215:13600;;53194:187;53267:16;53286:6;;-1:-1:-1;;;;;53302:17:0;;;-1:-1:-1;;;;;;53302:17:0;;;;;;53334:40;;53286:6;;;;;;;53334:40;;53267:16;53334:40;53257:124;53194:187;:::o;95215:13600::-;;;;;;;","srcMapRuntime":"95215:13600:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;100545:182;;;;;;;;;;-1:-1:-1;100545:182:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;79464:295;;;;;;:::i;:::-;;:::i;:::-;;;5429:25:1;;;5417:2;5402:18;79464:295:0;5283:177:1;95575:31:0;;;;;;;;;;-1:-1:-1;95575:31:0;;;;-1:-1:-1;;;;;95575:31:0;;;;;;-1:-1:-1;;;;;5651:55:1;;;5633:74;;5621:2;5606:18;95575:31:0;5465:248:1;100763:178:0;;;;;;;;;;-1:-1:-1;100763:178:0;;;;;:::i;:::-;;:::i;99213:228::-;;;;;;;;;;-1:-1:-1;99213:228:0;;;;;:::i;:::-;;:::i;98453:440::-;;;;;;;;;;-1:-1:-1;98453:440:0;;;;;:::i;:::-;;:::i;:::-;;52592:101;;;;;;;;;;;;;:::i;103000:849::-;;;;;;;;;;-1:-1:-1;103000:849:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;97598:177::-;;;;;;;;;;-1:-1:-1;97598:177:0;;;;;:::i;:::-;;:::i;51960:85::-;;;;;;;;;;-1:-1:-1;52006:7:0;52032:6;-1:-1:-1;;;;;52032:6:0;51960:85;;99967:542;;;;;;;;;;;;;:::i;99477:454::-;;;;;;;;;;-1:-1:-1;99477:454:0;;;;;:::i;:::-;;:::i;98025:392::-;;;;;;;;;;-1:-1:-1;98025:392:0;;;;;:::i;:::-;;:::i;97261:301::-;;;;;;:::i;:::-;;:::i;98929:248::-;;;;;;;;;;-1:-1:-1;98929:248:0;;;;;:::i;:::-;;:::i;96242:983::-;;;;;;:::i;:::-;;:::i;100977:1987::-;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;97811:178::-;;;;;;;;;;-1:-1:-1;97811:178:0;;;;;:::i;:::-;;:::i;52842:198::-;;;;;;;;;;-1:-1:-1;52842:198:0;;;;;:::i;:::-;;:::i;103885:836::-;;;;;;;;;;-1:-1:-1;103885:836:0;;;;;:::i;:::-;;:::i;100545:182::-;100622:31;100678:42;100704:8;100714:5;100678:25;:42::i;:::-;100665:55;100545:182;-1:-1:-1;;100545:182:0:o;79464:295::-;79653:17;79689:63;79702:9;79713:7;79722:8;79732;79742:9;79689:12;:63::i;:::-;79682:70;79464:295;-1:-1:-1;;;;;;79464:295:0:o;100763:178::-;100834:33;100894:40;100920:7;100929:4;100894:25;:40::i;99213:228::-;99272:20;99309;99320:8;99309:10;:20::i;:::-;99304:68;;99338:34;;;;;;;;;;;;;;99304:68;99397:37;:14;99424:8;99397:18;:37::i;98453:440::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;;;;;;;;;-1:-1:-1;;;;;98554:26:0;::::1;98550:71;;98589:32;;;;;;;;;;;;;;98550:71;98636:20;98647:8;98636:10;:20::i;:::-;98631:68;;98665:34;;;;;;;;;;;;;;98631:68;98710:14;98727:37;:14;98754:8:::0;98727:18:::1;:37::i;:::-;98710:54:::0;-1:-1:-1;98774:51:0::1;:14;98801:8:::0;98812:12;98774:18:::1;:51::i;:::-;-1:-1:-1::0;98841:45:0::1;::::0;;-1:-1:-1;;;;;13326:15:1;;;13308:34;;13378:15;;13373:2;13358:18;;13351:43;98855:8:0;;98841:45:::1;::::0;13220:18:1;98841:45:0::1;;;;;;;98540:353;98453:440:::0;;:::o;52592:101::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;12712:356:1;52164:68:0;52656:30:::1;52683:1;52656:18;:30::i;:::-;52592:101::o:0;103000:849::-;103114:26;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;103114:26:0;103157:13;103172:18;103192:20;103216:48;103249:7;:14;;;103216:32;:48::i;:::-;103156:108;;-1:-1:-1;103156:108:0;-1:-1:-1;103156:108:0;-1:-1:-1;;;;;;103278:19:0;;103274:41;;103299:16;;;;;103274:41;103382:11;103407:8;-1:-1:-1;;;;;103398:17:0;:5;-1:-1:-1;;;;;103398:17:0;;:94;;;-1:-1:-1;;;;;;103420:41:0;;76661:42;103420:41;:71;;;;;103474:10;;;;;;;;;-1:-1:-1;;;;;103474:10:0;-1:-1:-1;;;;;103474:15:0;;:17;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;103465:26:0;:5;-1:-1:-1;;;;;103465:26:0;;103420:71;103396:97;103382:111;;103503:16;103522:71;103547:12;103561:5;103568:7;:16;;;103586:6;103522:24;:71::i;:::-;103503:90;;103607:8;103619:1;103607:13;103603:35;;103622:16;;;;;;;103603:35;103716:52;;;;;;;;;;;-1:-1:-1;;;;;103716:52:0;;;;;;;;;103790:10;;:52;;;;;13739:12:1;;103790:52:0;;;13727:25:1;13788:23;;13784:72;;13768:14;;;13761:96;14212:55;;;14192:18;;;14185:83;14284:18;;;14277:34;;;103716:52:0;;103790:10;;:23;;14099:19:1;;103790:52:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;103790:52:0;;;;;;;;;;;;:::i;:::-;103778:64;103000:849;-1:-1:-1;;;;;;;;;103000:849:0:o;97598:177::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;12712:356:1;52164:68:0;97700:10:::1;::::0;97682:52:::1;::::0;;-1:-1:-1;;;;;97700:10:0;;::::1;13308:34:1::0;;13378:15;;;13373:2;13358:18;;13351:43;97682:52:0::1;::::0;13220:18:1;97682:52:0::1;;;;;;;97744:10;:24:::0;;;::::1;-1:-1:-1::0;;;;;97744:24:0;;;::::1;::::0;;;::::1;::::0;;97598:177::o;99967:542::-;100015:20;100047:11;100061:23;:14;:21;:23::i;:::-;100047:37;;100094:34;100151:3;100131:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;100094:61:0;-1:-1:-1;100166:13:0;;100189:226;100213:3;100209:1;:7;100189:226;;;100240:20;100264;:14;100282:1;100264:17;:20::i;:::-;100237:47;;;100329:12;-1:-1:-1;;;;;100315:43:0;;:45;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;100315:45:0;;;;;;;;;;;;:::i;:::-;100298:11;100310:1;100298:14;;;;;;;;:::i;:::-;;;;;;:62;;;;100383:11;100395:1;100383:14;;;;;;;;:::i;:::-;;;;;;;:21;100374:30;;;;;:::i;:::-;;;100223:192;100218:3;;;;:::i;:::-;;;100189:226;;;-1:-1:-1;100476:26:0;:11;100496:5;100476:19;:26::i;:::-;100469:33;;;;;99967:542;:::o;99477:454::-;99540:16;99568:11;99582:23;:14;:21;:23::i;:::-;99568:37;;99620:9;99615:231;99639:3;99635:1;:7;99615:231;;;99664:11;;99695:20;:14;99713:1;99695:17;:20::i;:::-;99663:52;;;;99743:12;-1:-1:-1;;;;;99733:22:0;:6;-1:-1:-1;;;;;99733:22:0;;99729:107;;-1:-1:-1;99794:3:0;-1:-1:-1;99816:5:0;;99729:107;99649:197;;99644:3;;;;:::i;:::-;;;99615:231;;;-1:-1:-1;99859:8:0;99855:69;;99890:34;;;;;;;;;;;;;;99855:69;99558:373;99477:454;;;:::o;98025:392::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;12712:356:1;52164:68:0;98127:22;;;:52:::1;;-1:-1:-1::0;;;;;;98153:26:0;::::1;::::0;98127:52:::1;98123:97;;;98188:32;;;;;;;;;;;;;;98123:97;98234:20;98245:8;98234:10;:20::i;:::-;98230:64;;;98263:31;;;;;;;;;;;;;;98230:64;98305:51;:14;98332:8:::0;98343:12;98305:18:::1;:51::i;:::-;-1:-1:-1::0;98371:39:0::1;::::0;-1:-1:-1;;;;;5651:55:1;;5633:74;;98387:8:0;;98371:39:::1;::::0;5621:2:1;5606:18;98371:39:0::1;;;;;;;98025:392:::0;;:::o;97261:301::-;97406:17;97440:18;:5;6256:19;-1:-1:-1;;;;;6256:33:0;;;;6166:130;97440:18;97435:61;;97467:29;;;;;;;;;;;;;;97435:61;97522:33;97530:2;97534:5;97541:6;97549:5;97522:7;:33::i;98929:248::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;12712:356:1;52164:68:0;99013:20:::1;99024:8;99013:10;:20::i;:::-;99008:68;;99042:34;;;;;;;;;;;;;;99008:68;99087:40;:14;99117:8:::0;99087:21:::1;:40::i;:::-;-1:-1:-1::0;99142:28:0::1;::::0;99161:8;;99142:28:::1;::::0;;;::::1;98929:248:::0;:::o;96242:983::-;96493:20;96516;96527:8;96516:10;:20::i;:::-;96493:43;;96605:24;:11;6256:19;-1:-1:-1;;;;;6256:33:0;;;;6166:130;96605:24;96601:203;;;96663:50;96679:4;96686:5;96693:6;96701:11;96663:7;:50::i;:::-;96645:68;;-1:-1:-1;96645:68:0;-1:-1:-1;96601:203:0;;;96753:40;96772:4;96779:5;96786:6;96753:10;:40::i;:::-;96744:49;;96601:203;96909:20;96968:37;;;97019:2;97035:7;97056:5;97075:6;97095:9;96932:182;;;;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;96932:182:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;97124:42:0;-1:-1:-1;;;;;97124:33:0;;96932:182;97124:33;:42::i;:::-;;96483:742;;96242:983;;;;;;;:::o;100977:1987::-;101030:32;101116:19;101138:10;;;;;;;;;-1:-1:-1;;;;;101138:10:0;-1:-1:-1;;;;;101138:19:0;;:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;101138:21:0;;;;;;;;;;;;:::i;:::-;101116:43;;101231:30;101280:5;:12;101295:1;101280:16;;;;:::i;:::-;101264:33;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;101231:66;;101307:13;101423:26;:17;:15;:17::i;:::-;:24;:26::i;:::-;101395:11;101407:5;:12;101395:25;;;;;;;;:::i;:::-;;;;;;:54;;;;101468:11;101480:5;:12;101468:25;;;;;;;;:::i;:::-;;;;;;;:32;101459:41;;;;;:::i;:::-;;;101594:9;101589:1070;101613:5;:12;101609:1;:16;101589:1070;;;101646:16;101665:5;101671:1;101665:8;;;;;;;;:::i;:::-;;;;;;;101646:27;;101718:4;:11;;;:18;101704:33;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;101704:33:0;;101687:11;101699:1;101687:14;;;;;;;;:::i;:::-;;;;;;:50;;;;101976:9;101988:48;102023:4;:12;;;101988:11;102000:5;:12;101988:25;;;;;;;;:::i;:::-;;;;;;;:34;;:48;;;;:::i;:::-;101976:60;;102055:9;102050:463;102074:4;:11;;;:18;102070:1;:22;102050:463;;;102194:4;:11;;;102206:1;102194:14;;;;;;;;:::i;:::-;;;;;;;:20;;;102174:11;102186:1;102174:14;;;;;;;;:::i;:::-;;;;;;;102189:1;102174:17;;;;;;;;:::i;:::-;;;;;;:40;-1:-1:-1;;;;;102174:40:0;;;-1:-1:-1;;;;;102174:40:0;;;;;102429:4;102424:74;;102442:56;102477:4;:11;;;102489:1;102477:14;;;;;;;;:::i;:::-;;;;;;;:20;;;102442:11;102454:5;:12;102442:25;;;;;;;;:::i;:56::-;102435:63;;102424:74;102094:3;;;:::i;:::-;;;102050:463;;;;102575:4;102570:78;;102588:11;102600:1;102588:14;;;;;;;;:::i;:::-;;;;;;102581:21;;;;102570:78;;;102630:11;;;;:18;102621:27;;;;:::i;:::-;;;102570:78;101632:1027;;101627:3;;;;:::i;:::-;;;101589:1070;;;-1:-1:-1;102754:35:0;:26;:11;102774:5;102754:19;:26::i;:::-;:33;:35::i;:::-;102736:53;;102852:43;102877:10;;;;;;;;;-1:-1:-1;;;;;102877:10:0;-1:-1:-1;;;;;102877:15:0;;:17;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;102852:15;;:24;:43::i;:::-;102848:109;;;102904:53;:15;76661:42;102904:22;:53::i;102848:109::-;101064:1900;;;100977:1987;:::o;97811:178::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;12712:356:1;52164:68:0;97940:42:::1;-1:-1:-1::0;;;;;97940:25:0;::::1;97966:7:::0;97975:6;97940:25:::1;:42::i;:::-;97811:178:::0;;;:::o;52842:198::-;52006:7;52032:6;-1:-1:-1;;;;;52032:6:0;20979:10;52172:23;52164:68;;;;-1:-1:-1;;;52164:68:0;;12914:2:1;52164:68:0;;;12896:21:1;;;12933:18;;;12926:30;12992:34;12972:18;;;12965:62;13044:18;;52164:68:0;12712:356:1;52164:68:0;-1:-1:-1;;;;;52930:22:0;::::1;52922:73;;;::::0;-1:-1:-1;;;52922:73:0;;22313:2:1;52922:73:0::1;::::0;::::1;22295:21:1::0;22352:2;22332:18;;;22325:30;22391:34;22371:18;;;22364:62;22462:8;22442:18;;;22435:36;22488:19;;52922:73:0::1;22111:402:1::0;52922:73:0::1;53005:28;53024:8;53005:18;:28::i;:::-;52842:198:::0;:::o;103885:836::-;104028:28;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;104028:28:0;104069:16;104089:20;104113:45;104146:11;104113:32;:45::i;:::-;104068:90;;-1:-1:-1;104068:90:0;;-1:-1:-1;;;;;;;104172:22:0;;104168:46;;104196:18;;;;104168:46;104262:28;104293:66;;;;;;;;104319:22;-1:-1:-1;;8581:17:0;8493:112;104319:22;104293:66;;-1:-1:-1;;;;;104293:66:0;;;;;;;;104394:10;;:53;;;;;13739:12:1;;104394:53:0;;;13727:25:1;13794:16;;;13788:23;13784:72;;13768:14;;;13761:96;14212:55;;;14192:18;;;14185:83;14284:18;;;14277:34;;;104262:97:0;;-1:-1:-1;;;104394:10:0;;:23;;14099:19:1;;104394:53:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;104394:53:0;;;;;;;;;;;;:::i;:::-;104520:57;;;;;-1:-1:-1;;;;;5651:55:1;;;104520:57:0;;;5633:74:1;104369:78:0;;-1:-1:-1;104497:20:0;;104520:47;;;;;5606:18:1;;104520:57:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;104497:80;;104612:12;104591:5;:18;;;:33;104587:57;;;104626:18;;;;;;;104587:57;-1:-1:-1;104709:5:0;-1:-1:-1;;;;103885:836:0;;;;;;:::o;106197:1867::-;106295:30;106341:11;106355:23;:14;:21;:23::i;:::-;106341:37;;106388:34;106445:3;106425:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;106388:61:0;-1:-1:-1;106460:13:0;;106483:1485;106507:3;106503:1;:7;106483:1485;;;106534:20;106558;:14;106576:1;106558:17;:20::i;:::-;106531:47;;;106592:33;106642:12;-1:-1:-1;;;;;106628:43:0;;:45;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;106628:45:0;;;;;;;;;;;;:::i;:::-;106592:81;;106749:19;106782:25;106821:12;:19;106810:31;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;106810:31:0;;106782:59;;106860:9;106855:684;106879:12;:19;106875:1;:23;106855:684;;;106923:28;106954:6;:336;;107094:196;;;;;;;;107159:12;-1:-1:-1;;;;;107145:45:0;;107191:12;107204:1;107191:15;;;;;;;;:::i;:::-;;;;;;;:21;;;107145:68;;;;;;;;;;;;;;-1:-1:-1;;;;;5651:55:1;;;;5633:74;;5621:2;5606:18;;5465:248;107145:68:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;107094:196;;;;107246:12;107259:1;107246:15;;;;;;;;:::i;:::-;;;;;;;:21;;;-1:-1:-1;;;;;107094:196:0;;;;106954:336;;;106983:64;;;;;;;;107009:22;-1:-1:-1;;8581:17:0;8493:112;107009:22;106983:64;;;;107040:5;-1:-1:-1;;;;;106983:64:0;;;;106954:336;106923:367;;107330:17;107350:6;:38;;107383:5;107350:38;;;107359:12;107372:1;107359:15;;;;;;;;:::i;:::-;;;;;;;:21;;;107350:38;107423:10;;:50;;;;;13739:12:1;;107423:50:0;;;13727:25:1;13805:4;13794:16;;13788:23;-1:-1:-1;;;;;13784:72:1;;;13768:14;;;13761:96;23022:55;;;23002:18;;;22995:83;107330:58:0;;-1:-1:-1;107423:10:0;;;:29;;22910:18:1;;107423:50:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;107406:11;107418:1;107406:14;;;;;;;;:::i;:::-;;;;;;:67;;;;;;;;;;;107495:11;107507:1;107495:14;;;;;;;;:::i;:::-;;;;;;;107491:33;;;107511:13;;;;:::i;:::-;;;;107491:33;106905:634;;106900:3;;;;:::i;:::-;;;106855:684;;;;107671:11;107653:30;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;107653:30:0;;;;;;;;;;;;;;;;107636:11;107648:1;107636:14;;;;;;;;:::i;:::-;;;;;;;;;;:47;107697:20;107706:11;107697:20;;:::i;:::-;;-1:-1:-1;107732:9:0;;107755:203;107779:12;:19;107775:1;:23;107755:203;;;107827:11;107839:1;107827:14;;;;;;;;:::i;:::-;;;;;;;107823:121;;;107885:12;107898:1;107885:15;;;;;;;;:::i;:::-;;;;;;;107865:11;107877:1;107865:14;;;;;;;;:::i;:::-;;;;;;;107880:1;107865:17;;;;;;;;:::i;:::-;;;;;;:35;;;;107922:3;;;;;:::i;:::-;;;;107823:121;107800:3;;;:::i;:::-;;;107755:203;;;;106517:1451;;;;;106512:3;;;;:::i;:::-;;;106483:1485;;;-1:-1:-1;108031:26:0;:11;108051:5;108031:19;:26::i;79917:1827::-;80107:17;80342:27;80372:42;80385:7;80394:8;80404:9;80372:12;:42::i;:::-;80342:72;;80486:53;80503:7;80512:8;80522;80532:6;80486:16;:53::i;:::-;80476:63;;80701:19;80723:45;80742:7;80751:8;80761:6;80723:18;:45::i;:::-;80701:67;;81042:58;81061:7;81070:8;81080:11;81093:6;81042:18;:58::i;:::-;81030:70;-1:-1:-1;81314:41:0;-1:-1:-1;;;;;81314:41:0;;;81310:171;;81436:34;81447:11;81460:9;81436:10;:34::i;:::-;81689:48;-1:-1:-1;;;;;81689:26:0;;81716:9;81727;81689:26;:48::i;:::-;80126:1618;;79917:1827;;;;;;;:::o;104805:133::-;104866:4;104889:42;:14;104921:8;104889:23;:42::i;60323:169::-;60402:7;60452:30;60457:3;60477;60452:4;:30::i;58238:213::-;58357:4;58380:64;58385:3;58405;-1:-1:-1;;;;;58419:23:0;;58380:4;:64::i;:::-;58373:71;58238:213;-1:-1:-1;;;;58238:213:0:o;53194:187::-;53267:16;53286:6;;-1:-1:-1;;;;;53302:17:0;;;;;;;;;;53334:40;;53286:6;;;;;;;53334:40;;53267:16;53334:40;53257:124;53194:187;:::o;105172:638::-;105280:13;105303:18;105331:20;105372:11;105386:23;:14;:21;:23::i;:::-;105372:37;;105424:9;105419:385;105443:3;105439:1;:7;105419:385;;;105470:21;105495:20;:14;105513:1;105495:17;:20::i;:::-;105537:50;;;;;105467:48;;-1:-1:-1;;;;;;105537:42:0;;;-1:-1:-1;105537:42:0;;:50;;105580:6;;105537:50;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;105529:58;-1:-1:-1;;;;;;105605:19:0;;;105601:193;;105657:53;;;;;-1:-1:-1;;;;;5651:55:1;;;105657:53:0;;;5633:74:1;105657:46:0;;;;;5606:18:1;;105657:53:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;105644:66;-1:-1:-1;105743:13:0;-1:-1:-1;105774:5:0;;105601:193;-1:-1:-1;105448:3:0;;;:::i;:::-;;;105419:385;;;;105362:448;105172:638;;;;;:::o;108467:346::-;108675:69;;;;;-1:-1:-1;;;;;23735:55:1;;;108675:69:0;;;23717:74:1;23807:18;;;23800:34;;;23877:14;;23870:22;23850:18;;;23843:50;108628:15:0;;;;108675:46;;;;;23690:18:1;;108675:69:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;108655:89;;108770:6;108758:9;:18;108754:52;;;108788:18;108797:9;108788:6;:18;:::i;:::-;108778:28;;108754:52;108645:168;108467:346;;;;;;:::o;59061:121::-;59130:7;59156:19;59164:3;59156:7;:19::i;59519:233::-;59599:7;;;;59658:22;59662:3;59674:5;59658:3;:22::i;:::-;59627:53;;;;-1:-1:-1;59519:233:0;-1:-1:-1;;;;;59519:233:0:o;46982:536::-;47085:30;47161:5;47143:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;47143:24:0;;;;;;;;;;;;;;;-1:-1:-1;47131:36:0;-1:-1:-1;47178:9:0;;47197:211;47221:11;:18;47217:1;:22;47197:211;;;47265:9;47260:138;47284:11;47296:1;47284:14;;;;;;;;:::i;:::-;;;;;;;:21;47280:1;:25;47260:138;;;47345:11;47357:1;47345:14;;;;;;;;:::i;:::-;;;;;;;47360:1;47345:17;;;;;;;;:::i;:::-;;;;;;;47330:9;47340:1;47330:12;;;;;;;;:::i;:::-;;;;;;:32;;;;47380:3;;;;;:::i;:::-;;;;47307;;;;:::i;:::-;;;47260:138;;;-1:-1:-1;47241:3:0;;;:::i;:::-;;;47197:211;;;;47427:5;47422:1;:10;47418:44;;47441:21;;;;;;;;5429:25:1;;;5402:18;;47441:21:0;5283:177:1;47418:44:0;47121:397;46982:536;;;;:::o;92108:1732::-;92259:16;92277:17;92432:5;:14;;;92414:15;:32;92410:63;;;92455:18;;;;;;;;;;;;;;92410:63;92577:19;;92566:50;;92598:7;92607:8;92566:10;:50::i;:::-;92637:14;;;;92685:19;;92555:61;;-1:-1:-1;92637:14:0;-1:-1:-1;92743:4:0;-1:-1:-1;;;;;92718:30:0;;;92714:955;;92885:69;92898:9;92909:7;92918:8;92928;92938:5;:15;;;92885:12;:69::i;:::-;92873:81;;92714:955;;;93163:38;-1:-1:-1;;;;;93163:27:0;;93191:9;93163:27;:38::i;:::-;93151:50;;93230:13;-1:-1:-1;;;;;93215:41:0;;93264:9;93304;93340:7;93375:8;93411;93448:5;:15;;;93215:263;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;93649:9:0;93608:38;-1:-1:-1;;;;;93608:27:0;;93636:9;93608:27;:38::i;:::-;:50;;;;:::i;:::-;93596:62;;92714:955;93780:5;:18;;;93768:9;:30;93764:69;;;93807:26;;;;;;;;;;;;;;93764:69;92296:1544;92108:1732;;;;;;;:::o;58610:140::-;58687:4;58710:33;58718:3;58738;58710:7;:33::i;94022:1148::-;94140:20;94176:9;94189:1;94176:14;94172:992;;94206:24;:5;-1:-1:-1;;;;;94206:22:0;;:24::i;:::-;94311:34;;;;;-1:-1:-1;;;;;5651:55:1;;;94311:34:0;;;5633:74:1;94311:23:0;;;;;5606:18:1;;94311:34:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;94296:49;-1:-1:-1;94491:61:0;-1:-1:-1;;;;;94491:30:0;;94522:10;94534:9;94545:6;94491:30;:61::i;:::-;94688:34;;;;;-1:-1:-1;;;;;5651:55:1;;;94688:34:0;;;5633:74:1;94725:12:0;;94688:23;;;;;;5606:18:1;;94688:34:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:49;;;;:::i;:::-;94673:64;;94172:992;;;-1:-1:-1;;;;;94838:38:0;;76661:42;94838:38;94834:64;;94885:13;;;;;;;;;;;;;;94834:64;94975:9;94965:6;:19;94961:51;;94993:19;;;;;;;;;;;;;;94961:51;-1:-1:-1;95144:9:0;94022:1148;;;;;:::o;18565:198::-;18648:12;18679:77;18700:6;18708:4;18679:77;;;;;;;;;;;;;;;;;:20;:77::i;48512:193::-;48575:18;48623:1;:8;48609:23;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;48609:23:0;;48605:27;;48647:9;48642:56;48666:1;:8;48662:1;:12;48642:56;;;48688:1;48690;48688:4;;;;;;;;:::i;:::-;;;;;;;:10;;;48681:1;48683;48681:4;;;;;;;;:::i;:::-;-1:-1:-1;;;;;48681:17:0;;;:4;;;;;;;;;;;:17;48676:3;;;:::i;:::-;;;48642:56;;50278:212;50351:9;;50372:112;50396:1;:8;50392:1;:12;50372:112;;;50439:1;50441;50439:4;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;;;;;50433:10:0;:2;-1:-1:-1;;;;;50433:10:0;;50425:19;;50462:4;50468:5;50458:15;50406:3;;;:::i;:::-;;;50372:112;;47789:508;47876:26;47940:5;47926:20;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;47926:20:0;-1:-1:-1;47914:32:0;-1:-1:-1;47957:9:0;;47976:211;48000:11;:18;47996:1;:22;47976:211;;;48044:9;48039:138;48063:11;48075:1;48063:14;;;;;;;;:::i;:::-;;;;;;;:21;48059:1;:25;48039:138;;;48124:11;48136:1;48124:14;;;;;;;;:::i;:::-;;;;;;;48139:1;48124:17;;;;;;;;:::i;:::-;;;;;;;48109:9;48119:1;48109:12;;;;;;;;:::i;:::-;-1:-1:-1;;;;;48109:32:0;;;:12;;;;;;;;;;;:32;48159:3;;;;:::i;:::-;;;;48086;;;;:::i;:::-;;;48039:138;;;-1:-1:-1;48020:3:0;;;:::i;:::-;;;47976:211;;49378:689;49446:25;49483:29;49529:10;:17;49515:32;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;49515:32:0;-1:-1:-1;49483:64:0;-1:-1:-1;49605:13:0;;49628:227;49652:10;:17;49648:1;:21;49628:227;;;49690:10;49703;49714:1;49703:13;;;;;;;;:::i;:::-;;;;;;;49690:26;;49735;49744:12;49758:2;49735:8;:26::i;:::-;49730:115;;49803:2;49781:12;49794:5;49781:19;;;;;;;;:::i;:::-;-1:-1:-1;;;;;49781:24:0;;;:19;;;;;;;;;;;:24;49823:7;;;;:::i;:::-;;;;49730:115;-1:-1:-1;49671:3:0;;;:::i;:::-;;;49628:227;;;;49955:5;49941:20;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;49941:20:0;;49930:31;;49976:9;49971:90;49995:5;49991:1;:9;49971:90;;;50035:12;50048:1;50035:15;;;;;;;;:::i;:::-;;;;;;;50021:8;50030:1;50021:11;;;;;;;;:::i;:::-;-1:-1:-1;;;;;50021:29:0;;;:11;;;;;;;;;;;:29;50002:3;;;;:::i;:::-;;;;49971:90;;;;49473:594;;49378:689;;;:::o;50714:229::-;50785:18;50833:1;:8;50844:1;50833:12;;;;:::i;:::-;50819:27;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;50819:27:0;;50815:31;;50861:9;50856:50;50880:1;:8;50876:1;:12;50856:50;;;50902:1;50904;50902:4;;;;;;;;:::i;:::-;;;;;;;50895:1;50897;50895:4;;;;;;;;:::i;:::-;-1:-1:-1;;;;;50895:11:0;;;:4;;;;;;;;;;;:11;50890:3;;;;:::i;:::-;;;;50856:50;;;;50934:2;50916:1;50929;50918;:8;:12;;;;:::i;:::-;50916:15;;;;;;;;:::i;:::-;;;;;;:20;-1:-1:-1;;;;;50916:20:0;;;-1:-1:-1;;;;;50916:20:0;;;;;50714:229;;;;:::o;64326:603::-;64681:10;;;64680:62;;-1:-1:-1;64697:39:0;;;;;64721:4;64697:39;;;13308:34:1;-1:-1:-1;;;;;13378:15:1;;;13358:18;;;13351:43;64697:15:0;;;;;13220:18:1;;64697:39:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:44;64680:62;64659:163;;;;-1:-1:-1;;;64659:163:0;;24837:2:1;64659:163:0;;;24819:21:1;24876:2;24856:18;;;24849:30;24915:34;24895:18;;;24888:62;24986:24;24966:18;;;24959:52;25028:19;;64659:163:0;24635:418:1;64659:163:0;64859:62;;-1:-1:-1;;;;;25250:55:1;;64859:62:0;;;25232:74:1;25322:18;;;25315:34;;;64832:90:0;;64852:5;;64882:22;;25205:18:1;;64859:62:0;;;;-1:-1:-1;;64859:62:0;;;;;;;;;;;;;;;;;;;;;;;;;;;64832:19;:90::i;81813:522::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;82001:8:0;-1:-1:-1;;;;;81990:19:0;:7;-1:-1:-1;;;;;81990:19:0;;81986:49;;82018:17;;;;;;;;;;;;;;81986:49;82122:9;82111:38;;;;;;;;;;;;:::i;:::-;82243:11;;;;82102:47;;-1:-1:-1;;;;;;82243:25:0;;:62;;;;-1:-1:-1;82289:16:0;82272:13;;:33;;;;;;;;:::i;:::-;;;82243:62;82239:89;;;82314:14;;;;;;;;;;;;;;82465:914;82629:22;82762:40;-1:-1:-1;;;;;82762:40:0;;;82758:615;;83002:76;83029:8;83047:6;83072:4;83002:18;:76::i;:::-;82985:93;;83156:34;83165:14;83181:8;83156;:34::i;:::-;82758:615;;;-1:-1:-1;83238:7:0;83320:9;:14;83316:46;;83343:19;;;;;;;;;;;;;;83479:614;83624:19;83712:41;-1:-1:-1;;;;;83712:41:0;;;83708:379;;83947:76;83974:7;83991:6;84016:5;83947:18;:76::i;83708:379::-;-1:-1:-1;84068:8:0;;83479:614;-1:-1:-1;;83479:614:0:o;84201:1307::-;84370:17;84470:16;84453:13;;:33;;;;;;;;:::i;:::-;;84449:1053;;-1:-1:-1;84578:8:0;84449:1053;;;84675:44;;;;;84713:4;84675:44;;;5633:74:1;-1:-1:-1;;;;;84675:29:0;;;;;5606:18:1;;84675:44:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;84848:11;;;;84663:56;;-1:-1:-1;84810:60:0;;-1:-1:-1;;;;;84810:37:0;;;84861:8;84810:37;:60::i;:::-;84905:11;84888:13;;:28;;;;;;;;:::i;:::-;;84884:417;;84936:49;84942:6;:11;;;84955:6;84963:8;84973:11;84936:5;:49::i;:::-;84884:417;;;85027:19;85010:13;;:36;;;;;;;;:::i;:::-;;85006:295;;85066:57;85080:6;:11;;;85093:6;85101:8;85111:11;85066:13;:57::i;85006:295::-;85226:60;85243:6;:11;;;85256:6;85264:8;85274:11;85226:16;:60::i;:::-;85435:44;;;;;85473:4;85435:44;;;5633:74:1;85482:9:0;;-1:-1:-1;;;;;85435:29:0;;;;;5606:18:1;;85435:44:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:56;;;;:::i;:::-;85423:68;84201:1307;-1:-1:-1;;;;;84201:1307:0:o;90702:146::-;90812:29;;;;;;;;5429:25:1;;;-1:-1:-1;;;;;90812:21:0;;;;;5402:18:1;;90812:29:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;90702:146;;:::o;76944:593::-;77149:4;-1:-1:-1;;;;;77135:19:0;;;77131:32;;76944:593;;;:::o;77131:32::-;77176:20;-1:-1:-1;;;;;77176:20:0;;;77172:359;;77356:12;77374:2;-1:-1:-1;;;;;77374:7:0;77389:5;77374:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;77355:44;;;77421:7;77413:39;;;;-1:-1:-1;;;77413:39:0;;26950:2:1;77413:39:0;;;26932:21:1;26989:2;26969:18;;;26962:30;27028:21;27008:18;;;27001:49;27067:18;;77413:39:0;26748:343:1;77413:39:0;77198:265;97811:178;;;:::o;77172:359::-;77483:37;-1:-1:-1;;;;;77483:26:0;;77510:2;77514:5;77483:26;:37::i;58829:149::-;58913:4;58936:35;58946:3;58966;58936:9;:35::i;57145:232::-;57211:7;57246:16;;;:11;;;:16;;;;;;57280:10;;;;:33;;;57294:19;57304:3;57309;57294:9;:19::i;:::-;57272:76;;;;-1:-1:-1;;;57272:76:0;;27298:2:1;57272:76:0;;;27280:21:1;27337:2;27317:18;;;27310:30;27376:32;27356:18;;;27349:60;27426:18;;57272:76:0;27096:354:1;55136:188:0;55242:4;55258:16;;;:11;;;:16;;;;;:24;;;55299:18;55258:3;55270;55299:13;:18::i;55933:107::-;55989:7;56015:18;:3;:16;:18::i;56393:175::-;56460:7;;;56502:19;:3;56515:5;56502:12;:19::i;:::-;56544:16;;;;:11;;;;;:16;;;;;;;;;56393:175;-1:-1:-1;;;;56393:175:0:o;78380:251::-;78463:7;78486:20;-1:-1:-1;;;;;78486:20:0;;;78482:143;;-1:-1:-1;;;;;;78529:15:0;;;78522:22;;78482:143;78582:32;;;;;-1:-1:-1;;;;;5651:55:1;;;78582:32:0;;;5633:74:1;78582:23:0;;;;;5606:18:1;;78582:32:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;78575:39;;;;55492:148;55556:4;55579:16;;;:11;;;:16;;;;;55572:23;;;55612:21;55579:3;55591;55612:16;:21::i;78703:344::-;78870:38;-1:-1:-1;;;;;78870:38:0;;;78866:69;;78917:18;;;;;;;;;;;;;;78866:69;78991:5;-1:-1:-1;;;;;78991:17:0;;79012:1;78991:22;78987:53;;79022:18;;;;;;;;;;;;;;63825:241;63990:68;;-1:-1:-1;;;;;27736:15:1;;;63990:68:0;;;27718:34:1;27788:15;;27768:18;;;27761:43;27820:18;;;27813:34;;;63963:96:0;;63983:5;;64013:27;;27630:18:1;;63990:68:0;27455:398:1;18949:387:0;19090:12;-1:-1:-1;;;;;13460:19:0;;;19114:69;;;;-1:-1:-1;;;19114:69:0;;28060:2:1;19114:69:0;;;28042:21:1;28099:2;28079:18;;;28072:30;28138:34;28118:18;;;28111:62;28209:8;28189:18;;;28182:36;28235:19;;19114:69:0;27858:402:1;19114:69:0;19195:12;19209:23;19236:6;-1:-1:-1;;;;;19236:19:0;19256:4;19236:25;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;19194:67;;;;19278:51;19295:7;19304:10;19316:12;19278:16;:51::i;66120:706::-;66539:23;66565:69;66593:4;66565:69;;;;;;;;;;;;;;;;;66573:5;-1:-1:-1;;;;;66565:27:0;;;:69;;;;;:::i;:::-;66648:17;;66539:95;;-1:-1:-1;66648:21:0;66644:176;;66743:10;66732:30;;;;;;;;;;;;:::i;:::-;66724:85;;;;-1:-1:-1;;;66724:85:0;;28759:2:1;66724:85:0;;;28741:21:1;28798:2;28778:18;;;28771:30;28837:34;28817:18;;;28810:62;28908:12;28888:18;;;28881:40;28938:19;;66724:85:0;28557:406:1;90910:608:0;91057:12;91102:16;91085:13;;:33;;;;;;;;:::i;:::-;;91081:431;;-1:-1:-1;91244:5:0;91081:431;;;91403:6;:11;;;-1:-1:-1;;;;;91390:34:0;;91425:15;:61;;91467:6;:19;;;91425:61;;;91443:6;:21;;;91425:61;91390:97;;;;;;;;;;29140:4:1;29128:17;;;91390:97:0;;;29110:36:1;29083:18;;91390:97:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;90430:230::-;90511:9;90501:6;:19;90497:51;;90529:19;;;;;;;;;;;;;;90497:51;90623:4;-1:-1:-1;;;;;90616:20:0;;90644:6;90616:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;90430:230;;:::o;64935:310::-;65084:39;;;;;65108:4;65084:39;;;13308:34:1;-1:-1:-1;;;;;13378:15:1;;;13358:18;;;13351:43;65061:20:0;;65126:5;;65084:15;;;;;13220:18:1;;65084:39:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:47;;;;:::i;:::-;65168:69;;-1:-1:-1;;;;;25250:55:1;;65168:69:0;;;25232:74:1;25322:18;;;25315:34;;;65061:70:0;;-1:-1:-1;65141:97:0;;65161:5;;65191:22;;25205:18:1;;65168:69:0;25058:297:1;85929:605:0;86165:19;;;;86137:48;;;;;29140:4:1;29128:17;;;86137:48:0;;;29110:36:1;-1:-1:-1;;;;;86137:60:0;;;;:27;;;;;;29083:18:1;;86137:48:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;86137:60:0;;86133:95;;86206:22;;;;;;;;;;;;;;86133:95;86359:21;;;;;86408:19;;;;86305:222;;;;;29446:4:1;29434:17;;;86305:222:0;;;29416:36:1;29488:17;;29468:18;;;29461:45;29522:18;;;29515:34;;;86474:1:0;29565:18:1;;;29558:34;-1:-1:-1;;29608:19:1;;;29601:35;-1:-1:-1;;;;;86305:23:0;;;;;29388:19:1;;86305:222:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;85929:605;;;;:::o;86689:659::-;86848:17;86868:23;86886:4;86868:17;:23::i;:::-;86848:43;;86901:15;86919:21;86935:4;86919:15;:21::i;:::-;86901:39;;87011:8;-1:-1:-1;;;;;87000:19:0;:7;-1:-1:-1;;;;;87000:19:0;;86996:54;;87028:22;;;;;;;;;;;;;;86996:54;87060:24;87101:9;87087:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;87087:24:0;;87060:51;;87154:8;87121:7;87129:6;:21;;;87121:30;;;;;;;;;;:::i;:::-;;;;;;;;;;:41;87239:102;;;;;-1:-1:-1;;;;;87239:39:0;;;;;:102;;87289:7;;87309:1;;-1:-1:-1;;87322:17:0;87239:102;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;86838:510;;;86689:659;;;;:::o;87508:603::-;87755:19;;;;87727:48;;;;;29140:4:1;29128:17;;;87727:48:0;;;29110:36:1;-1:-1:-1;;;;;87727:60:0;;;;:27;;;;;;29083:18:1;;87727:48:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;87727:60:0;;87723:95;;87796:22;;;;;;;;;;;;;;87723:95;88007:19;;;;87895:209;;;;;;;;30672:25:1;;;30745:4;30733:17;;;30713:18;;;30706:45;88051:1:0;30767:18:1;;;30760:34;-1:-1:-1;;30810:18:1;;;30803:34;-1:-1:-1;;;;;87895:50:0;;;;;30644:19:1;;87895:209:0;30437:406:1;63614:205:0;63753:58;;-1:-1:-1;;;;;25250:55:1;;63753:58:0;;;25232:74:1;25322:18;;;25315:34;;;63726:86:0;;63746:5;;63776:23;;25205:18:1;;63753:58:0;25058:297:1;55719:124:0;55790:4;55813:23;:3;55832;55813:18;:23::i;26529:123::-;26599:4;26622:23;26627:3;26639:5;26622:4;:23::i;27249:115::-;27312:7;27338:19;27346:3;25155:18;;25073:107;27706:129;27780:7;27806:22;27810:3;27822:5;27806:3;:22::i;26820:129::-;26893:4;26916:26;26924:3;26936:5;26916:7;:26::i;19556:692::-;19702:12;19730:7;19726:516;;;-1:-1:-1;19760:10:0;19753:17;;19726:516;19871:17;;:21;19867:365;;20065:10;20059:17;20125:15;20112:10;20108:2;20104:19;20097:44;19867:365;20204:12;20197:20;;-1:-1:-1;;;20197:20:0;;;;;;;;:::i;15856:223::-;15989:12;16020:52;16042:6;16050:4;16056:1;16059:12;16020:21;:52::i;88699:406::-;88763:17;;88864:235;88915:34;;;;;29140:4:1;29128:17;;88915:34:0;;;29110:36:1;-1:-1:-1;;;;;88915:27:0;;;;;29083:18:1;;88915:34:0;;;;;;;;;;;;;;;;;;-1:-1:-1;88915:34:0;;;;;;;;-1:-1:-1;;88915:34:0;;;;;;;;;;;;:::i;:::-;;;88911:178;;89046:5;89034:17;;;;89069:5;;88911:178;88950:20;88888:7;;;:::i;:::-;;;88864:235;;88472:160;88534:15;88606:4;-1:-1:-1;;;;;88585:38:0;;:40;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;88561:64;88472:160;-1:-1:-1;;;;;;;;88472:160:0:o;27030:138::-;27110:4;24961:19;;;:12;;;:19;;;;;;:24;;27133:28;24865:127;22824:404;22887:4;24961:19;;;:12;;;:19;;;;;;22903:319;;-1:-1:-1;22945:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;23125:18;;23103:19;;;:12;;;:19;;;;;;:40;;;;23157:11;;22903:319;-1:-1:-1;23206:5:0;23199:12;;25522:118;25589:7;25615:3;:11;;25627:5;25615:18;;;;;;;;:::i;:::-;;;;;;;;;25608:25;;25522:118;;;;:::o;23396:1388::-;23462:4;23599:19;;;:12;;;:19;;;;;;23633:15;;23629:1149;;24002:21;24026:14;24039:1;24026:10;:14;:::i;:::-;24074:18;;24002:38;;-1:-1:-1;24054:17:0;;24074:22;;24095:1;;24074:22;:::i;:::-;24054:42;;24128:13;24115:9;:26;24111:398;;24161:17;24181:3;:11;;24193:9;24181:22;;;;;;;;:::i;:::-;;;;;;;;;24161:42;;24332:9;24303:3;:11;;24315:13;24303:26;;;;;;;;:::i;:::-;;;;;;;;;;;;:38;;;;24415:23;;;:12;;;:23;;;;;:36;;;24111:398;24587:17;;:3;;:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;24679:3;:12;;:19;24692:5;24679:19;;;;;;;;;;;24672:26;;;24720:4;24713:11;;;;;;;23629:1149;24762:5;24755:12;;;;;16943:499;17108:12;17165:5;17140:21;:30;;17132:81;;;;-1:-1:-1;;;17132:81:0;;32045:2:1;17132:81:0;;;32027:21:1;32084:2;32064:18;;;32057:30;32123:34;32103:18;;;32096:62;32194:8;32174:18;;;32167:36;32220:19;;17132:81:0;31843:402:1;17132:81:0;-1:-1:-1;;;;;13460:19:0;;;17223:60;;;;-1:-1:-1;;;17223:60:0;;32452:2:1;17223:60:0;;;32434:21:1;32491:2;32471:18;;;32464:30;32530:31;32510:18;;;32503:59;32579:18;;17223:60:0;32250:353:1;17223:60:0;17295:12;17309:23;17336:6;-1:-1:-1;;;;;17336:11:0;17355:5;17362:4;17336:31;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;17294:73;;;;17384:51;17401:7;17410:10;17422:12;17384:16;:51::i;:::-;17377:58;16943:499;-1:-1:-1;;;;;;;16943:499:0:o;14:154:1:-;-1:-1:-1;;;;;93:5:1;89:54;82:5;79:65;69:93;;158:1;155;148:12;173:247;232:6;285:2;273:9;264:7;260:23;256:32;253:52;;;301:1;298;291:12;253:52;340:9;327:23;359:31;384:5;359:31;:::i;425:250::-;510:1;520:113;534:6;531:1;528:13;520:113;;;610:11;;;604:18;591:11;;;584:39;556:2;549:10;520:113;;;-1:-1:-1;;667:1:1;649:16;;642:27;425:250::o;680:330::-;722:3;760:5;754:12;787:6;782:3;775:19;803:76;872:6;865:4;860:3;856:14;849:4;842:5;838:16;803:76;:::i;:::-;924:2;912:15;-1:-1:-1;;908:88:1;899:98;;;;999:4;895:109;;680:330;-1:-1:-1;;680:330:1:o;1015:1172::-;1211:4;1240:2;1280;1269:9;1265:18;1310:2;1299:9;1292:21;1333:6;1368;1362:13;1399:6;1391;1384:22;1425:2;1415:12;;1458:2;1447:9;1443:18;1436:25;;1520:2;1510:6;1507:1;1503:14;1492:9;1488:30;1484:39;1558:2;1550:6;1546:15;1579:1;1589:569;1603:6;1600:1;1597:13;1589:569;;;1692:66;1680:9;1672:6;1668:22;1664:95;1659:3;1652:108;1789:6;1783:13;1835:2;1829:9;1866:2;1858:6;1851:18;1896:48;1940:2;1932:6;1928:15;1914:12;1896:48;:::i;:::-;1991:11;;;1985:18;-1:-1:-1;;;;;1981:67:1;1964:15;;;1957:92;;;;2136:12;;;;1882:62;-1:-1:-1;2101:15:1;;;;1625:1;1618:9;1589:569;;;-1:-1:-1;2175:6:1;;1015:1172;-1:-1:-1;;;;;;;;1015:1172:1:o;2192:184::-;2244:77;2241:1;2234:88;2341:4;2338:1;2331:15;2365:4;2362:1;2355:15;2381:251;2453:2;2447:9;;;2483:15;;2528:18;2513:34;;2549:22;;;2510:62;2507:88;;;2575:18;;:::i;:::-;2611:2;2604:22;2381:251;:::o;2637:253::-;2709:2;2703:9;2751:4;2739:17;;2786:18;2771:34;;2807:22;;;2768:62;2765:88;;;2833:18;;:::i;3157:253::-;3229:2;3223:9;3271:4;3259:17;;3306:18;3291:34;;3327:22;;;3288:62;3285:88;;;3353:18;;:::i;3415:334::-;3486:2;3480:9;3542:2;3532:13;;-1:-1:-1;;3528:86:1;3516:99;;3645:18;3630:34;;3666:22;;;3627:62;3624:88;;;3692:18;;:::i;:::-;3728:2;3721:22;3415:334;;-1:-1:-1;3415:334:1:o;3754:245::-;3802:4;3835:18;3827:6;3824:30;3821:56;;;3857:18;;:::i;:::-;-1:-1:-1;3914:2:1;3902:15;-1:-1:-1;;3898:88:1;3988:4;3894:99;;3754:245::o;4004:462::-;4046:5;4099:3;4092:4;4084:6;4080:17;4076:27;4066:55;;4117:1;4114;4107:12;4066:55;4153:6;4140:20;4184:48;4200:31;4228:2;4200:31;:::i;:::-;4184:48;:::i;:::-;4257:2;4248:7;4241:19;4303:3;4296:4;4291:2;4283:6;4279:15;4275:26;4272:35;4269:55;;;4320:1;4317;4310:12;4269:55;4385:2;4378:4;4370:6;4366:17;4359:4;4350:7;4346:18;4333:55;4433:1;4408:16;;;4426:4;4404:27;4397:38;;;;4412:7;4004:462;-1:-1:-1;;;4004:462:1:o;4471:807::-;4575:6;4583;4591;4599;4607;4660:3;4648:9;4639:7;4635:23;4631:33;4628:53;;;4677:1;4674;4667:12;4628:53;4716:9;4703:23;4735:31;4760:5;4735:31;:::i;:::-;4785:5;-1:-1:-1;4842:2:1;4827:18;;4814:32;4855:33;4814:32;4855:33;:::i;:::-;4907:7;-1:-1:-1;4961:2:1;4946:18;;4933:32;;-1:-1:-1;5017:2:1;5002:18;;4989:32;5030:33;4989:32;5030:33;:::i;:::-;5082:7;-1:-1:-1;5140:3:1;5125:19;;5112:33;5168:18;5157:30;;5154:50;;;5200:1;5197;5190:12;5154:50;5223:49;5264:7;5255:6;5244:9;5240:22;5223:49;:::i;:::-;5213:59;;;4471:807;;;;;;;;:::o;5718:180::-;5777:6;5830:2;5818:9;5809:7;5805:23;5801:32;5798:52;;;5846:1;5843;5836:12;5798:52;-1:-1:-1;5869:23:1;;5718:180;-1:-1:-1;5718:180:1:o;6134:315::-;6202:6;6210;6263:2;6251:9;6242:7;6238:23;6234:32;6231:52;;;6279:1;6276;6269:12;6231:52;6315:9;6302:23;6292:33;;6375:2;6364:9;6360:18;6347:32;6388:31;6413:5;6388:31;:::i;:::-;6438:5;6428:15;;;6134:315;;;;;:::o;6454:808::-;6550:6;6558;6611:2;6599:9;6590:7;6586:23;6582:32;6579:52;;;6627:1;6624;6617:12;6579:52;6667:9;6654:23;6696:18;6737:2;6729:6;6726:14;6723:34;;;6753:1;6750;6743:12;6723:34;6776:22;;;;6832:2;6814:16;;;6810:25;6807:45;;;6848:1;6845;6838:12;6807:45;6874:22;;:::i;:::-;6934:2;6921:16;6962:2;6952:8;6949:16;6946:36;;;6978:1;6975;6968:12;6946:36;7005:44;7041:7;7030:8;7026:2;7022:17;7005:44;:::i;:::-;6991:59;;-1:-1:-1;7103:2:1;7095:11;;;7082:25;7066:14;;;7059:49;6998:5;-1:-1:-1;;7169:18:1;;7156:32;7197:33;7156:32;7197:33;:::i;7267:500::-;7319:3;-1:-1:-1;;;;;7428:2:1;7420:5;7414:12;7410:21;7405:3;7398:34;7493:2;7485:4;7478:5;7474:16;7468:23;7464:32;7457:4;7452:3;7448:14;7441:56;;7546:4;7539:5;7535:16;7529:23;7522:4;7517:3;7513:14;7506:47;7602:4;7595:5;7591:16;7585:23;7578:4;7573:3;7569:14;7562:47;7655:4;7648:5;7644:16;7638:23;7693:4;7686;7681:3;7677:14;7670:28;7714:47;7755:4;7750:3;7746:14;7732:12;7714:47;:::i;7772:262::-;7953:2;7942:9;7935:21;7916:4;7973:55;8024:2;8013:9;8009:18;8001:6;7973:55;:::i;8495:754::-;8551:5;8599:4;8587:9;8582:3;8578:19;8574:30;8571:50;;;8617:1;8614;8607:12;8571:50;8639:22;;:::i;:::-;8630:31;;8698:9;8685:23;8717:33;8742:7;8717:33;:::i;:::-;8759:22;;8833:2;8818:18;;8805:32;8846:33;8805:32;8846:33;:::i;:::-;8911:7;8906:2;8899:5;8895:14;8888:31;;8979:2;8968:9;8964:18;8951:32;8946:2;8939:5;8935:14;8928:56;9044:2;9033:9;9029:18;9016:32;9011:2;9004:5;9000:14;8993:56;9100:3;9089:9;9085:19;9072:33;9128:18;9120:6;9117:30;9114:50;;;9160:1;9157;9150:12;9114:50;9197:45;9238:3;9229:6;9218:9;9214:22;9197:45;:::i;:::-;9191:3;9184:5;9180:15;9173:70;;8495:754;;;;:::o;9254:693::-;9366:6;9374;9382;9390;9443:3;9431:9;9422:7;9418:23;9414:33;9411:53;;;9460:1;9457;9450:12;9411:53;9499:9;9486:23;9518:31;9543:5;9518:31;:::i;:::-;9568:5;-1:-1:-1;9625:2:1;9610:18;;9597:32;9638:33;9597:32;9638:33;:::i;:::-;9690:7;-1:-1:-1;9744:2:1;9729:18;;9716:32;;-1:-1:-1;9799:2:1;9784:18;;9771:32;9826:18;9815:30;;9812:50;;;9858:1;9855;9848:12;9812:50;9881:60;9933:7;9924:6;9913:9;9909:22;9881:60;:::i;:::-;9871:70;;;9254:693;;;;;;;:::o;9952:1079::-;10117:6;10125;10133;10141;10149;10157;10165;10218:3;10206:9;10197:7;10193:23;10189:33;10186:53;;;10235:1;10232;10225:12;10186:53;10274:9;10261:23;10293:31;10318:5;10293:31;:::i;:::-;10343:5;-1:-1:-1;10395:2:1;10380:18;;10367:32;;-1:-1:-1;10446:2:1;10431:18;;10418:32;;-1:-1:-1;10502:2:1;10487:18;;10474:32;10515:33;10474:32;10515:33;:::i;:::-;10567:7;-1:-1:-1;10621:3:1;10606:19;;10593:33;;-1:-1:-1;10677:3:1;10662:19;;10649:33;10701:18;10731:14;;;10728:34;;;10758:1;10755;10748:12;10728:34;10781:60;10833:7;10824:6;10813:9;10809:22;10781:60;:::i;:::-;10771:70;;10894:3;10883:9;10879:19;10866:33;10850:49;;10924:2;10914:8;10911:16;10908:36;;;10940:1;10937;10930:12;10908:36;;10963:62;11017:7;11006:8;10995:9;10991:24;10963:62;:::i;:::-;10953:72;;;9952:1079;;;;;;;;;;:::o;11036:681::-;11207:2;11259:21;;;11329:13;;11232:18;;;11351:22;;;11178:4;;11207:2;11430:15;;;;11404:2;11389:18;;;11178:4;11473:218;11487:6;11484:1;11481:13;11473:218;;;11552:13;;-1:-1:-1;;;;;11548:62:1;11536:75;;11666:15;;;;11631:12;;;;11509:1;11502:9;11473:218;;;-1:-1:-1;11708:3:1;;11036:681;-1:-1:-1;;;;;;11036:681:1:o;11722:456::-;11799:6;11807;11815;11868:2;11856:9;11847:7;11843:23;11839:32;11836:52;;;11884:1;11881;11874:12;11836:52;11923:9;11910:23;11942:31;11967:5;11942:31;:::i;:::-;11992:5;-1:-1:-1;12049:2:1;12034:18;;12021:32;12062:33;12021:32;12062:33;:::i;:::-;11722:456;;12114:7;;-1:-1:-1;;;12168:2:1;12153:18;;;;12140:32;;11722:456::o;12183:524::-;12270:6;12278;12286;12339:2;12327:9;12318:7;12314:23;12310:32;12307:52;;;12355:1;12352;12345:12;12307:52;12394:9;12381:23;12413:31;12438:5;12413:31;:::i;:::-;12463:5;-1:-1:-1;12519:2:1;12504:18;;12491:32;12546:18;12535:30;;12532:50;;;12578:1;12575;12568:12;12532:50;12601:49;12642:7;12633:6;12622:9;12618:22;12601:49;:::i;:::-;12591:59;;;12697:2;12686:9;12682:18;12669:32;12659:42;;12183:524;;;;;:::o;13405:251::-;13475:6;13528:2;13516:9;13507:7;13503:23;13499:32;13496:52;;;13544:1;13541;13534:12;13496:52;13576:9;13570:16;13595:31;13620:5;13595:31;:::i;14322:320::-;14397:5;14426:52;14442:35;14470:6;14442:35;:::i;14426:52::-;14417:61;;14501:6;14494:5;14487:21;14541:3;14532:6;14527:3;14523:16;14520:25;14517:45;;;14558:1;14555;14548:12;14517:45;14571:65;14629:6;14622:4;14615:5;14611:16;14606:3;14571:65;:::i;14647:1091::-;14743:6;14796:2;14784:9;14775:7;14771:23;14767:32;14764:52;;;14812:1;14809;14802:12;14764:52;14845:9;14839:16;14874:18;14915:2;14907:6;14904:14;14901:34;;;14931:1;14928;14921:12;14901:34;14954:22;;;;15010:4;14992:16;;;14988:27;14985:47;;;15028:1;15025;15018:12;14985:47;15054:22;;:::i;:::-;15106:2;15100:9;15118:33;15143:7;15118:33;:::i;:::-;15160:22;;15220:2;15212:11;;15206:18;15233:33;15206:18;15233:33;:::i;:::-;15298:7;15293:2;15286:5;15282:14;15275:31;;15352:2;15348;15344:11;15338:18;15333:2;15326:5;15322:14;15315:42;15403:2;15399;15395:11;15389:18;15384:2;15377:5;15373:14;15366:42;15447:3;15443:2;15439:12;15433:19;15477:2;15467:8;15464:16;15461:36;;;15493:1;15490;15483:12;15461:36;15524:8;15520:2;15516:17;15506:27;;;15571:7;15564:4;15560:2;15556:13;15552:27;15542:55;;15593:1;15590;15583:12;15542:55;15630:77;15699:7;15694:2;15688:9;15683:2;15679;15675:11;15630:77;:::i;:::-;15624:3;15613:15;;15606:102;15617:5;14647:1091;-1:-1:-1;;;;;14647:1091:1:o;15743:194::-;15814:4;15847:18;15839:6;15836:30;15833:56;;;15869:18;;:::i;:::-;-1:-1:-1;15914:1:1;15910:14;15926:4;15906:25;;15743:194::o;15942:2017::-;16064:6;16095:2;16138;16126:9;16117:7;16113:23;16109:32;16106:52;;;16154:1;16151;16144:12;16106:52;16187:9;16181:16;16216:18;16257:2;16249:6;16246:14;16243:34;;;16273:1;16270;16263:12;16243:34;16311:6;16300:9;16296:22;16286:32;;16356:7;16349:4;16345:2;16341:13;16337:27;16327:55;;16378:1;16375;16368:12;16327:55;16407:2;16401:9;16430:71;16446:54;16497:2;16446:54;:::i;16430:71::-;16535:15;;;16617:1;16613:10;;;;16605:19;;16601:28;;;16566:12;;;;16641:19;;;16638:39;;;16673:1;16670;16663:12;16638:39;16705:2;16701;16697:11;16717:1212;16733:6;16728:3;16725:15;16717:1212;;;16812:3;16806:10;16848:2;16835:11;16832:19;16829:109;;;16892:1;16921:2;16917;16910:14;16829:109;16961:20;;17004:4;17032:16;;;-1:-1:-1;;17028:89:1;17024:98;-1:-1:-1;17021:188:1;;;17163:1;17192:2;17188;17181:14;17021:188;17235:22;;:::i;:::-;17300:2;17296;17292:11;17286:18;17333:2;17323:8;17320:16;17317:106;;;17377:1;17406:2;17402;17395:14;17317:106;17447:17;;17500:2;17491:12;;17487:26;-1:-1:-1;17477:127:1;;17556:1;17586:3;17581;17574:16;17477:127;17631:88;17711:7;17705:2;17700:3;17696:12;17690:19;17685:2;17680:3;17676:12;17631:88;:::i;:::-;17617:103;;-1:-1:-1;17754:11:1;;;17748:18;;17779:33;17748:18;17779:33;:::i;:::-;17832:14;;;17825:31;;;;-1:-1:-1;17869:18:1;;17907:12;;;;16750;;16717:1212;;;-1:-1:-1;17948:5:1;15942:2017;-1:-1:-1;;;;;;;;15942:2017:1:o;17964:184::-;18016:77;18013:1;18006:88;18113:4;18110:1;18103:15;18137:4;18134:1;18127:15;18153:184;18205:77;18202:1;18195:88;18302:4;18299:1;18292:15;18326:4;18323:1;18316:15;18342:125;18407:9;;;18428:10;;;18425:36;;;18441:18;;:::i;18472:195::-;18511:3;-1:-1:-1;;18535:5:1;18532:77;18529:103;;18612:18;;:::i;:::-;-1:-1:-1;18659:1:1;18648:13;;18472:195::o;18672:628::-;18928:4;-1:-1:-1;;;;;19038:2:1;19030:6;19026:15;19015:9;19008:34;19078:6;19073:2;19062:9;19058:18;19051:34;19133:2;19125:6;19121:15;19116:2;19105:9;19101:18;19094:43;;19173:6;19168:2;19157:9;19153:18;19146:34;19217:3;19211;19200:9;19196:19;19189:32;19238:56;19289:3;19278:9;19274:19;19266:6;19238:56;:::i;19305:164::-;19381:13;;19430;;19423:21;19413:32;;19403:60;;19459:1;19456;19449:12;19403:60;19305:164;;;:::o;19474:2632::-;19590:6;19643:2;19631:9;19622:7;19618:23;19614:32;19611:52;;;19659:1;19656;19649:12;19611:52;19692:9;19686:16;19721:18;19762:2;19754:6;19751:14;19748:34;;;19778:1;19775;19768:12;19748:34;19816:6;19805:9;19801:22;19791:32;;19861:7;19854:4;19850:2;19846:13;19842:27;19832:55;;19883:1;19880;19873:12;19832:55;19912:2;19906:9;19935:71;19951:54;20002:2;19951:54;:::i;19935:71::-;20028:3;20052:2;20047:3;20040:15;20080:2;20075:3;20071:12;20064:19;;20131:2;20125;20122:1;20118:10;20114:2;20110:19;20106:28;20092:42;;20157:7;20149:6;20146:19;20143:39;;;20178:1;20175;20168:12;20143:39;20210:2;20206;20202:11;20222:1854;20238:6;20233:3;20230:15;20222:1854;;;20317:3;20311:10;20353:2;20340:11;20337:19;20334:39;;;20369:1;20366;20359:12;20334:39;20396:20;;20527:4;20440:16;;;-1:-1:-1;;20436:89:1;20432:100;20429:120;;;20545:1;20542;20535:12;20429:120;20575:22;;:::i;:::-;20639:2;20635;20631:11;20625:18;20656:33;20681:7;20656:33;:::i;:::-;20702:22;;20766:2;20758:11;;20752:18;20783:33;20752:18;20783:33;:::i;:::-;20847:2;20836:14;;20829:31;20903:4;20895:13;;20889:20;20925:16;;;20922:36;;;20954:1;20951;20944:12;20922:36;20989:8;20985:2;20981:17;20971:27;;;21038:7;21033:2;21029;21025:11;21021:25;21011:53;;21060:1;21057;21050:12;21011:53;21101:2;21097;21093:11;21087:18;21131:71;21147:54;21198:2;21147:54;:::i;21131:71::-;21246:17;;;21344:1;21340:10;;;;21332:19;;21353:2;21328:28;;21296:2;21285:14;;;21372:21;;;21369:41;;;21406:1;21403;21396:12;21369:41;21444:2;21440;21436:11;21423:24;;21460:501;21478:8;21471:5;21468:19;21460:501;;;21574:2;21566:5;21557:7;21553:19;21549:28;21546:48;;;21590:1;21587;21580:12;21546:48;21626:22;;:::i;:::-;21681:33;21708:5;21681:33;:::i;:::-;21672:7;21665:50;21764:2;21757:5;21753:14;21747:21;21785:33;21810:7;21785:33;:::i;:::-;21860:7;21855:2;21846:7;21842:16;21835:33;;21899:7;21892:5;21885:22;;21944:2;21937:5;21933:14;21924:23;;21510:2;21503:5;21499:14;21490:23;;21460:501;;;21992:2;21981:14;;21974:29;-1:-1:-1;;22016:18:1;;-1:-1:-1;22063:2:1;22054:12;;;;20255;20222:1854;;;-1:-1:-1;22095:5:1;19474:2632;-1:-1:-1;;;;;;;19474:2632:1:o;22518:184::-;22588:6;22641:2;22629:9;22620:7;22616:23;22612:32;22609:52;;;22657:1;22654;22647:12;22609:52;-1:-1:-1;22680:16:1;;22518:184;-1:-1:-1;22518:184:1:o;23089:202::-;23156:6;23209:2;23197:9;23188:7;23184:23;23180:32;23177:52;;;23225:1;23222;23215:12;23177:52;23248:37;23275:9;23248:37;:::i;23296:220::-;23445:2;23434:9;23427:21;23408:4;23465:45;23506:2;23495:9;23491:18;23483:6;23465:45;:::i;23904:128::-;23971:9;;;23992:11;;;23989:37;;;24006:18;;:::i;24037:593::-;24259:4;-1:-1:-1;;;;;24369:2:1;24361:6;24357:15;24346:9;24339:34;24421:2;24413:6;24409:15;24404:2;24393:9;24389:18;24382:43;24461:6;24456:2;24445:9;24441:18;24434:34;24516:2;24508:6;24504:15;24499:2;24488:9;24484:18;24477:43;;24557:3;24551;24540:9;24536:19;24529:32;24578:46;24619:3;24608:9;24604:19;24596:6;24578:46;:::i;25360:160::-;25437:13;;25490:4;25479:16;;25469:27;;25459:55;;25510:1;25507;25500:12;25525:819;25625:6;25678:3;25666:9;25657:7;25653:23;25649:33;25646:53;;;25695:1;25692;25685:12;25646:53;25728:2;25722:9;25770:3;25762:6;25758:16;25840:6;25828:10;25825:22;25804:18;25792:10;25789:34;25786:62;25783:88;;;25851:18;;:::i;:::-;25887:2;25880:22;25924:16;;25969:1;25959:12;;25949:40;;25985:1;25982;25975:12;25949:40;25998:21;;26064:2;26049:18;;26043:25;26077:33;26043:25;26077:33;:::i;:::-;26138:2;26126:15;;26119:32;26184:47;26227:2;26212:18;;26184:47;:::i;:::-;26179:2;26171:6;26167:15;26160:72;26265:47;26308:2;26297:9;26293:18;26265:47;:::i;:::-;26260:2;26248:15;;26241:72;26252:6;25525:819;-1:-1:-1;;;25525:819:1:o;26349:184::-;26401:77;26398:1;26391:88;26498:4;26495:1;26488:15;26522:4;26519:1;26512:15;28265:287;28394:3;28432:6;28426:13;28448:66;28507:6;28502:3;28495:4;28487:6;28483:17;28448:66;:::i;:::-;28530:16;;;;;28265:287;-1:-1:-1;;28265:287:1:o;29647:785::-;29901:2;29913:21;;;29983:13;;29886:18;;;30005:22;;;29853:4;;30081;;30058:3;30043:19;;;30108:15;;;29853:4;30151:169;30165:6;30162:1;30159:13;30151:169;;;30226:13;;30214:26;;30260:12;;;;30295:15;;;;30187:1;30180:9;30151:169;;;-1:-1:-1;;;30356:18:1;;;30349:34;;;;-1:-1:-1;30414:2:1;30399:18;30392:34;30337:3;29647:785;-1:-1:-1;29647:785:1:o;30848:175::-;30885:3;30929:4;30922:5;30918:16;30958:4;30949:7;30946:17;30943:43;;30966:18;;:::i;:::-;31015:1;31002:15;;30848:175;-1:-1:-1;;30848:175:1:o;31028:621::-;31152:6;31160;31168;31176;31184;31192;31200;31253:3;31241:9;31232:7;31228:23;31224:33;31221:53;;;31270:1;31267;31260:12;31221:53;31299:9;31293:16;31283:26;;31349:2;31338:9;31334:18;31328:25;31318:35;;31393:2;31382:9;31378:18;31372:25;31362:35;;31437:2;31426:9;31422:18;31416:25;31406:35;;31481:3;31470:9;31466:19;31460:26;31450:36;;31526:3;31515:9;31511:19;31505:26;31495:36;;31574:3;31563:9;31559:19;31553:26;31588:31;31613:5;31588:31;:::i;:::-;31638:5;31628:15;;;31028:621;;;;;;;;;;:::o;31654:184::-;31706:77;31703:1;31696:88;31803:4;31800:1;31793:15;31827:4;31824:1;31817:15","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"count","type":"uint256"}],"name":"ArrayLengthInvalid","type":"error"},{"inputs":[],"name":"DeadlineExceeded","type":"error"},{"inputs":[],"name":"InsufficientOutputAmount","type":"error"},{"inputs":[],"name":"MsgValueIncorrect","type":"error"},{"inputs":[],"name":"PoolNotFound","type":"error"},{"inputs":[],"name":"SynapseRouterV2__ModuleExists","type":"error"},{"inputs":[],"name":"SynapseRouterV2__ModuleInvalid","type":"error"},{"inputs":[],"name":"SynapseRouterV2__ModuleNotExists","type":"error"},{"inputs":[],"name":"SynapseRouterV2__QueryEmpty","type":"error"},{"inputs":[],"name":"TokenAddressMismatch","type":"error"},{"inputs":[],"name":"TokenNotContract","type":"error"},{"inputs":[],"name":"TokenNotETH","type":"error"},{"inputs":[],"name":"TokensIdentical","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"bridgeModule","type":"address"}],"name":"ModuleConnected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"name":"ModuleDisconnected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"oldBridgeModule","type":"address"},{"indexed":false,"internalType":"address","name":"newBridgeModule","type":"address"}],"name":"ModuleUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"oldSwapQuoter","type":"address"},{"indexed":false,"internalType":"address","name":"newSwapQuoter","type":"address"}],"name":"QuoterSet","type":"event"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"name":"adapterSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"originQuery","type":"tuple"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"destQuery","type":"tuple"}],"name":"bridgeViaSynapse","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"internalType":"address","name":"bridgeModule","type":"address"}],"name":"connectBridgeModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"name":"disconnectBridgeModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"internalType":"struct DestRequest","name":"request","type":"tuple"},{"internalType":"address","name":"tokenOut","type":"address"}],"name":"getDestinationAmountOut","outputs":[{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"destQuery","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOut","type":"address"}],"name":"getDestinationBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"destTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"string","name":"tokenSymbol","type":"string"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"name":"getOriginAmountOut","outputs":[{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"originQuery","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"}],"name":"getOriginBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"originTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSupportedTokens","outputs":[{"internalType":"address[]","name":"supportedTokens","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"name":"idToModule","outputs":[{"internalType":"address","name":"bridgeModule","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"bridgeModule","type":"address"}],"name":"moduleToId","outputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"setAllowance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ISwapQuoterV2","name":"_swapQuoter","type":"address"}],"name":"setSwapQuoter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"components":[{"internalType":"address","name":"routerAdapter","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"rawParams","type":"bytes"}],"internalType":"struct SwapQuery","name":"query","type":"tuple"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"swapQuoter","outputs":[{"internalType":"contract ISwapQuoterV2","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"moduleId","type":"bytes32"},{"internalType":"address","name":"bridgeModule","type":"address"}],"name":"updateBridgeModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}],"userDoc":{"kind":"user","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"notice":"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient."},"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))":{"notice":"Initiate a bridge transaction with an optional swap on both origin and destination chains."},"connectBridgeModule(bytes32,address)":{"notice":"Whitelists a new bridge module for users to route through"},"disconnectBridgeModule(bytes32)":{"notice":"Disconnects a whitelisted bridge module"},"getBridgeTokens()":{"notice":"Gets all bridge tokens for supported bridge modules"},"getDestinationAmountOut((string,uint256),address)":{"notice":"Finds the best path between every supported bridge token from the given list and `tokenOut`, treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token."},"getDestinationBridgeTokens(address)":{"notice":"Gets the list of all bridge tokens (and their symbols), such that destination swap from a bridge token to `tokenOut` is possible."},"getOriginAmountOut(address,string,uint256)":{"notice":"Finds the best path between `tokenIn` and every supported bridge token from the given list, treating the swap as \"origin swap\", without putting any restrictions on the swap."},"getOriginBridgeTokens(address)":{"notice":"Gets the list of all bridge tokens (and their symbols), such that origin swap from `tokenIn` to a bridge token is possible."},"getSupportedTokens()":{"notice":"Gets the list of all tokens that can be swapped into bridge tokens on this chain."},"idToModule(bytes32)":{"notice":"Gets the address associated with the given bridge module ID"},"moduleToId(address)":{"notice":"Gets the module ID associated with the given bridge module address"},"setAllowance(address,address,uint256)":{"notice":"Sets a custom allowance for the given token."},"setSwapQuoter(address)":{"notice":"Sets the Swap Quoter address to get the swap quotes from."},"swap(address,address,uint256,(address,address,uint256,uint256,bytes))":{"notice":"Perform a swap using the supplied parameters."},"swapQuoter()":{"notice":"swap quoter"},"updateBridgeModule(bytes32,address)":{"notice":"Updates a whitelisted bridge module"}},"version":1},"developerDoc":{"kind":"dev","methods":{"adapterSwap(address,address,uint256,address,bytes)":{"details":"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.","params":{"amountIn":"Amount of tokens to sell","rawParams":"Additional swap parameters","recipient":"Address to receive the swapped token","tokenIn":"Token to sell (use ETH_ADDRESS to start from native ETH)","tokenOut":"Token to buy (use ETH_ADDRESS to end with native ETH)"},"returns":{"amountOut":"  Amount of bought tokens"}},"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))":{"details":"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens. `token` is always a token user is sending. In case token requires a wrapper token to be bridge, use underlying address for `token` instead of the wrapper one. `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut should always use the underlying address. In other words, the concept of wrapper token is fully abstracted away from the end user. `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut(). Alternatively one could use an external adapter for more complex swaps on the origin chain. `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut(). Complex swaps on destination chain are not supported for the time being. Check contract description above for more details.","params":{"amount":"Amount of the initial tokens for the bridge transaction","chainId":"Destination chain id","destQuery":"Destination swap query. Empty struct indicates no swap is required","moduleId":"Bridge module id to delegate bridge call","originQuery":"Origin swap query. Empty struct indicates no swap is required","to":"Address to receive tokens on destination chain","token":"Initial token for the bridge transaction to be pulled from the user"}},"connectBridgeModule(bytes32,address)":{"details":"Reverts if not router owner","params":{"bridgeModule":"Bridge module address","moduleId":"Unique bridge module ID"}},"disconnectBridgeModule(bytes32)":{"details":"Reverts if not router owner","params":{"moduleId":"Unique bridge module ID"}},"getBridgeTokens()":{"details":"Intended for off-chain queries.","returns":{"_0":"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address"}},"getDestinationAmountOut((string,uint256),address)":{"details":"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap. For the time being, only swaps through the Synapse-supported pools are available on destination chain.","params":{"request":"Struct with following information:                 - symbol: unique token ID consistent among all chains                 - amountIn: amount of bridge token to start with, before the bridge fee is applied","tokenOut":"Token user wants to receive on destination chain"},"returns":{"destQuery":" Structs that could be used as `destQuery` in SynapseRouter.                      minAmountOut and deadline fields will need to be adjusted based on the user settings."}},"getDestinationBridgeTokens(address)":{"details":"Intended for off-chain queries.","params":{"tokenOut":"Token address to swap to on destination chain"},"returns":{"destTokens":"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address"}},"getOriginAmountOut(address,string,uint256)":{"details":"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported. The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter. Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.","params":{"amountIn":"Amount of tokens user wants to bridge/swap","tokenIn":"Initial token that user wants to bridge/swap","tokenSymbol":"Symbol representing bridge tokens"},"returns":{"originQuery":"   Structs that could be used as `originQuery` in SynapseRouter.                          minAmountOut and deadline fields will need to be adjusted based on the user settings."}},"getOriginBridgeTokens(address)":{"details":"Intended for off-chain queries.","params":{"tokenIn":"Token address to swap from on origin chain"},"returns":{"originTokens":"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address"}},"getSupportedTokens()":{"details":"Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.Intended for off-chain queries.","returns":{"supportedTokens":"Supported token addresses that can be swapped for bridge tokens"}},"idToModule(bytes32)":{"params":{"moduleId":"Unique bridge module ID"},"returns":{"bridgeModule":"Bridge module address"}},"moduleToId(address)":{"params":{"bridgeModule":"Bridge module address"},"returns":{"moduleId":"Unique bridge module ID"}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setAllowance(address,address,uint256)":{"details":"Reverts if not router owner. To be used for the wrapper token setups."},"setSwapQuoter(address)":{"params":{"_swapQuoter":"Swap Quoter"}},"swap(address,address,uint256,(address,address,uint256,uint256,bytes))":{"details":"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If query.tokenOut is ERC20, the tokens will be transferred to the recipient.","params":{"amount":"Amount of tokens to swap","query":"Query with the swap parameters (see BridgeStructs.sol)","to":"Address to receive swapped tokens","token":"Token to swap"},"returns":{"amountOut":"   Amount of swapped tokens received by the user"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateBridgeModule(bytes32,address)":{"details":"Reverts if not router owner","params":{"bridgeModule":"New bridge module address to update to","moduleId":"Unique bridge module ID"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ArrayLengthInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeadlineExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MsgValueIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseRouterV2__ModuleExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseRouterV2__ModuleInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseRouterV2__ModuleNotExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseRouterV2__QueryEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAddressMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokensIdentical\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"ModuleConnected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"ModuleDisconnected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldBridgeModule\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBridgeModule\",\"type\":\"address\"}],\"name\":\"ModuleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldSwapQuoter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSwapQuoter\",\"type\":\"address\"}],\"name\":\"QuoterSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"name\":\"adapterSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"destQuery\",\"type\":\"tuple\"}],\"name\":\"bridgeViaSynapse\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"connectBridgeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"disconnectBridgeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct DestRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getDestinationAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"destQuery\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getDestinationBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"destTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getOriginAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getOriginBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"originTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"supportedTokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"idToModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"moduleToId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapQuoterV2\",\"name\":\"_swapQuoter\",\"type\":\"address\"}],\"name\":\"setSwapQuoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"query\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapQuoter\",\"outputs\":[{\"internalType\":\"contract ISwapQuoterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"bridgeModule\",\"type\":\"address\"}],\"name\":\"updateBridgeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"details\":\"Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions. On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient. Swap deadline and slippage is checked outside of this contract.\",\"params\":{\"amountIn\":\"Amount of tokens to sell\",\"rawParams\":\"Additional swap parameters\",\"recipient\":\"Address to receive the swapped token\",\"tokenIn\":\"Token to sell (use ETH_ADDRESS to start from native ETH)\",\"tokenOut\":\"Token to buy (use ETH_ADDRESS to end with native ETH)\"},\"returns\":{\"amountOut\":\"  Amount of bought tokens\"}},\"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))\":{\"details\":\"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens. `token` is always a token user is sending. In case token requires a wrapper token to be bridge, use underlying address for `token` instead of the wrapper one. `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut should always use the underlying address. In other words, the concept of wrapper token is fully abstracted away from the end user. `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut(). Alternatively one could use an external adapter for more complex swaps on the origin chain. `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut(). Complex swaps on destination chain are not supported for the time being. Check contract description above for more details.\",\"params\":{\"amount\":\"Amount of the initial tokens for the bridge transaction\",\"chainId\":\"Destination chain id\",\"destQuery\":\"Destination swap query. Empty struct indicates no swap is required\",\"moduleId\":\"Bridge module id to delegate bridge call\",\"originQuery\":\"Origin swap query. Empty struct indicates no swap is required\",\"to\":\"Address to receive tokens on destination chain\",\"token\":\"Initial token for the bridge transaction to be pulled from the user\"}},\"connectBridgeModule(bytes32,address)\":{\"details\":\"Reverts if not router owner\",\"params\":{\"bridgeModule\":\"Bridge module address\",\"moduleId\":\"Unique bridge module ID\"}},\"disconnectBridgeModule(bytes32)\":{\"details\":\"Reverts if not router owner\",\"params\":{\"moduleId\":\"Unique bridge module ID\"}},\"getBridgeTokens()\":{\"details\":\"Intended for off-chain queries.\",\"returns\":{\"_0\":\"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address\"}},\"getDestinationAmountOut((string,uint256),address)\":{\"details\":\"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap. For the time being, only swaps through the Synapse-supported pools are available on destination chain.\",\"params\":{\"request\":\"Struct with following information:                 - symbol: unique token ID consistent among all chains                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\",\"tokenOut\":\"Token user wants to receive on destination chain\"},\"returns\":{\"destQuery\":\" Structs that could be used as `destQuery` in SynapseRouter.                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\"}},\"getDestinationBridgeTokens(address)\":{\"details\":\"Intended for off-chain queries.\",\"params\":{\"tokenOut\":\"Token address to swap to on destination chain\"},\"returns\":{\"destTokens\":\"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address\"}},\"getOriginAmountOut(address,string,uint256)\":{\"details\":\"Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol. Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported. The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter. Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\",\"params\":{\"amountIn\":\"Amount of tokens user wants to bridge/swap\",\"tokenIn\":\"Initial token that user wants to bridge/swap\",\"tokenSymbol\":\"Symbol representing bridge tokens\"},\"returns\":{\"originQuery\":\"   Structs that could be used as `originQuery` in SynapseRouter.                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\"}},\"getOriginBridgeTokens(address)\":{\"details\":\"Intended for off-chain queries.\",\"params\":{\"tokenIn\":\"Token address to swap from on origin chain\"},\"returns\":{\"originTokens\":\"List of structs with following information:                  - symbol: unique token ID consistent among all chains                  - token: bridge token address\"}},\"getSupportedTokens()\":{\"details\":\"Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.Intended for off-chain queries.\",\"returns\":{\"supportedTokens\":\"Supported token addresses that can be swapped for bridge tokens\"}},\"idToModule(bytes32)\":{\"params\":{\"moduleId\":\"Unique bridge module ID\"},\"returns\":{\"bridgeModule\":\"Bridge module address\"}},\"moduleToId(address)\":{\"params\":{\"bridgeModule\":\"Bridge module address\"},\"returns\":{\"moduleId\":\"Unique bridge module ID\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setAllowance(address,address,uint256)\":{\"details\":\"Reverts if not router owner. To be used for the wrapper token setups.\"},\"setSwapQuoter(address)\":{\"params\":{\"_swapQuoter\":\"Swap Quoter\"}},\"swap(address,address,uint256,(address,address,uint256,uint256,bytes))\":{\"details\":\"Note that method is payable. If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`). Make sure to approve this contract for spending `token` beforehand. If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\",\"params\":{\"amount\":\"Amount of tokens to swap\",\"query\":\"Query with the swap parameters (see BridgeStructs.sol)\",\"to\":\"Address to receive swapped tokens\",\"token\":\"Token to swap\"},\"returns\":{\"amountOut\":\"   Amount of swapped tokens received by the user\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateBridgeModule(bytes32,address)\":{\"details\":\"Reverts if not router owner\",\"params\":{\"bridgeModule\":\"New bridge module address to update to\",\"moduleId\":\"Unique bridge module ID\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"adapterSwap(address,address,uint256,address,bytes)\":{\"notice\":\"Performs a tokenIn -\u003e tokenOut swap, according to the provided params. If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`. If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`). If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy). If tokenOut is ERC20, the tokens will be transferred to the recipient.\"},\"bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))\":{\"notice\":\"Initiate a bridge transaction with an optional swap on both origin and destination chains.\"},\"connectBridgeModule(bytes32,address)\":{\"notice\":\"Whitelists a new bridge module for users to route through\"},\"disconnectBridgeModule(bytes32)\":{\"notice\":\"Disconnects a whitelisted bridge module\"},\"getBridgeTokens()\":{\"notice\":\"Gets all bridge tokens for supported bridge modules\"},\"getDestinationAmountOut((string,uint256),address)\":{\"notice\":\"Finds the best path between every supported bridge token from the given list and `tokenOut`, treating the swap as \\\"destination swap\\\", limiting possible actions to those available for every bridge token.\"},\"getDestinationBridgeTokens(address)\":{\"notice\":\"Gets the list of all bridge tokens (and their symbols), such that destination swap from a bridge token to `tokenOut` is possible.\"},\"getOriginAmountOut(address,string,uint256)\":{\"notice\":\"Finds the best path between `tokenIn` and every supported bridge token from the given list, treating the swap as \\\"origin swap\\\", without putting any restrictions on the swap.\"},\"getOriginBridgeTokens(address)\":{\"notice\":\"Gets the list of all bridge tokens (and their symbols), such that origin swap from `tokenIn` to a bridge token is possible.\"},\"getSupportedTokens()\":{\"notice\":\"Gets the list of all tokens that can be swapped into bridge tokens on this chain.\"},\"idToModule(bytes32)\":{\"notice\":\"Gets the address associated with the given bridge module ID\"},\"moduleToId(address)\":{\"notice\":\"Gets the module ID associated with the given bridge module address\"},\"setAllowance(address,address,uint256)\":{\"notice\":\"Sets a custom allowance for the given token.\"},\"setSwapQuoter(address)\":{\"notice\":\"Sets the Swap Quoter address to get the swap quotes from.\"},\"swap(address,address,uint256,(address,address,uint256,uint256,bytes))\":{\"notice\":\"Perform a swap using the supplied parameters.\"},\"swapQuoter()\":{\"notice\":\"swap quoter\"},\"updateBridgeModule(bytes32,address)\":{\"notice\":\"Updates a whitelisted bridge module\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"SynapseRouterV2\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{"adapterSwap(address,address,uint256,address,bytes)":"24a98f11","bridgeViaSynapse(address,uint256,bytes32,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))":"c95fafd2","connectBridgeModule(bytes32,address)":"b3bce952","disconnectBridgeModule(bytes32)":"b68e4302","getBridgeTokens()":"9c1d060e","getDestinationAmountOut((string,uint256),address)":"7de31c74","getDestinationBridgeTokens(address)":"1d04879b","getOriginAmountOut(address,string,uint256)":"f533941d","getOriginBridgeTokens(address)":"3e811a5c","getSupportedTokens()":"d3c7c2c7","idToModule(bytes32)":"53e2e8e7","moduleToId(address)":"9f2671fa","owner()":"8da5cb5b","renounceOwnership()":"715018a6","setAllowance(address,address,uint256)":"da46098c","setSwapQuoter(address)":"804b3dff","swap(address,address,uint256,(address,address,uint256,uint256,bytes))":"b5d1cdd4","swapQuoter()":"34474c8c","transferOwnership(address)":"f2fde38b","updateBridgeModule(bytes32,address)":"70a1cdc9"}},"solidity/SynapseRouterV2.sol:UniversalTokenLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206119c53f4972e8f550594d951a759848cc63d2318cea815ea66ab7477769324964736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206119c53f4972e8f550594d951a759848cc63d2318cea815ea66ab7477769324964736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.17 \u003e=0.8.13 ^0.8.0 ^0.8.1;\n\n// contracts/router/interfaces/IDefaultPool.sol\n\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\n// contracts/router/interfaces/IRouterAdapter.sol\n\ninterface IRouterAdapter {\n    /// @notice Performs a tokenIn -\u003e tokenOut swap, according to the provided params.\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\n    /// Swap deadline and slippage is checked outside of this contract.\n    /// @param recipient    Address to receive the swapped token\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\n    /// @param amountIn     Amount of tokens to sell\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\n    /// @param rawParams    Additional swap parameters\n    /// @return amountOut   Amount of bought tokens\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes calldata rawParams\n    ) external payable returns (uint256 amountOut);\n}\n\n// contracts/router/interfaces/IWETH9.sol\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// contracts/router/libs/Errors.sol\n\n    error DeadlineExceeded();\n    error InsufficientOutputAmount();\n\n    error MsgValueIncorrect();\n    error PoolNotFound();\n    error TokenAddressMismatch();\n    error TokenNotContract();\n    error TokenNotETH();\n    error TokensIdentical();\n\n// contracts/router/libs/Structs.sol\n\n// \"using A for B global\" requires 0.8.13 or higher\n\n// ══════════════════════════════════════════ TOKEN AND POOL DESCRIPTION ═══════════════════════════════════════════════\n\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param token    Bridge token address\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n/// @notice Struct used by IPoolHandler to represent a token in a pool\n/// @param index    Token index in the pool\n/// @param token    Token address\n    struct IndexedToken {\n        uint8 index;\n        address token;\n    }\n\n/// @notice Struct representing a token, and the available Actions for performing a swap.\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\n/// @param token        Token address\n    struct LimitedToken {\n        uint256 actionMask;\n        address token;\n    }\n\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\n/// @param isWeth   Whether the token represents Wrapped ETH.\n/// @param token    Token address.\n    struct PoolToken {\n        bool isWeth;\n        address token;\n    }\n\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\n/// @param pool         Pool address.\n/// @param lpToken      Address of pool's LP token.\n/// @param tokens       List of pool's tokens.\n    struct Pool {\n        address pool;\n        address lpToken;\n        PoolToken[] tokens;\n    }\n\n// ════════════════════════════════════════════════ ROUTER STRUCTS ═════════════════════════════════════════════════════\n\n/// @notice Struct representing a quote request for swapping a bridge token.\n/// Used in destination chain's SynapseRouter, hence the name \"Destination Request\".\n/// @dev tokenOut is passed externally.\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n/// @notice Struct representing a swap request for SynapseRouter.\n/// @dev tokenIn is supplied separately.\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \"no swap\" query.\n/// @param tokenOut         Token address to swap to.\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\n///                         Should be DefaultParams for swaps via DefaultAdapter.\n    struct SwapQuery {\n        address routerAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    using SwapQueryLib for SwapQuery global;\n\nlibrary SwapQueryLib {\n    /// @notice Checks whether the router adapter was specified in the query.\n    /// Query without a router adapter specifies that no action needs to be taken.\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\n        return query.routerAdapter != address(0);\n    }\n\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\n    /// and if a path for this action was found.\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\n        // Fill the fields only if some path was found.\n        if (query.minAmountOut == 0) return;\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\n        // Set default deadline to infinity. Not using the value of 0,\n        // which would lead to every swap to revert by default.\n        query.deadline = type(uint256).max;\n    }\n}\n\n// ════════════════════════════════════════════════ ADAPTER STRUCTS ════════════════════════════════════════════════════\n\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\n/// @param action           Action that DefaultAdapter needs to perform.\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\n    struct DefaultParams {\n        Action action;\n        address pool;\n        uint8 tokenIndexFrom;\n        uint8 tokenIndexTo;\n    }\n\n/// @notice All possible actions that DefaultAdapter could perform.\n    enum Action {\n        Swap, // swap between two pools tokens\n        AddLiquidity, // add liquidity in a form of a single pool token\n        RemoveLiquidity, // remove liquidity in a form of a single pool token\n        HandleEth // ETH \u003c\u003e WETH interaction\n    }\n\n    using ActionLib for Action global;\n\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\nlibrary ActionLib {\n    /// @notice Returns a bitmask with all possible actions set to True.\n    function allActions() internal pure returns (uint256 actionMask) {\n        actionMask = type(uint256).max;\n    }\n\n    /// @notice Returns whether the given action is set to True in the bitmask.\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\n        return actionMask \u0026 mask(action) != 0;\n    }\n\n    /// @notice Returns a bitmask with only the given action set to True.\n    function mask(Action action) internal pure returns (uint256) {\n        return 1 \u003c\u003c uint256(action);\n    }\n\n    /// @notice Returns a bitmask with only two given actions set to True.\n    function mask(Action a, Action b) internal pure returns (uint256) {\n        return mask(a) | mask(b);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/router/interfaces/IBridgeModule.sol\n\ninterface IBridgeModule {\n    /// @notice Performs a bridging transaction on behalf of the sender, assuming they already have `token`.\n    /// @dev This will be used via delegatecall from SynapseRouterV2, which will have custody over the bridge tokens.\n    /// This will revert if delegatecall is not used.\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param token         Address of the bridge token\n    /// @param amount        Amount of the tokens for the bridge transaction\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function delegateBridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Gets the maximum amount of tokens user can bridge from this chain.\n    /// @param token        Address of the bridge token\n    /// @return amount      Max amount of tokens user can bridge from this chain\n    function getMaxBridgedAmount(address token) external view returns (uint256 amount);\n\n    /// @notice Calculates the fee amount for bridging a token to this chain.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @param amount       Amount of tokens to be bridged\n    /// @param isSwap       Whether the user provided swap details for converting the bridge token\n    ///                     to the final token on this chain\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee);\n\n    /// @notice Returns the list of all supported bridge tokens and their bridge symbols.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @return bridgeTokens Supported bridge tokens and their bridge symbols\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Returns the address of the bridge token for a given bridge symbol.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return address(0) if the token is not supported.\n    /// @param symbol       Symbol of the supported bridge token used by the token's bridge\n    /// @return token       Address of the bridge token\n    function symbolToToken(string memory symbol) external view returns (address token);\n\n    /// @notice Returns the bridge symbol of a given bridge token.\n    /// - Bridge symbol is consistent across all chains for a given token and their bridge.\n    /// - Bridge symbol doesn't have to be the same as the token symbol on this chain.\n    /// @dev Will return empty string if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return symbol      Symbol of the supported bridge token used by the token's bridge\n    function tokenToSymbol(address token) external view returns (string memory symbol);\n\n    /// @notice Returns the action mask associated with bridging a token to this chain.\n    /// Action mask is a bitmask of the actions that could be performed with the token atomically with the\n    /// incoming bridge transaction to this chain. See Structs.sol for the list of actions.\n    /// @dev Will return 0 (empty mask) if the token is not supported.\n    /// @param token        Address of the bridge token\n    /// @return actionMask  Action mask for the bridge token\n    function tokenToActionMask(address token) external view returns (uint256 actionMask);\n}\n\n// contracts/router/interfaces/IDefaultExtendedPool.sol\n\ninterface IDefaultExtendedPool is IDefaultPool {\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function swapStorage()\n    external\n    view\n    returns (\n        uint256 initialA,\n        uint256 futureA,\n        uint256 initialATime,\n        uint256 futureATime,\n        uint256 swapFee,\n        uint256 adminFee,\n        address lpToken\n    );\n}\n\n// contracts/router/interfaces/ISwapQuoterV1.sol\n\n/// @notice Interface for the SwapQuoterV1 version with updated pragma and enriched docs.\ninterface ISwapQuoterV1 {\n    // ════════════════════════════════════════════════ IMMUTABLES ════════════════════════════════════════════════════\n\n    /// @notice Address of deployed calculator contract for DefaultPool, which is able to calculate\n    /// EXACT quotes for AddLiquidity action (something that DefaultPool contract itself is unable to do).\n    function defaultPoolCalc() external view returns (address);\n\n    /// @notice Address of WETH token used in the pools. Represents wrapped version of chain's native currency,\n    /// e.g. WETH on Ethereum, WBNB on BSC, etc.\n    function weth() external view returns (address);\n\n    // ═══════════════════════════════════════════════ POOL GETTERS ════════════════════════════════════════════════════\n\n    /// @notice Returns a list of all supported pools.\n    function allPools() external view returns (Pool[] memory pools);\n\n    /// @notice Returns the amount of supported pools.\n    function poolsAmount() external view returns (uint256 amtPools);\n\n    /// @notice Returns the number of tokens the given pool supports and the pool's LP token.\n    function poolInfo(address pool) external view returns (uint256 numTokens, address lpToken);\n\n    /// @notice Returns a list of pool tokens for the given pool.\n    function poolTokens(address pool) external view returns (PoolToken[] memory tokens);\n\n    // ══════════════════════════════════════════════ GENERAL QUOTES ═══════════════════════════════════════════════════\n\n    /// @notice Checks if a swap is possible between every bridge token in the given list and tokenOut.\n    /// Only the bridge token's whitelisted pool is considered for every `tokenIn -\u003e tokenOut` swap.\n    /// @param bridgeTokensIn   List of structs with following information:\n    ///                         - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                         - token         Bridge token address to swap from\n    /// @param tokenOut         Token address to swap to\n    /// @return amountFound     Amount of tokens from the list that are swappable to tokenOut\n    /// @return isConnected     List of bool values, specifying whether a token from the list is swappable to tokenOut\n    function findConnectedTokens(LimitedToken[] memory bridgeTokensIn, address tokenOut)\n    external\n    view\n    returns (uint256 amountFound, bool[] memory isConnected);\n\n    /// @notice Finds the quote and the swap parameters for a tokenIn -\u003e tokenOut swap from the list of supported pools.\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    /// \u003e Returns the `SwapQuery` struct, that can be used on SynapseRouter.\n    /// \u003e minAmountOut and deadline fields will need to be adjusted based on the swap settings.\n    /// @dev If tokenIn or tokenOut is ETH_ADDRESS, only the pools having WETH as a pool token will be considered.\n    /// Three potential outcomes are available:\n    /// 1. `tokenIn` and `tokenOut` represent the same token address (identical tokens).\n    /// 2. `tokenIn` and `tokenOut` represent different addresses. No trade path from `tokenIn` to `tokenOut` is found.\n    /// 3. `tokenIn` and `tokenOut` represent different addresses. Trade path from `tokenIn` to `tokenOut` is found.\n    /// The exact composition of the returned struct for every case is documented in the return parameter documentation.\n    /// @param tokenIn  Struct with following information:\n    ///                 - actionMask    Bitmask of available actions for doing tokenIn -\u003e tokenOut\n    ///                 - token         Token address to swap from\n    /// @param tokenOut Token address to swap to\n    /// @param amountIn Amount of tokens to swap from\n    /// @return query   Struct representing trade path between tokenIn and tokenOut:\n    ///                 - swapAdapter: adapter address that would handle the swap. Address(0) if no path is found,\n    ///                 or tokens are identical. Address of SynapseRouter otherwise.\n    ///                 - tokenOut: always equals to the provided `tokenOut`, even if no path if found.\n    ///                 - minAmountOut: amount of `tokenOut`, if swap was completed now. 0, if no path is found.\n    ///                 - deadline: 2**256-1 if path was found, or tokens are identical. 0, if no path is found.\n    ///                 - rawParams: ABI-encoded DefaultParams struct indicating the swap parameters. Empty string,\n    ///                 if no path is found, or tokens are identical.\n    function getAmountOut(\n        LimitedToken memory tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory query);\n\n    // ═══════════════════════════════════════════ SPECIFIC POOL QUOTES ════════════════════════════════════════════════\n\n    /// @notice Returns the exact quote for adding liquidity to a given pool in a form of a single token.\n    /// @dev The only way to get a quote for adding liquidity would be `pool.calculateTokenAmount()`,\n    /// which gives an ESTIMATE: it doesn't take the trade fees into account.\n    /// We do need the exact quotes for (DAI/USDC/USDT) -\u003e nUSD \"swaps\" on Mainnet, hence we do this.\n    /// We also need the exact quotes for adding liquidity to the pools.\n    /// Note: the function might revert instead of returning 0 for incorrect requests. Make sure\n    /// to take that into account.\n    function calculateAddLiquidity(address pool, uint256[] memory amounts) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for swapping between two given tokens.\n    /// @dev Exposes IDefaultPool.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    function calculateSwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns the exact quote for withdrawing pools tokens in a balanced way.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidity(amount);\n    function calculateRemoveLiquidity(address pool, uint256 amount) external view returns (uint256[] memory amountsOut);\n\n    /// @notice Returns the exact quote for withdrawing a single pool token.\n    /// @dev Exposes IDefaultPool.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);\n    function calculateWithdrawOneToken(\n        address pool,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 amountOut);\n}\n\n// contracts/router/libs/Arrays.sol\n\n/// @notice Arrays library offers helper functions for working with arrays and array of arrays\nlibrary Arrays {\n    error ArrayLengthInvalid(uint256 count);\n\n    /// @notice Flattens out a list of lists of bridge tokens into a list of bridge tokens\n    /// @param unflattened The list of lists of bridge tokens\n    /// @param count The total number of bridge tokens in unflattened\n    /// @return flattened The flattened list of bridge tokens\n    function flatten(BridgeToken[][] memory unflattened, uint256 count)\n    internal\n    pure\n    returns (BridgeToken[] memory flattened)\n    {\n        flattened = new BridgeToken[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Flattens out a list of lists of addresses into a list of addresses\n    /// @param unflattened The list of lists of addresses\n    /// @param count The total number of addresses in unflattened\n    /// @return flattened The flattened list of addresses\n    function flatten(address[][] memory unflattened, uint256 count) internal pure returns (address[] memory flattened) {\n        flattened = new address[](count);\n\n        uint256 k;\n        for (uint256 i = 0; i \u003c unflattened.length; ++i) {\n            for (uint256 j = 0; j \u003c unflattened[i].length; ++j) {\n                flattened[k] = unflattened[i][j];\n                k++;\n            }\n        }\n\n        if (k != count) revert ArrayLengthInvalid(k); // @dev should never happen in practice w router\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token addresses\n    /// @param b The list of bridge tokens\n    /// @return t The list of token addresses associated with given bridge tokens\n    function tokens(BridgeToken[] memory b) internal pure returns (address[] memory t) {\n        t = new address[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) t[i] = b[i].token;\n    }\n\n    /// @notice Converts a list of bridge tokens to a list of their token symbols\n    /// @param b The list of bridge tokens\n    /// @return s The list of token symbols associated with given bridge tokens\n    function symbols(BridgeToken[] memory b) internal pure returns (string[] memory s) {\n        s = new string[](b.length);\n        for (uint256 i = 0; i \u003c b.length; ++i) s[i] = b[i].symbol;\n    }\n\n    /// @notice Filters out duplicates and zero addresses from given list of addresses\n    /// @dev Removes zero addresses from list\n    /// @param unfiltered The list of addresses with duplicates\n    /// @return filtered The list of addresses without duplicates\n    function unique(address[] memory unfiltered) internal pure returns (address[] memory filtered) {\n        address[] memory intermediate = new address[](unfiltered.length);\n\n        // add unique elements to intermediate\n        uint256 count;\n        for (uint256 i = 0; i \u003c unfiltered.length; ++i) {\n            address el = unfiltered[i];\n            if (!contains(intermediate, el)) {\n                intermediate[count] = el;\n                count++;\n            }\n        }\n\n        // remove the zero elements at the end if any duplicates\n        filtered = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            filtered[i] = intermediate[i];\n        }\n    }\n\n    /// @notice Whether given element is in the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to search for\n    /// @return does If given list does contain element\n    function contains(address[] memory l, address el) internal pure returns (bool does) {\n        for (uint256 j = 0; j \u003c l.length; ++j) {\n            does = (el == l[j]);\n            if (does) break;\n        }\n    }\n\n    /// @notice Appends a new element to the end of the list of addresses\n    /// @param l The list of addresses\n    /// @param el The element to append\n    /// @param r The new list of addresses with appended element\n    function append(address[] memory l, address el) internal pure returns (address[] memory r) {\n        r = new address[](l.length + 1);\n        for (uint256 i = 0; i \u003c l.length; i++) r[i] = l[i];\n        r[r.length - 1] = el;\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/utils/structs/EnumerableMap.sol\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableMap.sol)\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -\u003e address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 =\u003e bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\n// contracts/router/interfaces/ISwapQuoterV2.sol\n\ninterface ISwapQuoterV2 is ISwapQuoterV1 {\n    /// @notice Checks if tokenIn -\u003e tokenOut swap is possible using the supported pools.\n    /// Follows `getAmountOut()` convention when it comes to providing tokenIn.actionMask:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// `tokenIn.actionMask` needs to be set to bitmask of all possible actions (ActionLib.allActions()).\n    ///  For this case, all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// `tokenIn.actionMask` needs to be set to bitmask of possible actions for `tokenIn.token` as a bridge token,\n    /// e.g. Action.Swap for minted tokens, or Action.RemoveLiquidity | Action.HandleEth for withdrawn tokens.\n    ///\n    /// As for the pools considered for the swap, there are two cases:\n    /// - If this is a request for the swap to be performed immediately (or the \"origin swap\" in the bridge workflow),\n    /// all pools added to SwapQuoterV2 will be considered for the swap.\n    /// - If this is a request for the swap to be performed as the \"destination swap\" in the bridge workflow,\n    /// only the whitelisted pool for tokenIn.token will be considered for the swap.\n    function areConnectedTokens(LimitedToken memory tokenIn, address tokenOut) external view returns (bool);\n\n    /// @notice Allows to set the SynapseRouter contract, which is used as \"Router Adapter\" for doing\n    /// swaps through Default Pools (or handling ETH).\n    /// Note: this will not affect the old SynapseRouter contract which still uses this Quoter, as the old SynapseRouter\n    /// could handle the requests with the new SynapseRouter as external \"Router Adapter\".\n    function setSynapseRouter(address synapseRouter_) external;\n}\n\n// node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// contracts/router/interfaces/IRouterV2.sol\n\ninterface IRouterV2 {\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    /// `token` is always a token user is sending. In case token requires a wrapper token to be bridge,\n    /// use underlying address for `token` instead of the wrapper one.\n    ///\n    /// `originQuery` contains instructions for the swap on origin chain. As above, originQuery.tokenOut\n    /// should always use the underlying address. In other words, the concept of wrapper token is fully\n    /// abstracted away from the end user.\n    ///\n    /// `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    /// `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    /// Complex swaps on destination chain are not supported for the time being.\n    /// Check contract description above for more details.\n    ///\n    /// @param to            Address to receive tokens on destination chain\n    /// @param chainId       Destination chain id\n    /// @param moduleId      Bridge module id to delegate bridge call\n    /// @param token         Initial token for the bridge transaction to be pulled from the user\n    /// @param amount        Amount of the initial tokens for the bridge transaction\n    /// @param originQuery   Origin swap query. Empty struct indicates no swap is required\n    /// @param destQuery     Destination swap query. Empty struct indicates no swap is required\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Perform a swap using the supplied parameters.\n    /// @dev Note that method is payable.\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    /// Make sure to approve this contract for spending `token` beforehand.\n    /// If query.tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\n    /// If query.tokenOut is ERC20, the tokens will be transferred to the recipient.\n    /// @param to            Address to receive swapped tokens\n    /// @param token         Token to swap\n    /// @param amount        Amount of tokens to swap\n    /// @param query         Query with the swap parameters (see BridgeStructs.sol)\n    /// @return amountOut    Amount of swapped tokens received by the user\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Sets the Swap Quoter address to get the swap quotes from.\n    /// @param _swapQuoter Swap Quoter\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external;\n\n    /// @notice Sets a custom allowance for the given token.\n    /// @dev Reverts if not router owner. To be used for the wrapper token setups.\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /// @notice Whitelists a new bridge module for users to route through\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule Bridge module address\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Updates a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    /// @param bridgeModule New bridge module address to update to\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external;\n\n    /// @notice Disconnects a whitelisted bridge module\n    /// @dev Reverts if not router owner\n    /// @param moduleId Unique bridge module ID\n    function disconnectBridgeModule(bytes32 moduleId) external;\n\n    /// @notice Gets the address associated with the given bridge module ID\n    /// @param moduleId Unique bridge module ID\n    /// @return bridgeModule Bridge module address\n    function idToModule(bytes32 moduleId) external view returns (address bridgeModule);\n\n    /// @notice Gets the module ID associated with the given bridge module address\n    /// @param bridgeModule Bridge module address\n    /// @return moduleId Unique bridge module ID\n    function moduleToId(address bridgeModule) external view returns (bytes32 moduleId);\n\n    /// @notice Gets all bridge tokens for supported bridge modules\n    /// @dev Intended for off-chain queries.\n    /// @return bridgeTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\n    /// from a bridge token to `tokenOut` is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenOut  Token address to swap to on destination chain\n    /// @return destTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that origin swap\n    /// from `tokenIn` to a bridge token is possible.\n    /// @dev Intended for off-chain queries.\n    /// @param tokenIn  Token address to swap from on origin chain\n    /// @return originTokens List of structs with following information:\n    ///                  - symbol: unique token ID consistent among all chains\n    ///                  - token: bridge token address\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens);\n\n    /// @notice Gets the list of all tokens that can be swapped into bridge tokens on this chain.\n    /// @dev Supported tokens should include all bridge tokens and any pool tokens paired with a bridge token.\n    /// @dev Intended for off-chain queries.\n    /// @return supportedTokens Supported token addresses that can be swapped for bridge tokens\n    function getSupportedTokens() external view returns (address[] memory supportedTokens);\n\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\n    /// treating the swap as \"destination swap\", limiting possible actions to those available for every bridge token.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\n    /// @param request Struct with following information:\n    ///                 - symbol: unique token ID consistent among all chains\n    ///                 - amountIn: amount of bridge token to start with, before the bridge fee is applied\n    /// @param tokenOut  Token user wants to receive on destination chain\n    /// @return destQuery  Structs that could be used as `destQuery` in SynapseRouter.\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery);\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\n    /// treating the swap as \"origin swap\", without putting any restrictions on the swap.\n    /// @dev Intended for off-chain queries. Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\n    /// @param tokenIn       Initial token that user wants to bridge/swap\n    /// @param tokenSymbol  Symbol representing bridge tokens\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\n    /// @return originQuery    Structs that could be used as `originQuery` in SynapseRouter.\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery);\n}\n\n// contracts/router/libs/UniversalToken.sol\n\nlibrary UniversalTokenLib {\n    using SafeERC20 for IERC20;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\n    /// Make sure this can not lead to reentrancy attacks.\n    function universalTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // Don't do anything, if need to send tokens to this address\n        if (to == address(this)) return;\n        if (token == ETH_ADDRESS) {\n            /// @dev Note: this can potentially lead to executing code in `to`.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: value}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else {\n            IERC20(token).safeTransfer(to, value);\n        }\n    }\n\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\n    /// to spend the given amount.\n    function universalApproveInfinity(\n        address token,\n        address spender,\n        uint256 amountToSpend\n    ) internal {\n        // ETH Chad doesn't require your approval\n        if (token == ETH_ADDRESS) return;\n        // No-op if allowance is already sufficient\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003e= amountToSpend) return;\n        // Otherwise, reset approval to 0 and set to max allowance\n        if (allowance \u003e 0) IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH_ADDRESS) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\n    function assertIsContract(address token) internal view {\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\n        // Check that token is not an EOA\n        if (token.code.length == 0) revert TokenNotContract();\n    }\n}\n\n// contracts/router/adapters/DefaultAdapter.sol\n\ncontract DefaultAdapter is IRouterAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\n    receive() external payable {}\n\n    /// @inheritdoc IRouterAdapter\n    function adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) external payable returns (uint256 amountOut) {\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\n    }\n\n    /// @dev Internal logic for doing a tokenIn -\u003e tokenOut swap.\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\n    function _adapterSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal virtual returns (uint256 amountOut) {\n        // We define a few phases for the whole Adapter's swap process.\n        // (?) means the phase is optional.\n        // (!) means the phase is mandatory.\n\n        // PHASE 0(!): CHECK ALL THE PARAMS\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\n\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\n\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\n        // We need to perform tokenIn -\u003e tokenSwapTo action in PHASE 3.\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\n        // Recipient will receive `tokenOut` in PHASE 5.\n\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\n\n        // PHASE 4(?): UNWRAP SWAPPED WETH\n        // Check if the final token is native ETH\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\n            _unwrapETH(tokenSwapTo, amountOut);\n        }\n\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\n        // Note: this is a no-op if recipient == address(this)\n        tokenOut.universalTransfer(recipient, amountOut);\n    }\n\n    /// @dev Checks the params and decodes them into a struct.\n    function _checkParams(\n        address tokenIn,\n        address tokenOut,\n        bytes memory rawParams\n    ) internal pure returns (DefaultParams memory params) {\n        if (tokenIn == tokenOut) revert TokensIdentical();\n        // Decode params for swapping via a Default pool\n        params = abi.decode(rawParams, (DefaultParams));\n        // Swap pool should exist, if action other than HandleEth was requested\n        if (params.pool == address(0) \u0026\u0026 params.action != Action.HandleEth) revert PoolNotFound();\n    }\n\n    /// @dev Wraps native ETH into WETH, if requested.\n    /// Returns the address of the token this contract ends up with.\n    function _wrapReceivedETH(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal returns (address wrappedTokenIn) {\n        // tokenIn was already transferred to this contract, check if we start from native ETH\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\n            // Wrap ETH into WETH and leave it in this contract\n            _wrapETH(wrappedTokenIn, amountIn);\n        } else {\n            wrappedTokenIn = tokenIn;\n            // For ERC20 tokens msg.value should be zero\n            if (msg.value != 0) revert MsgValueIncorrect();\n        }\n    }\n\n    /// @dev Derives the address of token to be received after an action defined in `params`.\n    function _deriveTokenSwapTo(\n        address tokenIn,\n        address tokenOut,\n        DefaultParams memory params\n    ) internal view returns (address tokenSwapTo) {\n        // Check if swap to native ETH was requested\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\n        } else {\n            tokenSwapTo = tokenOut;\n        }\n    }\n\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\n    function _performPoolAction(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenSwapTo,\n        DefaultParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if we need to perform a swap\n        if (params.action == Action.HandleEth) {\n            // If no swap is required, amountOut doesn't change\n            amountOut = amountIn;\n        } else {\n            // Record balance before the swap\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\n            if (params.action == Action.Swap) {\n                _swap(params.pool, params, amountIn, tokenSwapTo);\n            } else if (params.action == Action.AddLiquidity) {\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            } else {\n                // The only remaining action is RemoveLiquidity\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\n            }\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\n        }\n    }\n\n    // ═══════════════════════════════════════ INTERNAL LOGIC: SWAP ACTIONS ════════════════════════════════════════════\n\n    /// @dev Performs a swap through the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _swap(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultPool(pool).swap({\n            tokenIndexFrom: params.tokenIndexFrom,\n            tokenIndexTo: params.tokenIndexTo,\n            dx: amountIn,\n            minDy: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    /// @dev Adds liquidity in a form of a single token to the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _addLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        address lpToken = _getPoolLPToken(pool);\n        // tokenOut should match the LP token\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\n        uint256[] memory amounts = new uint256[](numTokens);\n        amounts[params.tokenIndexFrom] = amountIn;\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\n    }\n\n    /// @dev Removes liquidity in a form of a single token from the given pool.\n    /// Note: The pool should be already approved for spending `tokenIn`.\n    function _removeLiquidity(\n        address pool,\n        DefaultParams memory params,\n        uint256 amountIn,\n        address tokenOut\n    ) internal {\n        // tokenOut should match the \"swap to\" token\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\n        // amountOut and deadline are not checked in RouterAdapter\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\n            tokenAmount: amountIn,\n            tokenIndex: params.tokenIndexTo,\n            minAmount: 0,\n            deadline: type(uint256).max\n        });\n    }\n\n    // ═════════════════════════════════════════ INTERNAL LOGIC: POOL LENS ═════════════════════════════════════════════\n\n    /// @dev Returns the LP token address of the given pool.\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\n    }\n\n    /// @dev Returns the number of tokens in the given pool.\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\n        // Iterate over all tokens in the pool until the end is reached\n        for (uint8 index = 0; ; ++index) {\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\n                // End of pool reached\n                numTokens = index;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the tokens in the given pool.\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\n        uint256 numTokens = _getPoolNumTokens(pool);\n        tokens = new address[](numTokens);\n        for (uint8 i = 0; i \u003c numTokens; ++i) {\n            // This will not revert because we already know the number of tokens in the pool\n            tokens[i] = IDefaultPool(pool).getToken(i);\n        }\n    }\n\n    /// @dev Returns the quote for a swap through the given pool.\n    /// Note: will return 0 on invalid swaps.\n    function _getPoolSwapQuote(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\n            amountOut = dy;\n        } catch {\n            // Return 0 instead of reverting\n            amountOut = 0;\n        }\n    }\n\n    // ════════════════════════════════════════ INTERNAL LOGIC: ETH \u003c\u003e WETH ════════════════════════════════════════════\n\n    /// @dev Wraps ETH into WETH.\n    function _wrapETH(address weth, uint256 amount) internal {\n        if (amount != msg.value) revert MsgValueIncorrect();\n        // Deposit in order to have WETH in this contract\n        IWETH9(weth).deposit{value: amount}();\n    }\n\n    /// @dev Unwraps WETH into ETH.\n    function _unwrapETH(address weth, uint256 amount) internal {\n        // Withdraw ETH to this contract\n        IWETH9(weth).withdraw(amount);\n    }\n\n    /// @dev Derives WETH address from swap parameters.\n    function _deriveWethAddress(\n        address token,\n        DefaultParams memory params,\n        bool isTokenFromWeth\n    ) internal view returns (address weth) {\n        if (params.action == Action.HandleEth) {\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\n            weth = token;\n        } else {\n            // Otherwise, we need to get WETH address from the liquidity pool\n            weth = address(\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\n            );\n        }\n    }\n}\n\n// contracts/router/DefaultRouter.sol\n\n/// @title DefaultRouter\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\n/// due to the fact that it inherits from DefaultAdapter.\nabstract contract DefaultRouter is DefaultAdapter {\n    using SafeERC20 for IERC20;\n    using UniversalTokenLib for address;\n\n    /// @dev Performs a \"swap from tokenIn\" following instructions from `query`.\n    /// `query` will include the router adapter to use, and the exact type of \"tokenIn -\u003e tokenOut swap\"\n    /// should be encoded in `query.rawParams`.\n    function _doSwap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        SwapQuery memory query\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // First, check the deadline for the swap\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp \u003e query.deadline) revert DeadlineExceeded();\n        // Pull initial token from the user to specified router adapter\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\n        tokenOut = query.tokenOut;\n        address routerAdapter = query.routerAdapter;\n        if (routerAdapter == address(this)) {\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\n        } else {\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\n            // Record tokenOut balance before swap\n            amountOut = tokenOut.universalBalanceOf(recipient);\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\n                recipient: recipient,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                tokenOut: tokenOut,\n                rawParams: query.rawParams\n            });\n            // Use the difference between the recorded balance and the current balance as the amountOut\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\n        }\n        // Finally, check that the recipient received at least as much as they wanted\n        if (amountOut \u003c query.minAmountOut) revert InsufficientOutputAmount();\n    }\n\n    /// @dev Pulls a requested token from the user to the requested recipient.\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\n    function _pullToken(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 amountPulled) {\n        if (msg.value == 0) {\n            token.assertIsContract();\n            // Record token balance before transfer\n            amountPulled = IERC20(token).balanceOf(recipient);\n            // Token needs to be pulled only if msg.value is zero\n            // This way user can specify WETH as the origin asset\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\n            // Use the difference between the recorded balance and the current balance as the amountPulled\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\n        } else {\n            // Otherwise, we need to check that ETH was specified\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\n            // And that amount matches msg.value\n            if (amount != msg.value) revert MsgValueIncorrect();\n            // We will forward msg.value in the external call later, if recipient is not this contract\n            amountPulled = msg.value;\n        }\n    }\n}\n\n// contracts/router/SynapseRouterV2.sol\n\ncontract SynapseRouterV2 is IRouterV2, DefaultRouter, Ownable {\n    using Address for address;\n    using Arrays for BridgeToken[][];\n    using Arrays for BridgeToken[];\n    using Arrays for address[][];\n    using Arrays for address[];\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice swap quoter\n    ISwapQuoterV2 public swapQuoter;\n\n    /// @notice Enumerable map of all connected bridge modules\n    EnumerableMap.UintToAddressMap internal _bridgeModules;\n\n    event QuoterSet(address oldSwapQuoter, address newSwapQuoter);\n    event ModuleConnected(bytes32 indexed moduleId, address bridgeModule);\n    event ModuleUpdated(bytes32 indexed moduleId, address oldBridgeModule, address newBridgeModule);\n    event ModuleDisconnected(bytes32 indexed moduleId);\n\n    error SynapseRouterV2__ModuleExists();\n    error SynapseRouterV2__ModuleNotExists();\n    error SynapseRouterV2__ModuleInvalid();\n    error SynapseRouterV2__QueryEmpty();\n\n    /// @inheritdoc IRouterV2\n    function bridgeViaSynapse(\n        address to,\n        uint256 chainId,\n        bytes32 moduleId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable {\n        address bridgeModule = idToModule(moduleId);\n\n        // pull (and possibly swap) token into router\n        if (originQuery.hasAdapter()) {\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\n        } else {\n            amount = _pullToken(address(this), token, amount);\n        }\n\n        // delegate bridge call to module\n        // @dev delegatecall should approve to spend\n        bytes memory payload = abi.encodeWithSelector(\n            IBridgeModule.delegateBridge.selector,\n            to,\n            chainId,\n            token,\n            amount,\n            destQuery\n        );\n        bridgeModule.functionDelegateCall(payload); // bubbles up the error, but nothing to be returned\n    }\n\n    /// @inheritdoc IRouterV2\n    function swap(\n        address to,\n        address token,\n        uint256 amount,\n        SwapQuery memory query\n    ) external payable returns (uint256 amountOut) {\n        if (!query.hasAdapter()) revert SynapseRouterV2__QueryEmpty();\n        (, amountOut) = _doSwap(to, token, amount, query);\n    }\n\n    /// @inheritdoc IRouterV2\n    function setSwapQuoter(ISwapQuoterV2 _swapQuoter) external onlyOwner {\n        emit QuoterSet(address(swapQuoter), address(_swapQuoter));\n        swapQuoter = _swapQuoter;\n    }\n\n    /// @inheritdoc IRouterV2\n    function setAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeApprove(spender, amount);\n    }\n\n    /// @inheritdoc IRouterV2\n    function connectBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (moduleId == bytes32(0) || bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (_hasModule(moduleId)) revert SynapseRouterV2__ModuleExists();\n\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n        emit ModuleConnected(moduleId, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function updateBridgeModule(bytes32 moduleId, address bridgeModule) external onlyOwner {\n        if (bridgeModule == address(0)) revert SynapseRouterV2__ModuleInvalid();\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        address module = _bridgeModules.get(uint256(moduleId));\n        _bridgeModules.set(uint256(moduleId), bridgeModule);\n\n        emit ModuleUpdated(moduleId, module, bridgeModule);\n    }\n\n    /// @inheritdoc IRouterV2\n    function disconnectBridgeModule(bytes32 moduleId) external onlyOwner {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n\n        _bridgeModules.remove(uint256(moduleId));\n        emit ModuleDisconnected(moduleId);\n    }\n\n    /// @inheritdoc IRouterV2\n    function idToModule(bytes32 moduleId) public view returns (address bridgeModule) {\n        if (!_hasModule(moduleId)) revert SynapseRouterV2__ModuleNotExists();\n        bridgeModule = _bridgeModules.get(uint256(moduleId));\n    }\n\n    /// @inheritdoc IRouterV2\n    function moduleToId(address bridgeModule) public view returns (bytes32 moduleId) {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (uint256 key, address module) = _bridgeModules.at(i);\n            if (module == bridgeModule) {\n                moduleId = bytes32(key);\n                break;\n            }\n        }\n        if (moduleId == bytes32(0)) revert SynapseRouterV2__ModuleNotExists();\n    }\n\n    /// @inheritdoc IRouterV2\n    function getBridgeTokens() public view returns (BridgeToken[] memory) {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            unflattened[i] = IBridgeModule(bridgeModule).getBridgeTokens();\n            count += unflattened[i].length;\n        }\n\n        // flatten into bridge tokens array\n        return unflattened.flatten(count);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory destTokens) {\n        destTokens = _getConnectedBridgeTokens(tokenOut, false);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginBridgeTokens(address tokenIn) external view returns (BridgeToken[] memory originTokens) {\n        originTokens = _getConnectedBridgeTokens(tokenIn, true);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getSupportedTokens() external view returns (address[] memory supportedTokens) {\n        // get tokens in each quoter pool\n        Pool[] memory pools = swapQuoter.allPools();\n\n        // init unflattened for aggregating supported tokens\n        address[][] memory unflattened = new address[][](pools.length + 1);\n        uint256 count;\n\n        // last index of unflattened dedicated to bridge tokens\n        unflattened[pools.length] = getBridgeTokens().tokens();\n        count += unflattened[pools.length].length;\n\n        // fill pool tokens up to but not including last index of unflattened\n        for (uint256 i = 0; i \u003c pools.length; ++i) {\n            Pool memory pool = pools[i];\n            unflattened[i] = new address[](pool.tokens.length);\n\n            // whether pool.tokens does contain a bridge token\n            // @dev need to initialize with contains pool LP token to catch edge case\n            // @dev of Ethereum Stablepool having LP token as bridge token\n            bool does = unflattened[pools.length].contains(pool.lpToken);\n            for (uint256 j = 0; j \u003c pool.tokens.length; ++j) {\n                // optimistically add pool token to list\n                unflattened[i][j] = pool.tokens[j].token;\n\n                // check whether pool token is a bridge token if haven't found one prior\n                // @dev remember last index of unflattened has all the addresses of the bridge tokens\n                if (!does) does = unflattened[pools.length].contains(pool.tokens[j].token);\n            }\n\n            // zero out if no bridge token\n            if (!does) delete unflattened[i];\n            else count += pool.tokens.length;\n        }\n\n        // flatten into supported tokens and filter out duplicates\n        supportedTokens = unflattened.flatten(count).unique();\n\n        // add native weth if in supported list\n        if (supportedTokens.contains(swapQuoter.weth())) return supportedTokens.append(UniversalTokenLib.ETH_ADDRESS);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getDestinationAmountOut(DestRequest memory request, address tokenOut)\n    external\n    view\n    returns (SwapQuery memory destQuery)\n    {\n        (address token, uint256 actionMask, address bridgeModule) = _getTokenAndActionMaskFromSymbol(request.symbol);\n        if (token == address(0)) return destQuery; // empty\n\n        // account for bridge fees in amountIn\n        bool isSwap = !(token == tokenOut || (tokenOut == UniversalTokenLib.ETH_ADDRESS \u0026\u0026 token == swapQuoter.weth()));\n        uint256 amountIn = _calculateBridgeAmountIn(bridgeModule, token, request.amountIn, isSwap);\n        if (amountIn == 0) return destQuery; // empty\n\n        // query the quoter\n        LimitedToken memory tokenIn = LimitedToken({actionMask: actionMask, token: token});\n        destQuery = swapQuoter.getAmountOut(tokenIn, tokenOut, amountIn);\n    }\n\n    /// @inheritdoc IRouterV2\n    function getOriginAmountOut(\n        address tokenIn,\n        string memory tokenSymbol,\n        uint256 amountIn\n    ) external view returns (SwapQuery memory originQuery) {\n        (address tokenOut, , address bridgeModule) = _getTokenAndActionMaskFromSymbol(tokenSymbol);\n        if (tokenOut == address(0)) return originQuery; // empty\n\n        // query the quoter\n        LimitedToken memory _tokenIn = LimitedToken({actionMask: ActionLib.allActions(), token: tokenIn});\n        SwapQuery memory query = swapQuoter.getAmountOut(_tokenIn, tokenOut, amountIn);\n\n        // check max amount can bridge\n        uint256 maxAmountOut = IBridgeModule(bridgeModule).getMaxBridgedAmount(tokenOut);\n        if (query.minAmountOut \u003e maxAmountOut) return originQuery; // empty\n\n        // set in return array\n        originQuery = query;\n    }\n\n    /// @notice Checks whether module ID has already been connected to router\n    function _hasModule(bytes32 moduleId) internal view returns (bool) {\n        return _bridgeModules.contains(uint256(moduleId));\n    }\n\n    /// @notice Searches all bridge modules to get the token address from the unique bridge symbol\n    /// @dev Returns zero value for unknown symbols (does not revert)\n    /// @param symbol Symbol of the supported bridge token\n    function _getTokenAndActionMaskFromSymbol(string memory symbol)\n    internal\n    view\n    returns (\n        address token,\n        uint256 actionMask,\n        address bridgeModule\n    )\n    {\n        uint256 len = _bridgeModules.length();\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address _bridgeModule) = _bridgeModules.at(i);\n            token = IBridgeModule(_bridgeModule).symbolToToken(symbol);\n            if (token != address(0)) {\n                actionMask = IBridgeModule(_bridgeModule).tokenToActionMask(token);\n                bridgeModule = _bridgeModule;\n                break;\n            }\n        }\n    }\n\n    /// @notice Gets all connected bridge tokens to the given token\n    /// @param token The token to connect bridge tokens with\n    /// @param origin Whether gathering on origin or destination chain\n    /// @param connected The connected bridge tokens. If origin == True, then returns origin\n    ///                  bridge tokens. If origin == False, returns dest bridge tokens.\n    function _getConnectedBridgeTokens(address token, bool origin)\n    internal\n    view\n    returns (BridgeToken[] memory connected)\n    {\n        uint256 len = _bridgeModules.length();\n        BridgeToken[][] memory unflattened = new BridgeToken[][](len);\n\n        uint256 count;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            (, address bridgeModule) = _bridgeModules.at(i);\n            BridgeToken[] memory bridgeTokens = IBridgeModule(bridgeModule).getBridgeTokens();\n\n            // assemble limited token format for quoter call\n            uint256 amountFound;\n            bool[] memory isConnected = new bool[](bridgeTokens.length);\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                LimitedToken memory _tokenIn = origin\n                    ? LimitedToken({actionMask: ActionLib.allActions(), token: token}) // origin bridge tokens\n                    : LimitedToken({\n                        actionMask: IBridgeModule(bridgeModule).tokenToActionMask(bridgeTokens[j].token),\n                        token: bridgeTokens[j].token\n                    }); // dest bridge tokens\n                address _tokenOut = origin ? bridgeTokens[j].token : token;\n                isConnected[j] = swapQuoter.areConnectedTokens(_tokenIn, _tokenOut);\n                if (isConnected[j]) amountFound++;\n            }\n\n            // push to unflattened tokens if bridge token connected to given token\n            unflattened[i] = new BridgeToken[](amountFound);\n            count += amountFound;\n\n            uint256 k;\n            for (uint256 j = 0; j \u003c bridgeTokens.length; ++j) {\n                if (isConnected[j]) {\n                    unflattened[i][k] = bridgeTokens[j];\n                    k++;\n                }\n            }\n        }\n\n        // flatten into connected tokens\n        connected = unflattened.flatten(count);\n    }\n\n    /// @notice Calculates amount of bridge token in accounting for bridge fees\n    /// @dev Returns zero value if fee too big (does not revert)\n    /// @param token    Address of the bridging token\n    /// @param amount   Amount in before fees\n    /// @param isSwap   Whether the user provided swap details for converting the bridge token\n    ///                 to the final token on this chain\n    function _calculateBridgeAmountIn(\n        address bridgeModule,\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 amount_) {\n        uint256 feeAmount = IBridgeModule(bridgeModule).calculateFeeAmount(token, amount, isSwap);\n        if (feeAmount \u003c amount) amount_ = amount - feeAmount;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"76556:2493:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;76556:2493:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"76556:2493:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseRouterV2.sol\":\"UniversalTokenLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseRouterV2.sol\":{\"keccak256\":\"0xc5ccb40d56575ef738758847e8307a8bb34a33e818de660f889bf96f3117f700\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://174b6b0a9a0fe611a9522829750ffac2980a11e00860307f43a898a6de16d38f\",\"dweb:/ipfs/QmWaztJBMKh8FsmmjrFdphFJu9G8ey9sBQj3kQbpJ2VYY5\"]}},\"version\":1}"},"hashes":{}}}