{"solidity/InterchainDB.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__BatchDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__BatchNotFinalized","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"},{"internalType":"bytes32","name":"existingBatchRoot","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"newBatch","type":"tuple"}],"name":"InterchainDB__ConflictingBatches","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"uint64","name":"batchSize","type":"uint64"}],"name":"InterchainDB__EntryIndexOutOfRange","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"InterchainDB__InvalidBatchVersion","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"InterchainDB__InvalidEntryRange","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"DB_VERSION","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"checkVerification","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatch","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatchLeafs","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"getBatchLeafsPaginated","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatchSize","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryProof","outputs":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryValue","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNextEntryIndex","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"DB_VERSION()":{"notice":"Get the version of the Interchain DataBase."},"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"getBatch(uint256)":{"notice":"Get the finalized Interchain Batch with the given nonce."},"getBatchLeafs(uint256)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together)."},"getBatchLeafsPaginated(uint256,uint64,uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error."},"getBatchSize(uint256)":{"notice":"Returns the size of the finalized batch with the given nonce."},"getDBNonce()":{"notice":"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch."},"getEntryProof(uint256,uint64)":{"notice":"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce."},"getEntryValue(uint256,uint64)":{"notice":"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getNextEntryIndex()":{"notice":"Get the index of the next entry to be written to the database."},"requestBatchVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch."},"verifyRemoteBatch(bytes)":{"notice":"Allows the Interchain Module to verify the batch coming from the remote chain. Note: The DB will only accept the batch of the same version as the DB itself."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details."}},"version":1},"developerDoc":{"kind":"dev","methods":{"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry."}},"getBatch(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafs(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafsPaginated(uint256,uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.","params":{"dbNonce":"The database nonce of the finalized batch","end":"The end index of the paginated leafs, exclusive","start":"The start index of the paginated leafs, inclusive"}},"getBatchSize(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getEntryProof(uint256,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the finalized batch","entryIndex":"The index of the written entry within the batch"},"returns":{"proof":"      The Merkle proof of inclusion for the entry"}},"getEntryValue(uint256,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the existing batch","entryIndex":"The index of the written entry within the batch"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getNextEntryIndex()":{"returns":{"dbNonce":"     The database nonce of the batch including the next entry","entryIndex":"  The index of the next entry within that batch"}},"requestBatchVerification(uint256,uint256,address[])":{"details":"Will revert if the batch with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the existing batch","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyRemoteBatch(bytes)":{"params":{"versionedBatch":"The versioned Interchain Batch to verify"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__BatchDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__BatchNotFinalized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"existingBatchRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"newBatch\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingBatches\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"InterchainDB__InvalidBatchVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__InvalidEntryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DB_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"checkVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatchLeafs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafsPaginated\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEntryIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry.\"}},\"getBatch(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafs(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafsPaginated(uint256,uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"end\":\"The end index of the paginated leafs, exclusive\",\"start\":\"The start index of the paginated leafs, inclusive\"}},\"getBatchSize(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getEntryProof(uint256,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"entryIndex\":\"The index of the written entry within the batch\"},\"returns\":{\"proof\":\"      The Merkle proof of inclusion for the entry\"}},\"getEntryValue(uint256,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"entryIndex\":\"The index of the written entry within the batch\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getNextEntryIndex()\":{\"returns\":{\"dbNonce\":\"     The database nonce of the batch including the next entry\",\"entryIndex\":\"  The index of the next entry within that batch\"}},\"requestBatchVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the batch with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyRemoteBatch(bytes)\":{\"params\":{\"versionedBatch\":\"The versioned Interchain Batch to verify\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DB_VERSION()\":{\"notice\":\"Get the version of the Interchain DataBase.\"},\"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"getBatch(uint256)\":{\"notice\":\"Get the finalized Interchain Batch with the given nonce.\"},\"getBatchLeafs(uint256)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\"},\"getBatchLeafsPaginated(uint256,uint64,uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error.\"},\"getBatchSize(uint256)\":{\"notice\":\"Returns the size of the finalized batch with the given nonce.\"},\"getDBNonce()\":{\"notice\":\"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch.\"},\"getEntryProof(uint256,uint64)\":{\"notice\":\"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce.\"},\"getEntryValue(uint256,uint64)\":{\"notice\":\"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getNextEntryIndex()\":{\"notice\":\"Get the index of the next entry to be written to the database.\"},\"requestBatchVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch.\"},\"verifyRemoteBatch(bytes)\":{\"notice\":\"Allows the Interchain Module to verify the batch coming from the remote chain. Note: The DB will only accept the batch of the same version as the DB itself.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{"DB_VERSION()":"15f53956","checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":"67b1f42e","getBatch(uint256)":"5ac44282","getBatchLeafs(uint256)":"d63020bb","getBatchLeafsPaginated(uint256,uint64,uint64)":"25a1641d","getBatchSize(uint256)":"b955e9b9","getDBNonce()":"f338140e","getEntryProof(uint256,uint64)":"4f84d040","getEntryValue(uint256,uint64)":"afa25005","getInterchainFee(uint256,address[])":"fc7686ec","getNextEntryIndex()":"aa2f06ae","requestBatchVerification(uint256,uint256,address[])":"84b1c8b8","verifyRemoteBatch(bytes)":"d961a48e","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainDB.sol:IInterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256,uint256)":{"notice":"Get the Module fee for verifying a batch on the specified destination chain."},"requestBatchVerification(uint256,bytes)":{"notice":"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering."}},"notice":"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256,uint256)":{"params":{"dbNonce":"The database nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain"}},"requestBatchVerification(uint256,bytes)":{"details":"Could be only called by the Interchain DataBase contract.","params":{"dstChainId":"The chain id of the destination chain","versionedBatch":"The versioned batch to verify"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256,uint256)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\"}},\"requestBatchVerification(uint256,bytes)\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"versionedBatch\":\"The versioned batch to verify\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256,uint256)\":{\"notice\":\"Get the Module fee for verifying a batch on the specified destination chain.\"},\"requestBatchVerification(uint256,bytes)\":{\"notice\":\"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint256,uint256)":"4a114f72","requestBatchVerification(uint256,bytes)":"4bd7e4dd"}},"solidity/InterchainDB.sol:InterchainBatchLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220af50f2c0661bdcd6d59d60ee94632aab91022cb6f846bb59efe98c1b2666d26d64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220af50f2c0661bdcd6d59d60ee94632aab91022cb6f846bb59efe98c1b2666d26d64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"7069:1618:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;7069:1618:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"7069:1618:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainBatchLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:InterchainDB":{"code":"0x608060405234801561001057600080fd5b5061175c806100206000396000f3fe6080604052600436106100e85760003560e01c806384b1c8b81161008a578063d63020bb11610059578063d63020bb14610296578063d961a48e146102b6578063f338140e146102d6578063fc7686ec146102eb57600080fd5b806384b1c8b814610213578063aa2f06ae14610228578063afa250051461023d578063b955e9b91461025d57600080fd5b80634f84d040116100c65780634f84d040146101855780635ac44282146101a557806367b1f42e146101d257806367c769af1461020057600080fd5b806315f53956146100ed57806325a1641d1461011a5780632ad8c70614610147575b600080fd5b3480156100f957600080fd5b50610102600181565b60405161ffff90911681526020015b60405180910390f35b34801561012657600080fd5b5061013a610135366004611030565b61030b565b604051610111919061106c565b34801561015357600080fd5b506101676101623660046110b0565b610398565b6040805192835267ffffffffffffffff909116602083015201610111565b34801561019157600080fd5b5061013a6101a03660046110c9565b6103bc565b3480156101b157600080fd5b506101c56101c03660046110b0565b6103e9565b60405161011191906110f5565b3480156101de57600080fd5b506101f26101ed3660046111fe565b610452565b604051908152602001610111565b61016761020e3660046112c3565b61054c565b6102266102213660046112c3565b6105d0565b005b34801561023457600080fd5b5061016761062d565b34801561024957600080fd5b506101f26102583660046110c9565b610642565b34801561026957600080fd5b5061027d6102783660046110b0565b610674565b60405167ffffffffffffffff9091168152602001610111565b3480156102a257600080fd5b5061013a6102b13660046110b0565b61069d565b3480156102c257600080fd5b506102266102d13660046112fe565b6106f8565b3480156102e257600080fd5b506000546101f2565b3480156102f757600080fd5b506101f2610306366004611370565b6108bc565b606067ffffffffffffffff831615158061033057508167ffffffffffffffff16600114155b15610387576040517fedcdbfea0000000000000000000000000000000000000000000000000000000081526004810185905267ffffffffffffffff8085166024830152831660448201526064015b60405180910390fd5b6103908461069d565b949350505050565b60008060006103a6846108db565b6020810151604090910151909590945092505050565b60606103c783610993565b506103d283836109d7565b506040805160008152602081019091525b92915050565b604080516060810182526000808252602082018190529181019190915261040f82610993565b506103e38261041f846000610642565b60408051606080820183526000808352602080840182905292840152825190810183524681529081019390935282015290565b8251600090468103610492576040517ffc2dee9a00000000000000000000000000000000000000000000000000000000815246600482015260240161037e565b82156104a15760009150610543565b604085015167ffffffffffffffff16156104be5760009150610543565b73ffffffffffffffffffffffffffffffffffffffff86166000908152600160205260408120816104ed88610a51565b8152602001908152602001600020604051806040016040529081600082015481526020016001820154815250509050600061052787610a94565b90508082602001511461053b57600061053e565b81515b935050505b50949350505050565b6000808546810361058b576040517ffc2dee9a00000000000000000000000000000000000000000000000000000000815246600482015260240161037e565b6000610596876108db565b602081015160408201519095509350905060006105b68561041f84610a94565b90506105c489828989610ab7565b50505094509492505050565b8346810361060c576040517ffc2dee9a00000000000000000000000000000000000000000000000000000000815246600482015260240161037e565b6000610617856103e9565b905061062586828686610ab7565b505050505050565b60008061063960005490565b92600092509050565b600061064e83836109d7565b60008381548110610661576106616113bc565b9060005260206000200154905092915050565b60008061068083610c81565b9050808310610690576000610693565b60015b60ff169392505050565b60606106a882610993565b5060408051600180825281830190925290602080830190803683370190505090506106d4826000610642565b816000815181106106e7576106e76113bc565b602002602001018181525050919050565b60006107048383610cc1565b905061ffff811660011461074a576040517f0526520e00000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161037e565b600061075e6107598585610d0b565b610d66565b9050468160000151036107a35780516040517ffc2dee9a000000000000000000000000000000000000000000000000000000008152600481019190915260240161037e565b60006107ae82610a51565b336000908152600160208181526040808420858552825280842081518083019092528054808352930154918101919091529293509003610872576040805180820182524281528482018051602080840191825233600081815260018084528782208a8352845290879020955186559251949092019390935586518388015192518551928352938201529283015260608201527fbdb1c58ad0991a7df73dd7d1e0c63ba29dd69af7d09838990eef8127de1a548c9060800160405180910390a1610625565b82604001518160200151146106255760208101516040517f4f70133a00000000000000000000000000000000000000000000000000000000815261037e91339186906004016113eb565b60006108d2846108cb60005490565b8585610d96565b95945050505050565b6040805160a081018252600080825260208201819052918101829052606081018290526080810182905290546109149060003385610f43565b9050600061092182610a94565b81546001810183556000928352602092839020015581015160608201516040517f8adbf0953083a65c138963c649cd1eabd31fa900ecd1cd5d6b5b530fbfa4177192610986924692879093845260208401929092526040830152606082015260800190565b60405180910390a1919050565b6000548082106109d2576040517ffa1681ec0000000000000000000000000000000000000000000000000000000081526004810183905260240161037e565b919050565b60006109e283610674565b90508067ffffffffffffffff168267ffffffffffffffff1610610a4c576040517f759b436e0000000000000000000000000000000000000000000000000000000081526004810184905267ffffffffffffffff80841660248301528216604482015260640161037e565b505050565b600081600001518260200151604051602001610a77929190918252602082015260400190565b604051602081830303815290604052805190602001209050919050565b606080820151608083015160408051602081019390935282015260009101610a77565b600080610aca8686602001518686610d96565b9150915080341015610b11576040517ffb7d66100000000000000000000000000000000000000000000000000000000081523460048201526024810182905260440161037e565b80341115610b4e57610b23813461145f565b82600081518110610b3657610b366113bc565b60200260200101818151610b4a9190611472565b9052505b826000610b646001610b5f89610fc3565b610fec565b905060005b82811015610c2f57868682818110610b8357610b836113bc565b9050602002016020810190610b989190611485565b73ffffffffffffffffffffffffffffffffffffffff16634bd7e4dd868381518110610bc557610bc56113bc565b60200260200101518b856040518463ffffffff1660e01b8152600401610bec9291906114c4565b6000604051808303818588803b158015610c0557600080fd5b505af1158015610c19573d6000803e3d6000fd5b505050505080610c289061151c565b9050610b69565b507f9f201dd0d5465cd198596655528d58e40b6ee2715d5e8bdab49f7e1b1dde771788886020015189604001518989604051610c6f959493929190611554565b60405180910390a15050505050505050565b600054808211156109d2576040517f77a0269c0000000000000000000000000000000000000000000000000000000081526004810183905260240161037e565b60006002821015610d025782826040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161037e9291906115c8565b50503560f01c90565b3660006002831015610d4d5783836040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161037e9291906115c8565b610d5a8360028187611615565b915091505b9250929050565b6040805160608101825260008082526020820181905291810191909152610d8f8284018461163f565b9392505050565b6060600082808203610dd4576040517f98ca492a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff811115610ded57610ded61113a565b604051908082528060200260200182016040528015610e16578160200160208202803683370190505b50925060005b81811015610f3857858582818110610e3657610e366113bc565b9050602002016020810190610e4b9190611485565b6040517f4a114f72000000000000000000000000000000000000000000000000000000008152600481018a90526024810189905273ffffffffffffffffffffffffffffffffffffffff9190911690634a114f7290604401602060405180830381865afa158015610ebf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ee391906116c2565b848281518110610ef557610ef56113bc565b602002602001018181525050838181518110610f1357610f136113bc565b602002602001015183610f269190611472565b9250610f318161151c565b9050610e1c565b505094509492505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526040518060a001604052804681526020018681526020018567ffffffffffffffff168152602001610fb28573ffffffffffffffffffffffffffffffffffffffff1690565b815260200192909252509392505050565b606081604051602001610fd691906110f5565b6040516020818303038152906040529050919050565b606082826040516020016110019291906116db565b604051602081830303815290604052905092915050565b803567ffffffffffffffff811681146109d257600080fd5b60008060006060848603121561104557600080fd5b8335925061105560208501611018565b915061106360408501611018565b90509250925092565b6020808252825182820181905260009190848201906040850190845b818110156110a457835183529284019291840191600101611088565b50909695505050505050565b6000602082840312156110c257600080fd5b5035919050565b600080604083850312156110dc57600080fd5b823591506110ec60208401611018565b90509250929050565b815181526020808301519082015260408083015190820152606081016103e3565b803573ffffffffffffffffffffffffffffffffffffffff811681146109d257600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160a0810167ffffffffffffffff811182821017156111b3577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b60008083601f8401126111cb57600080fd5b50813567ffffffffffffffff8111156111e357600080fd5b6020830191508360208260051b8501011115610d5f57600080fd5b60008060008084860360e081121561121557600080fd5b61121e86611116565b945060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08201121561125057600080fd5b50611259611169565b602086013581526040860135602082015261127660608701611018565b6040820152608086810135606083015260a087013590820152925060c085013567ffffffffffffffff8111156112ab57600080fd5b6112b7878288016111b9565b95989497509550505050565b600080600080606085870312156112d957600080fd5b8435935060208501359250604085013567ffffffffffffffff8111156112ab57600080fd5b6000806020838503121561131157600080fd5b823567ffffffffffffffff8082111561132957600080fd5b818501915085601f83011261133d57600080fd5b81358181111561134c57600080fd5b86602082850101111561135e57600080fd5b60209290920196919550909350505050565b60008060006040848603121561138557600080fd5b83359250602084013567ffffffffffffffff8111156113a357600080fd5b6113af868287016111b9565b9497909650939450505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff841681526020810183905260a0810161039060408301848051825260208082015190830152604090810151910152565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156103e3576103e3611430565b808201808211156103e3576103e3611430565b60006020828403121561149757600080fd5b610d8f82611116565b60005b838110156114bb5781810151838201526020016114a3565b50506000910152565b82815260406020820152600082518060408401526114e98160608501602087016114a0565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361154d5761154d611430565b5060010190565b60006080820187835260208781850152866040850152608060608501528185835260a08501905086925060005b868110156115ba5773ffffffffffffffffffffffffffffffffffffffff6115a785611116565b1682529282019290820190600101611581565b509998505050505050505050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b6000808585111561162557600080fd5b8386111561163257600080fd5b5050820193919092039150565b60006060828403121561165157600080fd5b6040516060810181811067ffffffffffffffff8211171561169b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b80604052508235815260208301356020820152604083013560408201528091505092915050565b6000602082840312156116d457600080fd5b5051919050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516117188160028501602087016114a0565b91909101600201939250505056fea2646970667358221220554480d387ab7fdce88939a7b60908990f6a5c6230412f0edc3f3ded6c1f403264736f6c63430008140033","runtime-code":"0x6080604052600436106100e85760003560e01c806384b1c8b81161008a578063d63020bb11610059578063d63020bb14610296578063d961a48e146102b6578063f338140e146102d6578063fc7686ec146102eb57600080fd5b806384b1c8b814610213578063aa2f06ae14610228578063afa250051461023d578063b955e9b91461025d57600080fd5b80634f84d040116100c65780634f84d040146101855780635ac44282146101a557806367b1f42e146101d257806367c769af1461020057600080fd5b806315f53956146100ed57806325a1641d1461011a5780632ad8c70614610147575b600080fd5b3480156100f957600080fd5b50610102600181565b60405161ffff90911681526020015b60405180910390f35b34801561012657600080fd5b5061013a610135366004611030565b61030b565b604051610111919061106c565b34801561015357600080fd5b506101676101623660046110b0565b610398565b6040805192835267ffffffffffffffff909116602083015201610111565b34801561019157600080fd5b5061013a6101a03660046110c9565b6103bc565b3480156101b157600080fd5b506101c56101c03660046110b0565b6103e9565b60405161011191906110f5565b3480156101de57600080fd5b506101f26101ed3660046111fe565b610452565b604051908152602001610111565b61016761020e3660046112c3565b61054c565b6102266102213660046112c3565b6105d0565b005b34801561023457600080fd5b5061016761062d565b34801561024957600080fd5b506101f26102583660046110c9565b610642565b34801561026957600080fd5b5061027d6102783660046110b0565b610674565b60405167ffffffffffffffff9091168152602001610111565b3480156102a257600080fd5b5061013a6102b13660046110b0565b61069d565b3480156102c257600080fd5b506102266102d13660046112fe565b6106f8565b3480156102e257600080fd5b506000546101f2565b3480156102f757600080fd5b506101f2610306366004611370565b6108bc565b606067ffffffffffffffff831615158061033057508167ffffffffffffffff16600114155b15610387576040517fedcdbfea0000000000000000000000000000000000000000000000000000000081526004810185905267ffffffffffffffff8085166024830152831660448201526064015b60405180910390fd5b6103908461069d565b949350505050565b60008060006103a6846108db565b6020810151604090910151909590945092505050565b60606103c783610993565b506103d283836109d7565b506040805160008152602081019091525b92915050565b604080516060810182526000808252602082018190529181019190915261040f82610993565b506103e38261041f846000610642565b60408051606080820183526000808352602080840182905292840152825190810183524681529081019390935282015290565b8251600090468103610492576040517ffc2dee9a00000000000000000000000000000000000000000000000000000000815246600482015260240161037e565b82156104a15760009150610543565b604085015167ffffffffffffffff16156104be5760009150610543565b73ffffffffffffffffffffffffffffffffffffffff86166000908152600160205260408120816104ed88610a51565b8152602001908152602001600020604051806040016040529081600082015481526020016001820154815250509050600061052787610a94565b90508082602001511461053b57600061053e565b81515b935050505b50949350505050565b6000808546810361058b576040517ffc2dee9a00000000000000000000000000000000000000000000000000000000815246600482015260240161037e565b6000610596876108db565b602081015160408201519095509350905060006105b68561041f84610a94565b90506105c489828989610ab7565b50505094509492505050565b8346810361060c576040517ffc2dee9a00000000000000000000000000000000000000000000000000000000815246600482015260240161037e565b6000610617856103e9565b905061062586828686610ab7565b505050505050565b60008061063960005490565b92600092509050565b600061064e83836109d7565b60008381548110610661576106616113bc565b9060005260206000200154905092915050565b60008061068083610c81565b9050808310610690576000610693565b60015b60ff169392505050565b60606106a882610993565b5060408051600180825281830190925290602080830190803683370190505090506106d4826000610642565b816000815181106106e7576106e76113bc565b602002602001018181525050919050565b60006107048383610cc1565b905061ffff811660011461074a576040517f0526520e00000000000000000000000000000000000000000000000000000000815261ffff8216600482015260240161037e565b600061075e6107598585610d0b565b610d66565b9050468160000151036107a35780516040517ffc2dee9a000000000000000000000000000000000000000000000000000000008152600481019190915260240161037e565b60006107ae82610a51565b336000908152600160208181526040808420858552825280842081518083019092528054808352930154918101919091529293509003610872576040805180820182524281528482018051602080840191825233600081815260018084528782208a8352845290879020955186559251949092019390935586518388015192518551928352938201529283015260608201527fbdb1c58ad0991a7df73dd7d1e0c63ba29dd69af7d09838990eef8127de1a548c9060800160405180910390a1610625565b82604001518160200151146106255760208101516040517f4f70133a00000000000000000000000000000000000000000000000000000000815261037e91339186906004016113eb565b60006108d2846108cb60005490565b8585610d96565b95945050505050565b6040805160a081018252600080825260208201819052918101829052606081018290526080810182905290546109149060003385610f43565b9050600061092182610a94565b81546001810183556000928352602092839020015581015160608201516040517f8adbf0953083a65c138963c649cd1eabd31fa900ecd1cd5d6b5b530fbfa4177192610986924692879093845260208401929092526040830152606082015260800190565b60405180910390a1919050565b6000548082106109d2576040517ffa1681ec0000000000000000000000000000000000000000000000000000000081526004810183905260240161037e565b919050565b60006109e283610674565b90508067ffffffffffffffff168267ffffffffffffffff1610610a4c576040517f759b436e0000000000000000000000000000000000000000000000000000000081526004810184905267ffffffffffffffff80841660248301528216604482015260640161037e565b505050565b600081600001518260200151604051602001610a77929190918252602082015260400190565b604051602081830303815290604052805190602001209050919050565b606080820151608083015160408051602081019390935282015260009101610a77565b600080610aca8686602001518686610d96565b9150915080341015610b11576040517ffb7d66100000000000000000000000000000000000000000000000000000000081523460048201526024810182905260440161037e565b80341115610b4e57610b23813461145f565b82600081518110610b3657610b366113bc565b60200260200101818151610b4a9190611472565b9052505b826000610b646001610b5f89610fc3565b610fec565b905060005b82811015610c2f57868682818110610b8357610b836113bc565b9050602002016020810190610b989190611485565b73ffffffffffffffffffffffffffffffffffffffff16634bd7e4dd868381518110610bc557610bc56113bc565b60200260200101518b856040518463ffffffff1660e01b8152600401610bec9291906114c4565b6000604051808303818588803b158015610c0557600080fd5b505af1158015610c19573d6000803e3d6000fd5b505050505080610c289061151c565b9050610b69565b507f9f201dd0d5465cd198596655528d58e40b6ee2715d5e8bdab49f7e1b1dde771788886020015189604001518989604051610c6f959493929190611554565b60405180910390a15050505050505050565b600054808211156109d2576040517f77a0269c0000000000000000000000000000000000000000000000000000000081526004810183905260240161037e565b60006002821015610d025782826040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161037e9291906115c8565b50503560f01c90565b3660006002831015610d4d5783836040517f659cf9fa00000000000000000000000000000000000000000000000000000000815260040161037e9291906115c8565b610d5a8360028187611615565b915091505b9250929050565b6040805160608101825260008082526020820181905291810191909152610d8f8284018461163f565b9392505050565b6060600082808203610dd4576040517f98ca492a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff811115610ded57610ded61113a565b604051908082528060200260200182016040528015610e16578160200160208202803683370190505b50925060005b81811015610f3857858582818110610e3657610e366113bc565b9050602002016020810190610e4b9190611485565b6040517f4a114f72000000000000000000000000000000000000000000000000000000008152600481018a90526024810189905273ffffffffffffffffffffffffffffffffffffffff9190911690634a114f7290604401602060405180830381865afa158015610ebf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ee391906116c2565b848281518110610ef557610ef56113bc565b602002602001018181525050838181518110610f1357610f136113bc565b602002602001015183610f269190611472565b9250610f318161151c565b9050610e1c565b505094509492505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526040518060a001604052804681526020018681526020018567ffffffffffffffff168152602001610fb28573ffffffffffffffffffffffffffffffffffffffff1690565b815260200192909252509392505050565b606081604051602001610fd691906110f5565b6040516020818303038152906040529050919050565b606082826040516020016110019291906116db565b604051602081830303815290604052905092915050565b803567ffffffffffffffff811681146109d257600080fd5b60008060006060848603121561104557600080fd5b8335925061105560208501611018565b915061106360408501611018565b90509250925092565b6020808252825182820181905260009190848201906040850190845b818110156110a457835183529284019291840191600101611088565b50909695505050505050565b6000602082840312156110c257600080fd5b5035919050565b600080604083850312156110dc57600080fd5b823591506110ec60208401611018565b90509250929050565b815181526020808301519082015260408083015190820152606081016103e3565b803573ffffffffffffffffffffffffffffffffffffffff811681146109d257600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160a0810167ffffffffffffffff811182821017156111b3577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b60008083601f8401126111cb57600080fd5b50813567ffffffffffffffff8111156111e357600080fd5b6020830191508360208260051b8501011115610d5f57600080fd5b60008060008084860360e081121561121557600080fd5b61121e86611116565b945060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08201121561125057600080fd5b50611259611169565b602086013581526040860135602082015261127660608701611018565b6040820152608086810135606083015260a087013590820152925060c085013567ffffffffffffffff8111156112ab57600080fd5b6112b7878288016111b9565b95989497509550505050565b600080600080606085870312156112d957600080fd5b8435935060208501359250604085013567ffffffffffffffff8111156112ab57600080fd5b6000806020838503121561131157600080fd5b823567ffffffffffffffff8082111561132957600080fd5b818501915085601f83011261133d57600080fd5b81358181111561134c57600080fd5b86602082850101111561135e57600080fd5b60209290920196919550909350505050565b60008060006040848603121561138557600080fd5b83359250602084013567ffffffffffffffff8111156113a357600080fd5b6113af868287016111b9565b9497909650939450505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff841681526020810183905260a0810161039060408301848051825260208082015190830152604090810151910152565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156103e3576103e3611430565b808201808211156103e3576103e3611430565b60006020828403121561149757600080fd5b610d8f82611116565b60005b838110156114bb5781810151838201526020016114a3565b50506000910152565b82815260406020820152600082518060408401526114e98160608501602087016114a0565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016919091016060019392505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361154d5761154d611430565b5060010190565b60006080820187835260208781850152866040850152608060608501528185835260a08501905086925060005b868110156115ba5773ffffffffffffffffffffffffffffffffffffffff6115a785611116565b1682529282019290820190600101611581565b509998505050505050505050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b6000808585111561162557600080fd5b8386111561163257600080fd5b5050820193919092039150565b60006060828403121561165157600080fd5b6040516060810181811067ffffffffffffffff8211171561169b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b80604052508235815260208301356020820152604083013560408201528091505092915050565b6000602082840312156116d457600080fd5b5051919050565b7fffff0000000000000000000000000000000000000000000000000000000000008360f01b168152600082516117188160028501602087016114a0565b91909101600201939250505056fea2646970667358221220554480d387ab7fdce88939a7b60908990f6a5c6230412f0edc3f3ded6c1f403264736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"21141:11922:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"21141:11922:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;21248:37;;;;;;;;;;;;21284:1;21248:37;;;;;188:6:1;176:19;;;158:38;;146:2;131:18;21248:37:0;;;;;;;;25306:347;;;;;;;;;;-1:-1:-1;25306:347:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;21964:228::-;;;;;;;;;;-1:-1:-1;21964:228:0;;;;;:::i;:::-;;:::i;:::-;;;;1706:25:1;;;1779:18;1767:31;;;1762:2;1747:18;;1740:59;1679:18;21964:228:0;1534:271:1;25693:341:0;;;;;;;;;;-1:-1:-1;25693:341:0;;;;;:::i;:::-;;:::i;28272:297::-;;;;;;;;;;-1:-1:-1;28272:297:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;26565:1036::-;;;;;;;;;;-1:-1:-1;26565:1036:0;;;;;:::i;:::-;;:::i;:::-;;;5148:25:1;;;5136:2;5121:18;26565:1036:0;5002:177:1;22605:648:0;;;;;;:::i;:::-;;:::i;22232:333::-;;;;;;:::i;:::-;;:::i;:::-;;26306:219;;;;;;;;;;;;;:::i;28609:183::-;;;;;;;;;;-1:-1:-1;28609:183:0;;;;;:::i;:::-;;:::i;27957:275::-;;;;;;;;;;-1:-1:-1;27957:275:0;;;;;:::i;:::-;;:::i;:::-;;;6696:18:1;6684:31;;;6666:50;;6654:2;6639:18;27957:275:0;6522:200:1;27641:276:0;;;;;;;;;;-1:-1:-1;27641:276:0;;;;;:::i;:::-;;:::i;23611:1321::-;;;;;;;;;;-1:-1:-1;23611:1321:0;;;;;:::i;:::-;;:::i;28832:95::-;;;;;;;;;;-1:-1:-1;28875:7:0;28901:19;28832:95;;26074:192;;;;;;;;;;-1:-1:-1;26074:192:0;;;;;:::i;:::-;;:::i;25306:347::-;25458:22;25500:10;;;;;;:22;;;25514:3;:8;;25521:1;25514:8;;25500:22;25496:112;;;25545:52;;;;;;;;8031:25:1;;;8075:18;8129:15;;;8109:18;;;8102:43;8181:15;;8161:18;;;8154:43;8004:18;;25545:52:0;;;;;;;;25496:112;25624:22;25638:7;25624:13;:22::i;:::-;25617:29;25306:347;-1:-1:-1;;;;25306:347:0:o;21964:228::-;22020:15;22037:17;22066:28;22097:21;22109:8;22097:11;:21::i;:::-;22153:13;;;;22168:16;;;;;22153:13;;22168:16;;-1:-1:-1;21964:228:0;-1:-1:-1;;;21964:228:0:o;25693:341::-;25775:22;25915:30;25937:7;25915:21;:30::i;:::-;;25955:39;25974:7;25983:10;25955:18;:39::i;:::-;-1:-1:-1;26011:16:0;;;26025:1;26011:16;;;;;;;;25693:341;;;;;:::o;28272:297::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;28362:30:0;28384:7;28362:21;:30::i;:::-;;28488:74;28527:7;28536:25;28550:7;28559:1;28536:13;:25::i;:::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;7628:84:0;;;;;;;7657:13;7628:84;;;;;;;;;;;;;7443:276;26565:1036;26753:16;;26788:24;;21502:13;21491:24;;21487:102;;21538:40;;;;;21564:13;21538:40;;;5148:25:1;5121:18;;21538:40:0;5002:177:1;21487:102:0;26938:17;;26934:125:::1;;27047:1;27040:8;;;;26934:125;27140:16;::::0;::::1;::::0;:21:::1;;::::0;27136:132:::1;;27256:1;27249:8;;;;27136:132;27310:25;::::0;::::1;27277:30;27310:25:::0;;;:14:::1;:25;::::0;;;;27277:30;27336:34:::1;27364:5:::0;27336:27:::1;:34::i;:::-;27310:61;;;;;;;;;;;27277:94;;;;;;;;;;;;;;;;;;;;;;;::::0;::::1;;;27381:18;27402:36;27432:5;27402:29;:36::i;:::-;27381:57;;27555:10;27530:11;:21;;;:35;:64;;27593:1;27530:64;;;27568:22:::0;;27530:64:::1;27523:71;;;;21598:1;26565:1036:::0;;;;;;;:::o;22605:648::-;22828:15;22845:17;22799:10;21502:13;21491:7;:24;21487:102;;21538:40;;;;;21564:13;21538:40;;;5148:25:1;5121:18;;21538:40:0;5002:177:1;21487:102:0;22878:28:::1;22909:21;22921:8;22909:11;:21::i;:::-;22965:13;::::0;::::1;::::0;22980:16:::1;::::0;::::1;::::0;22965:13;;-1:-1:-1;22980:16:0;-1:-1:-1;22878:52:0;-1:-1:-1;23087:28:0::1;23118:67;22965:13:::0;23166:18:::1;22878:52:::0;23166:16:::1;:18::i;23118:67::-;23087:98;;23195:51;23216:10;23228:5;23235:10;;23195:20;:51::i;:::-;22868:385;;22605:648:::0;;;;;;;;:::o;22232:333::-;22423:10;21502:13;21491:7;:24;21487:102;;21538:40;;;;;21564:13;21538:40;;;5148:25:1;5121:18;;21538:40:0;5002:177:1;21487:102:0;22449:28:::1;22480:17;22489:7;22480:8;:17::i;:::-;22449:48;;22507:51;22528:10;22540:5;22547:10;;22507:20;:51::i;:::-;22439:126;22232:333:::0;;;;;:::o;26306:219::-;26358:15;26375:17;26482:12;28875:7;28901:19;;28832:95;26482:12;26472:22;26517:1;;-1:-1:-1;26306:219:0;-1:-1:-1;26306:219:0:o;28609:183::-;28689:7;28708:39;28727:7;28736:10;28708:18;:39::i;:::-;28764:12;28777:7;28764:21;;;;;;;;:::i;:::-;;;;;;;;;28757:28;;28609:183;;;;:::o;27957:275::-;28017:6;28128:20;28151:27;28170:7;28151:18;:27::i;:::-;28128:50;;28205:12;28195:7;:22;:30;;28224:1;28195:30;;;28220:1;28195:30;28188:37;;;27957:275;-1:-1:-1;;;27957:275:0:o;27641:276::-;27702:22;27800:30;27822:7;27800:21;:30::i;:::-;-1:-1:-1;27848:16:0;;;27862:1;27848:16;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;27848:16:0;27840:24;;27885:25;27899:7;27908:1;27885:13;:25::i;:::-;27874:5;27880:1;27874:8;;;;;;;;:::i;:::-;;;;;;:36;;;;;27641:276;;;:::o;23611:1321::-;23688:16;23707:27;:14;;:25;:27::i;:::-;23688:46;-1:-1:-1;23748:23:0;;;21284:1;23748:23;23744:105;;23794:44;;;;;188:6:1;176:19;;23794:44:0;;;158:38:1;131:18;;23794:44:0;14:188:1;23744:105:0;23858:28;23889:59;23920:27;:14;;:25;:27::i;:::-;23889:30;:59::i;:::-;23858:90;;23982:13;23962:5;:16;;;:33;23958:114;;24044:16;;24018:43;;;;;;;;5148:25:1;;;;5121:18;;24018:43:0;5002:177:1;23958:114:0;24081:16;24100:34;24128:5;24100:27;:34::i;:::-;24194:10;24144:32;24179:26;;;:14;:26;;;;;;;;:36;;;;;;;;24144:71;;;;;;;;;;;;;;;;;;;;;;;24081:53;;-1:-1:-1;24297:29:0;;24293:633;;24397:70;;;;;;;;24422:15;24397:70;;24450:15;;;;;24397:70;;;;;;;24357:10;-1:-1:-1;24342:26:0;;;:14;:26;;;;;;:36;;;;;;;;;:125;;;;;;;;;;;;;;24522:16;;24540:13;;;;24555:15;;24486:85;;8628:74:1;;;8718:18;;;8711:34;8761:18;;;8754:34;8819:2;8804:18;;8797:34;24486:85:0;;8615:3:1;8600:19;24486:85:0;;;;;;;24293:633;;;24732:5;:15;;;24705:13;:23;;;:42;24701:164;;24819:23;;;;24774:76;;;;;;;24807:10;;24844:5;;24774:76;;;:::i;26074:192::-;26174:11;26207:52;26222:10;26234:12;28875:7;28901:19;;28832:95;26234:12;26248:10;;26207:14;:52::i;:::-;26197:62;26074:192;-1:-1:-1;;;;;26074:192:0:o;29314:429::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;28901:19:0;;29419:176;;29519:1;29542:10;29576:8;29419:38;:176::i;:::-;29411:184;;29605:12;29623:18;:5;:16;:18::i;:::-;29605:37;;;;;;;-1:-1:-1;29605:37:0;;;;;;;;;;29695:13;;;29710:15;;;;29657:79;;;;;;29680:13;;29727:8;;9538:25:1;;;9594:2;9579:18;;9572:34;;;;9637:2;9622:18;;9615:34;9680:2;9665:18;;9658:34;9525:3;9510:19;;9307:391;29657:79:0;;;;;;;;29314:429;;;:::o;31756:247::-;31827:20;28901:19;31900:23;;;31896:101;;31946:40;;;;;;;;5148:25:1;;;5121:18;;31946:40:0;5002:177:1;31896:101:0;31756:247;;;:::o;32110:327::-;32254:16;32273:21;32286:7;32273:12;:21::i;:::-;32254:40;;32322:9;32308:23;;:10;:23;;;32304:127;;32354:66;;;;;;;;8031:25:1;;;8075:18;8129:15;;;8109:18;;;8102:43;8181:15;;8161:18;;;8154:43;8004:18;;32354:66:0;7833:370:1;32304:127:0;32188:249;32110:327;;:::o;10988:158::-;11059:7;11106:5;:16;;;11124:5;:13;;;11095:43;;;;;;;;9877:25:1;;;9933:2;9918:18;;9911:34;9865:2;9850:18;;9703:248;11095:43:0;;;;;;;;;;;;;11085:54;;;;;;11078:61;;10988:158;;;:::o;10733:160::-;10853:15;;;;;10870:14;;;;10842:43;;;;;;9877:25:1;;;;9918:18;;9911:34;10806:7:0;;9850:18:1;10842:43:0;9703:248:1;29946:1049:0;30119:21;30142:16;30162:53;30177:10;30189:5;:13;;;30204:10;;30162:14;:53::i;:::-;30118:97;;;;30241:8;30229:9;:20;30225:260;;;30272:53;;;;;30305:9;30272:53;;;9877:25:1;9918:18;;;9911:34;;;9850:18;;30272:53:0;9703:248:1;30225:260:0;30358:8;30346:9;:20;30342:143;;;30454:20;30466:8;30454:9;:20;:::i;:::-;30443:4;30448:1;30443:7;;;;;;;;:::i;:::-;;;;;;:31;;;;;;;:::i;:::-;;;-1:-1:-1;30342:143:0;30508:10;30494:11;30565:147;21284:1;30664:37;30695:5;30664:30;:37::i;:::-;30565:42;:147::i;:::-;30535:177;;30727:9;30722:160;30746:3;30742:1;:7;30722:160;;;30788:10;;30799:1;30788:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;30770:57;;;30835:4;30840:1;30835:7;;;;;;;;:::i;:::-;;;;;;;30844:10;30856:14;30770:101;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30751:3;;;;:::i;:::-;;;30722:160;;;;30896:92;30933:10;30945:5;:13;;;30960:5;:15;;;30977:10;;30896:92;;;;;;;;;;:::i;:::-;;;;;;;;30108:887;;;;29946:1049;;;;:::o;31409:243::-;31477:20;28901:19;31550:22;;;31546:100;;;31595:40;;;;;;;;5148:25:1;;;5121:18;;31595:40:0;5002:177:1;3453:425:0;3529:14;2830:1;3559:40;;3555:122;;;3649:16;;3622:44;;;;;;;;;;;;:::i;3555:122::-;-1:-1:-1;;3824:37:0;3819:3;3815:47;;3453:425::o;4106:280::-;4182:14;;2830:1;4212:40;;4208:122;;;4302:16;;4275:44;;;;;;;;;;;;:::i;4208:122::-;4346:33;:16;2830:1;4346:16;;:33;:::i;:::-;4339:40;;;;4106:280;;;;;;:::o;8046:148::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;8152:35:0;;;;8163:4;8152:35;:::i;:::-;8145:42;8046:148;-1:-1:-1;;;8046:148:0:o;32498:563::-;32667:21;32690:16;32736:10;32767:8;;;32763:80;;32798:34;;;;;;;;;;;;;;32763:80;32873:3;32859:18;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;32859:18:0;;32852:25;;32892:9;32887:168;32911:3;32907:1;:7;32887:168;;;32963:10;;32974:1;32963:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;32945:66;;;;;;;;9877:25:1;;;9918:18;;;9911:34;;;32945:45:0;;;;;;;;9850:18:1;;32945:66:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;32935:4;32940:1;32935:7;;;;;;;;:::i;:::-;;;;;;:76;;;;;33037:4;33042:1;33037:7;;;;;;;;:::i;:::-;;;;;;;33025:19;;;;;:::i;:::-;;-1:-1:-1;32916:3:0;;;:::i;:::-;;;32887:168;;;;32712:349;32498:563;;;;;;;:::o;9930:465::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;10165:223:0;;;;;;;;10207:13;10165:223;;;;10243:7;10165:223;;;;10276:10;10165:223;;;;;;10311:34;10338:6;2395:22;;;2298:127;10311:34;10165:223;;;;;;;;-1:-1:-1;10158:230:0;9930:465;-1:-1:-1;;;9930:465:0:o;7812:129::-;7886:12;7928:5;7917:17;;;;;;;;:::i;:::-;;;;;;;;;;;;;7910:24;;7812:129;;;:::o;3116:165::-;3209:12;3257:7;3266;3240:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;3233:41;;3116:165;;;;:::o;207:171:1:-;274:20;;334:18;323:30;;313:41;;303:69;;368:1;365;358:12;383:324;458:6;466;474;527:2;515:9;506:7;502:23;498:32;495:52;;;543:1;540;533:12;495:52;579:9;566:23;556:33;;608:37;641:2;630:9;626:18;608:37;:::i;:::-;598:47;;664:37;697:2;686:9;682:18;664:37;:::i;:::-;654:47;;383:324;;;;;:::o;712:632::-;883:2;935:21;;;1005:13;;908:18;;;1027:22;;;854:4;;883:2;1106:15;;;;1080:2;1065:18;;;854:4;1149:169;1163:6;1160:1;1157:13;1149:169;;;1224:13;;1212:26;;1293:15;;;;1258:12;;;;1185:1;1178:9;1149:169;;;-1:-1:-1;1335:3:1;;712:632;-1:-1:-1;;;;;;712:632:1:o;1349:180::-;1408:6;1461:2;1449:9;1440:7;1436:23;1432:32;1429:52;;;1477:1;1474;1467:12;1429:52;-1:-1:-1;1500:23:1;;1349:180;-1:-1:-1;1349:180:1:o;1810:252::-;1877:6;1885;1938:2;1926:9;1917:7;1913:23;1909:32;1906:52;;;1954:1;1951;1944:12;1906:52;1990:9;1977:23;1967:33;;2019:37;2052:2;2041:9;2037:18;2019:37;:::i;:::-;2009:47;;1810:252;;;;;:::o;2469:268::-;2333:12;;2321:25;;2395:4;2384:16;;;2378:23;2362:14;;;2355:47;2451:4;2440:16;;;2434:23;2418:14;;;2411:47;2667:2;2652:18;;2679:52;2252:212;2742:196;2810:20;;2870:42;2859:54;;2849:65;;2839:93;;2928:1;2925;2918:12;2943:184;2995:77;2992:1;2985:88;3092:4;3089:1;3082:15;3116:4;3113:1;3106:15;3132:402;3199:2;3193:9;3241:4;3229:17;;3276:18;3261:34;;3297:22;;;3258:62;3255:242;;;3353:77;3350:1;3343:88;3454:4;3451:1;3444:15;3482:4;3479:1;3472:15;3255:242;3513:2;3506:22;3132:402;:::o;3539:367::-;3602:8;3612:6;3666:3;3659:4;3651:6;3647:17;3643:27;3633:55;;3684:1;3681;3674:12;3633:55;-1:-1:-1;3707:20:1;;3750:18;3739:30;;3736:50;;;3782:1;3779;3772:12;3736:50;3819:4;3811:6;3807:17;3795:29;;3879:3;3872:4;3862:6;3859:1;3855:14;3847:6;3843:27;3839:38;3836:47;3833:67;;;3896:1;3893;3886:12;3911:1086;4047:6;4055;4063;4071;4115:9;4106:7;4102:23;4145:3;4141:2;4137:12;4134:32;;;4162:1;4159;4152:12;4134:32;4185:29;4204:9;4185:29;:::i;:::-;4175:39;;4307:4;4238:66;4234:2;4230:75;4226:86;4223:106;;;4325:1;4322;4315:12;4223:106;;4351:17;;:::i;:::-;4419:2;4408:9;4404:18;4391:32;4384:5;4377:47;4484:2;4473:9;4469:18;4456:32;4451:2;4444:5;4440:14;4433:56;4521:37;4554:2;4543:9;4539:18;4521:37;:::i;:::-;4516:2;4505:14;;4498:61;4619:3;4604:19;;;4591:33;4586:2;4575:14;;4568:57;4686:4;4671:20;;4658:34;4641:15;;;4634:59;4509:5;-1:-1:-1;4768:3:1;4753:19;;4740:33;4796:18;4785:30;;4782:50;;;4828:1;4825;4818:12;4782:50;4867:70;4929:7;4920:6;4909:9;4905:22;4867:70;:::i;:::-;3911:1086;;;;-1:-1:-1;4956:8:1;-1:-1:-1;;;;3911:1086:1:o;5184:573::-;5288:6;5296;5304;5312;5365:2;5353:9;5344:7;5340:23;5336:32;5333:52;;;5381:1;5378;5371:12;5333:52;5417:9;5404:23;5394:33;;5474:2;5463:9;5459:18;5446:32;5436:42;;5529:2;5518:9;5514:18;5501:32;5556:18;5548:6;5545:30;5542:50;;;5588:1;5585;5578:12;6727:591;6797:6;6805;6858:2;6846:9;6837:7;6833:23;6829:32;6826:52;;;6874:1;6871;6864:12;6826:52;6914:9;6901:23;6943:18;6984:2;6976:6;6973:14;6970:34;;;7000:1;6997;6990:12;6970:34;7038:6;7027:9;7023:22;7013:32;;7083:7;7076:4;7072:2;7068:13;7064:27;7054:55;;7105:1;7102;7095:12;7054:55;7145:2;7132:16;7171:2;7163:6;7160:14;7157:34;;;7187:1;7184;7177:12;7157:34;7232:7;7227:2;7218:6;7214:2;7210:15;7206:24;7203:37;7200:57;;;7253:1;7250;7243:12;7200:57;7284:2;7276:11;;;;;7306:6;;-1:-1:-1;6727:591:1;;-1:-1:-1;;;;6727:591:1:o;7323:505::-;7418:6;7426;7434;7487:2;7475:9;7466:7;7462:23;7458:32;7455:52;;;7503:1;7500;7493:12;7455:52;7539:9;7526:23;7516:33;;7600:2;7589:9;7585:18;7572:32;7627:18;7619:6;7616:30;7613:50;;;7659:1;7656;7649:12;7613:50;7698:70;7760:7;7751:6;7740:9;7736:22;7698:70;:::i;:::-;7323:505;;7787:8;;-1:-1:-1;7672:96:1;;-1:-1:-1;;;;7323:505:1:o;8208:184::-;8260:77;8257:1;8250:88;8357:4;8354:1;8347:15;8381:4;8378:1;8371:15;8842:460;9139:42;9127:55;;9109:74;;9214:2;9199:18;;9192:34;;;9096:3;9081:19;;9235:61;9292:2;9277:18;;9269:6;2333:12;;2321:25;;2395:4;2384:16;;;2378:23;2362:14;;;2355:47;2451:4;2440:16;;;2434:23;2418:14;;2411:47;2252:212;10209:184;10261:77;10258:1;10251:88;10358:4;10355:1;10348:15;10382:4;10379:1;10372:15;10398:128;10465:9;;;10486:11;;;10483:37;;;10500:18;;:::i;10531:125::-;10596:9;;;10617:10;;;10614:36;;;10630:18;;:::i;10661:186::-;10720:6;10773:2;10761:9;10752:7;10748:23;10744:32;10741:52;;;10789:1;10786;10779:12;10741:52;10812:29;10831:9;10812:29;:::i;10852:250::-;10937:1;10947:113;10961:6;10958:1;10955:13;10947:113;;;11037:11;;;11031:18;11018:11;;;11011:39;10983:2;10976:10;10947:113;;;-1:-1:-1;;11094:1:1;11076:16;;11069:27;10852:250::o;11107:524::-;11282:6;11271:9;11264:25;11325:2;11320;11309:9;11305:18;11298:30;11245:4;11357:6;11351:13;11400:6;11395:2;11384:9;11380:18;11373:34;11416:79;11488:6;11483:2;11472:9;11468:18;11463:2;11455:6;11451:15;11416:79;:::i;:::-;11547:2;11535:15;11552:66;11531:88;11516:104;;;;11622:2;11512:113;;11107:524;-1:-1:-1;;;11107:524:1:o;11636:195::-;11675:3;11706:66;11699:5;11696:77;11693:103;;11776:18;;:::i;:::-;-1:-1:-1;11823:1:1;11812:13;;11636:195::o;11836:875::-;12072:4;12120:3;12109:9;12105:19;12151:6;12140:9;12133:25;12177:2;12215:6;12210:2;12199:9;12195:18;12188:34;12258:6;12253:2;12242:9;12238:18;12231:34;12301:3;12296:2;12285:9;12281:18;12274:31;12325:6;12355;12347;12340:22;12393:3;12382:9;12378:19;12371:26;;12420:6;12406:20;;12444:1;12454:231;12468:6;12465:1;12462:13;12454:231;;;12561:42;12533:26;12552:6;12533:26;:::i;:::-;12529:75;12517:88;;12660:15;;;;12625:12;;;;12490:1;12483:9;12454:231;;;-1:-1:-1;12702:3:1;11836:875;-1:-1:-1;;;;;;;;;11836:875:1:o;12716:447::-;12873:2;12862:9;12855:21;12912:6;12907:2;12896:9;12892:18;12885:34;12969:6;12961;12956:2;12945:9;12941:18;12928:48;13025:1;12996:22;;;13020:2;12992:31;;;12985:42;;;;13079:2;13067:15;;;13084:66;13063:88;13048:104;13044:113;;12716:447;-1:-1:-1;12716:447:1:o;13168:331::-;13273:9;13284;13326:8;13314:10;13311:24;13308:44;;;13348:1;13345;13338:12;13308:44;13377:6;13367:8;13364:20;13361:40;;;13397:1;13394;13387:12;13361:40;-1:-1:-1;;13423:23:1;;;13468:25;;;;;-1:-1:-1;13168:331:1:o;13504:731::-;13595:6;13648:2;13636:9;13627:7;13623:23;13619:32;13616:52;;;13664:1;13661;13654:12;13616:52;13697:2;13691:9;13739:2;13731:6;13727:15;13808:6;13796:10;13793:22;13772:18;13760:10;13757:34;13754:62;13751:242;;;13849:77;13846:1;13839:88;13950:4;13947:1;13940:15;13978:4;13975:1;13968:15;13751:242;14013:10;14009:2;14002:22;;14061:9;14048:23;14040:6;14033:39;14133:2;14122:9;14118:18;14105:32;14100:2;14092:6;14088:15;14081:57;14199:2;14188:9;14184:18;14171:32;14166:2;14158:6;14154:15;14147:57;14223:6;14213:16;;;13504:731;;;;:::o;14240:184::-;14310:6;14363:2;14351:9;14342:7;14338:23;14334:32;14331:52;;;14379:1;14376;14369:12;14331:52;-1:-1:-1;14402:16:1;;14240:184;-1:-1:-1;14240:184:1:o;14429:440::-;14636:66;14627:6;14622:3;14618:16;14614:89;14609:3;14602:102;14584:3;14733:6;14727:13;14749:74;14816:6;14812:1;14807:3;14803:11;14796:4;14788:6;14784:17;14749:74;:::i;:::-;14843:16;;;;14861:1;14839:24;;14429:440;-1:-1:-1;;;14429:440:1:o","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__BatchDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__BatchNotFinalized","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"},{"internalType":"bytes32","name":"existingBatchRoot","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"newBatch","type":"tuple"}],"name":"InterchainDB__ConflictingBatches","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"uint64","name":"batchSize","type":"uint64"}],"name":"InterchainDB__EntryIndexOutOfRange","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"InterchainDB__InvalidBatchVersion","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"InterchainDB__InvalidEntryRange","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainBatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"name":"InterchainBatchVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"},{"inputs":[],"name":"DB_VERSION","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"checkVerification","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatch","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatchLeafs","outputs":[{"internalType":"bytes32[]","name":"leafs","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"getBatchLeafsPaginated","outputs":[{"internalType":"bytes32[]","name":"leafs","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatchSize","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryProof","outputs":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryValue","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNextEntryIndex","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"versionedBatch","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"DB_VERSION()":{"notice":"Get the version of the Interchain DataBase."},"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"getBatch(uint256)":{"notice":"Get the finalized Interchain Batch with the given nonce."},"getBatchLeafs(uint256)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together)."},"getBatchLeafsPaginated(uint256,uint64,uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error."},"getBatchSize(uint256)":{"notice":"Returns the size of the finalized batch with the given nonce."},"getDBNonce()":{"notice":"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch."},"getEntryProof(uint256,uint64)":{"notice":"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce."},"getEntryValue(uint256,uint64)":{"notice":"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getNextEntryIndex()":{"notice":"Get the index of the next entry to be written to the database."},"requestBatchVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch."},"verifyRemoteBatch(bytes)":{"notice":"Allows the Interchain Module to verify the batch coming from the remote chain. Note: The DB will only accept the batch of the same version as the DB itself."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details."}},"version":1},"developerDoc":{"kind":"dev","methods":{"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry."}},"getBatch(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafs(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafsPaginated(uint256,uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.","params":{"dbNonce":"The database nonce of the finalized batch","end":"The end index of the paginated leafs, exclusive","start":"The start index of the paginated leafs, inclusive"}},"getBatchSize(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getEntryProof(uint256,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the finalized batch","entryIndex":"The index of the written entry within the batch"},"returns":{"proof":"      The Merkle proof of inclusion for the entry"}},"getEntryValue(uint256,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the existing batch","entryIndex":"The index of the written entry within the batch"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getNextEntryIndex()":{"returns":{"dbNonce":"     The database nonce of the batch including the next entry","entryIndex":"  The index of the next entry within that batch"}},"requestBatchVerification(uint256,uint256,address[])":{"details":"Will revert if the batch with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the existing batch","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyRemoteBatch(bytes)":{"params":{"versionedBatch":"The versioned Interchain Batch to verify"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__BatchDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__BatchNotFinalized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"existingBatchRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"newBatch\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingBatches\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"InterchainDB__InvalidBatchVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__InvalidEntryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainBatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"name\":\"InterchainBatchVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DB_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"checkVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatchLeafs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"leafs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafsPaginated\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"leafs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEntryIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedBatch\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry.\"}},\"getBatch(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafs(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafsPaginated(uint256,uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"end\":\"The end index of the paginated leafs, exclusive\",\"start\":\"The start index of the paginated leafs, inclusive\"}},\"getBatchSize(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getEntryProof(uint256,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"entryIndex\":\"The index of the written entry within the batch\"},\"returns\":{\"proof\":\"      The Merkle proof of inclusion for the entry\"}},\"getEntryValue(uint256,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"entryIndex\":\"The index of the written entry within the batch\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getNextEntryIndex()\":{\"returns\":{\"dbNonce\":\"     The database nonce of the batch including the next entry\",\"entryIndex\":\"  The index of the next entry within that batch\"}},\"requestBatchVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the batch with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyRemoteBatch(bytes)\":{\"params\":{\"versionedBatch\":\"The versioned Interchain Batch to verify\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DB_VERSION()\":{\"notice\":\"Get the version of the Interchain DataBase.\"},\"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"getBatch(uint256)\":{\"notice\":\"Get the finalized Interchain Batch with the given nonce.\"},\"getBatchLeafs(uint256)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\"},\"getBatchLeafsPaginated(uint256,uint64,uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error.\"},\"getBatchSize(uint256)\":{\"notice\":\"Returns the size of the finalized batch with the given nonce.\"},\"getDBNonce()\":{\"notice\":\"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch.\"},\"getEntryProof(uint256,uint64)\":{\"notice\":\"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce.\"},\"getEntryValue(uint256,uint64)\":{\"notice\":\"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getNextEntryIndex()\":{\"notice\":\"Get the index of the next entry to be written to the database.\"},\"requestBatchVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch.\"},\"verifyRemoteBatch(bytes)\":{\"notice\":\"Allows the Interchain Module to verify the batch coming from the remote chain. Note: The DB will only accept the batch of the same version as the DB itself.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{"DB_VERSION()":"15f53956","checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":"67b1f42e","getBatch(uint256)":"5ac44282","getBatchLeafs(uint256)":"d63020bb","getBatchLeafsPaginated(uint256,uint64,uint64)":"25a1641d","getBatchSize(uint256)":"b955e9b9","getDBNonce()":"f338140e","getEntryProof(uint256,uint64)":"4f84d040","getEntryValue(uint256,uint64)":"afa25005","getInterchainFee(uint256,address[])":"fc7686ec","getNextEntryIndex()":"aa2f06ae","requestBatchVerification(uint256,uint256,address[])":"84b1c8b8","verifyRemoteBatch(bytes)":"d961a48e","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainDB.sol:InterchainDBEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainBatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"name":"InterchainBatchVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainBatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"name\":\"InterchainBatchVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDBEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c5c6ee0a014b125b416a3cc318326615ebc8b7680afc484f616259d81bf64f3364736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c5c6ee0a014b125b416a3cc318326615ebc8b7680afc484f616259d81bf64f3364736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9515:1633:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9515:1633:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9515:1633:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207d26209ef83d193c97545339502f7624c8706bbfd9449b24ed2afaf83b4c319864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207d26209ef83d193c97545339502f7624c8706bbfd9449b24ed2afaf83b4c319864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"2274:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;2274:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"2274:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:VersionedPayloadLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220484454ce80d571e6e45c38907a45cbd50b51f427cfd88ee54c17b16a06d9a6e964736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220484454ce80d571e6e45c38907a45cbd50b51f427cfd88ee54c17b16a06d9a6e964736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n\n    event InterchainBatchVerified(address module, uint256 srcChainId, uint256 dbNonce, bytes32 batchRoot);\n\n    event InterchainBatchVerificationRequested(\n        uint256 dstChainId, uint256 dbNonce, bytes32 batchRoot, address[] srcModules\n    );\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId       The chain id of the destination chain\n    /// @param versionedBatch   The versioned batch to verify\n    function requestBatchVerification(uint256 dstChainId, bytes memory versionedBatch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/VersionedPayload.sol\n\n// solhint-disable no-inline-assembly\n// solhint-disable ordering\nlibrary VersionedPayloadLib {\n    /// @notice Amount of bytes reserved for the version (uint16) in the versioned payload\n    uint256 internal constant VERSION_LENGTH = 2;\n\n    error VersionedPayload__TooShort(bytes versionedPayload);\n    error VersionedPayload__PrecompileFailed();\n\n    /// @notice Encodes the versioned payload into a single bytes array.\n    /// @param version  The payload's version.\n    /// @param payload  The payload to encode.\n    function encodeVersionedPayload(uint16 version, bytes memory payload) internal pure returns (bytes memory) {\n        return abi.encodePacked(version, payload);\n    }\n\n    /// @notice Extracts the version from the versioned payload (calldata reference).\n    /// @param versionedPayload     The versioned payload (calldata reference).\n    function getVersion(bytes calldata versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            version := shr(240, calldataload(versionedPayload.offset))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (calldata reference).\n    /// @dev The extracted payload is also returned as a calldata reference.\n    /// @param versionedPayload     The versioned payload.\n    function getPayload(bytes calldata versionedPayload) internal pure returns (bytes calldata) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        return versionedPayload[VERSION_LENGTH:];\n    }\n\n    /// @notice Extracts the version from the versioned payload (memory reference).\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getVersionFromMemory(bytes memory versionedPayload) internal pure returns (uint16 version) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        assembly {\n            // We are only interested in the highest 16 bits of the loaded full 32 bytes word.\n            // We add 0x20 to skip the length of the bytes array.\n            version := shr(240, mload(add(versionedPayload, 0x20)))\n        }\n    }\n\n    /// @notice Extracts the payload from the versioned payload (memory reference).\n    /// @dev The extracted payload is copied into a new memory location. Use `getPayload` when possible\n    /// to avoid extra memory allocation.\n    /// @param versionedPayload     The versioned payload (memory reference).\n    function getPayloadFromMemory(bytes memory versionedPayload) internal view returns (bytes memory payload) {\n        if (versionedPayload.length \u003c VERSION_LENGTH) {\n            revert VersionedPayload__TooShort(versionedPayload);\n        }\n        // Figure how many bytes to copy and allocate the memory for the extracted payload.\n        uint256 toCopy;\n        unchecked {\n            toCopy = versionedPayload.length - VERSION_LENGTH;\n        }\n        payload = new bytes(toCopy);\n        // Use identity precompile (0x04) to copy the payload. Unlike MCOPY, this is available on all EVM chains.\n        bool res;\n        assembly {\n            // We add 0x20 to skip the length of the bytes array.\n            // We add 0x02 to skip the 2 bytes reserved for the version.\n            // Copy the payload to the previously allocated memory.\n            res := staticcall(gas(), 0x04, add(versionedPayload, 0x22), toCopy, add(payload, 0x20), toCopy)\n        }\n        if (!res) {\n            revert VersionedPayload__PrecompileFailed();\n        }\n    }\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    using VersionedPayloadLib for bytes;\n\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Encodes the InterchainBatch struct into a non-versioned batch payload.\n    function encodeBatch(InterchainBatch memory batch) internal pure returns (bytes memory) {\n        return abi.encode(batch);\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in calldata.\n    function decodeBatch(bytes calldata data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Decodes the InterchainBatch struct from a non-versioned batch payload in memory.\n    function decodeBatchFromMemory(bytes memory data) internal pure returns (InterchainBatch memory) {\n        return abi.decode(data, (InterchainBatch));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidBatchVersion(uint16 version);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// Note: The DB will only accept the batch of the same version as the DB itself.\n    /// @param versionedBatch   The versioned Interchain Batch to verify\n    function verifyRemoteBatch(bytes memory versionedBatch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n\n    /// @notice Get the version of the Interchain DataBase.\n    // solhint-disable-next-line func-name-mixedcase\n    function DB_VERSION() external pure returns (uint16);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    using VersionedPayloadLib for bytes;\n\n    uint16 public constant DB_VERSION = 1;\n\n    bytes32[] internal _entryValues;\n    mapping(address module =\u003e mapping(bytes32 batchKey =\u003e RemoteBatch batch)) internal _remoteBatches;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId(block.chainid);\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex) {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n    {\n        InterchainBatch memory batch = getBatch(dbNonce);\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(dstChainId)\n        returns (uint256 dbNonce, uint64 entryIndex)\n    {\n        InterchainEntry memory entry = _writeEntry(dataHash);\n        (dbNonce, entryIndex) = (entry.dbNonce, entry.entryIndex);\n        // In \"no batching\" mode: the batch root is the same as the entry value\n        InterchainBatch memory batch = InterchainBatchLib.constructLocalBatch(dbNonce, entry.entryValue());\n        _requestVerification(dstChainId, batch, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyRemoteBatch(bytes calldata versionedBatch) external {\n        uint16 dbVersion = versionedBatch.getVersion();\n        if (dbVersion != DB_VERSION) {\n            revert InterchainDB__InvalidBatchVersion(dbVersion);\n        }\n        InterchainBatch memory batch = InterchainBatchLib.decodeBatch(versionedBatch.getPayload());\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainDB__SameChainId(batch.srcChainId);\n        }\n        bytes32 batchKey = InterchainBatchLib.batchKey(batch);\n        RemoteBatch memory existingBatch = _remoteBatches[msg.sender][batchKey];\n        // Check if that's the first time module verifies the batch\n        if (existingBatch.verifiedAt == 0) {\n            _remoteBatches[msg.sender][batchKey] =\n                RemoteBatch({verifiedAt: block.timestamp, batchRoot: batch.batchRoot});\n            emit InterchainBatchVerified(msg.sender, batch.srcChainId, batch.dbNonce, batch.batchRoot);\n        } else {\n            // If the module has already verified the batch, check that the batch root is the same\n            if (existingBatch.batchRoot != batch.batchRoot) {\n                revert InterchainDB__ConflictingBatches(msg.sender, existingBatch.batchRoot, batch);\n            }\n            // No-op if the batch root is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory leafs)\n    {\n        if (start != 0 || end != 1) {\n            revert InterchainDB__InvalidEntryRange(dbNonce, start, end);\n        }\n        return getBatchLeafs(dbNonce);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof) {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        _assertBatchFinalized(dbNonce);\n        _assertEntryExists(dbNonce, entryIndex);\n        return new bytes32[](0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 dstChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(dstChainId, getDBNonce(), srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex) {\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        dbNonce = getDBNonce();\n        entryIndex = 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        // In \"no batching\" mode: the batch root is the same as the entry value, hence the proof is empty\n        if (proof.length != 0) {\n            // If proof is not empty, the batch root is not verified\n            return 0;\n        }\n        // In \"no batching\" mode: entry index is 0, batch size is 1\n        if (entry.entryIndex != 0) {\n            // If entry index is not 0, it does not belong to the batch\n            return 0;\n        }\n        RemoteBatch memory remoteBatch = _remoteBatches[dstModule][InterchainEntryLib.batchKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the batch root verified by the module\n        return remoteBatch.batchRoot == entryValue ? remoteBatch.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchLeafs(uint256 dbNonce) public view returns (bytes32[] memory leafs) {\n        // In \"no batching\" mode: the finalized batch size is 1\n        _assertBatchFinalized(dbNonce);\n        leafs = new bytes32[](1);\n        leafs[0] = getEntryValue(dbNonce, 0);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatchSize(uint256 dbNonce) public view returns (uint64) {\n        // In \"no batching\" mode: the finalized batch size is 1, the pending batch size is 0\n        uint256 pendingNonce = _assertBatchExists(dbNonce);\n        return dbNonce \u003c pendingNonce ? 1 : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getBatch(uint256 dbNonce) public view returns (InterchainBatch memory) {\n        _assertBatchFinalized(dbNonce);\n        // In \"no batching\" mode: the batch root is the same as the entry hash\n        return InterchainBatchLib.constructLocalBatch(dbNonce, getEntryValue(dbNonce, 0));\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) public view returns (bytes32) {\n        _assertEntryExists(dbNonce, entryIndex);\n        return _entryValues[dbNonce];\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entryValues.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (InterchainEntry memory entry) {\n        entry = InterchainEntryLib.constructLocalEntry({\n            dbNonce: getDBNonce(),\n            entryIndex: 0,\n            writer: msg.sender,\n            dataHash: dataHash\n        });\n        _entryValues.push(entry.entryValue());\n        emit InterchainEntryWritten(block.chainid, entry.dbNonce, entry.srcWriter, dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 dstChainId,\n        InterchainBatch memory batch,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(dstChainId, batch.dbNonce, srcModules);\n        if (msg.value \u003c totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        } else if (msg.value \u003e totalFee) {\n            // The exceeding amount goes to the first module\n            fees[0] += msg.value - totalFee;\n        }\n        uint256 len = srcModules.length;\n        bytes memory versionedBatch = VersionedPayloadLib.encodeVersionedPayload({\n            version: DB_VERSION,\n            payload: InterchainBatchLib.encodeBatch(batch)\n        });\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestBatchVerification{value: fees[i]}(dstChainId, versionedBatch);\n        }\n        emit InterchainBatchVerificationRequested(dstChainId, batch.dbNonce, batch.batchRoot, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Check that the batch with the given nonce exists and return the pending nonce.\n    function _assertBatchExists(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e pendingNonce) {\n            revert InterchainDB__BatchDoesNotExist(dbNonce);\n        }\n    }\n\n    /// @dev Check that the batch with the given nonce is finalized and return the pending nonce.\n    function _assertBatchFinalized(uint256 dbNonce) internal view returns (uint256 pendingNonce) {\n        pendingNonce = getDBNonce();\n        if (dbNonce \u003e= pendingNonce) {\n            revert InterchainDB__BatchNotFinalized(dbNonce);\n        }\n    }\n\n    /// @dev Check that the entry index is within the batch size. Also checks that the batch exists.\n    function _assertEntryExists(uint256 dbNonce, uint64 entryIndex) internal view {\n        // This will revert if the batch does not exist\n        uint64 batchSize = getBatchSize(dbNonce);\n        if (entryIndex \u003e= batchSize) {\n            revert InterchainDB__EntryIndexOutOfRange(dbNonce, entryIndex, batchSize);\n        }\n    }\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(dstChainId, dbNonce);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"2662:3757:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;2662:3757:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"2662:3757:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"VersionedPayload__PrecompileFailed","type":"error"},{"inputs":[{"internalType":"bytes","name":"versionedPayload","type":"bytes"}],"name":"VersionedPayload__TooShort","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"VersionedPayload__PrecompileFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"versionedPayload\",\"type\":\"bytes\"}],\"name\":\"VersionedPayload__TooShort\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"VersionedPayloadLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0x076528c639c479d6a5d8fb9c9067e1e031ade8a18563149d38645eb65316e07d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7a9aad5e568cb0b40daef4a358e023775bc276aa60ff83b354329c0acfe79e89\",\"dweb:/ipfs/QmUZ16PFUBoe9MFKG7QH5Y6Km8A7T12gTAEv3X8hLaTVXd\"]}},\"version\":1}"},"hashes":{}}}