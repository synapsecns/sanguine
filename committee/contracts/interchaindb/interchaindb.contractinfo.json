{"solidity/InterchainDB.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(uint256 destChainId, uint256 dbNonce, address[] srcModules);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    LocalEntry[] internal _entries;\n    mapping(address module =\u003e mapping(bytes32 entryKey =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(dbNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 dbNonce)\n    {\n        dbNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(dbNonce, msg.sender, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryKey = InterchainEntryLib.entryKey(entry);\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[msg.sender][entryKey];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[msg.sender][entryKey] = RemoteEntry({verifiedAt: block.timestamp, entryValue: entryValue});\n            emit InterchainEntryVerified(msg.sender, entry.srcChainId, entry.dbNonce, entry.srcWriter, entry.dataHash);\n        } else {\n            // If the module has already verified the entry, check that the entry value is the same\n            if (existingEntry.entryValue != entryValue) {\n                revert InterchainDB__ConflictingEntries(existingEntry.entryValue, entry);\n            }\n            // No-op if the entry value is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[dstModule][InterchainEntryLib.entryKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the one verified by the module\n        return remoteEntry.entryValue == entryValue ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(uint256 dbNonce) public view returns (InterchainEntry memory) {\n        if (getDBNonce() \u003c= dbNonce) {\n            revert InterchainDB__EntryDoesNotExist(dbNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(dbNonce, _entries[dbNonce].writer, _entries[dbNonce].dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entries.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 dbNonce) {\n        dbNonce = _entries.length;\n        _entries.push(LocalEntry(msg.sender, dataHash));\n        emit InterchainEntryWritten(block.chainid, dbNonce, TypeCasts.addressToBytes32(msg.sender), dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.dbNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingEntryValue","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getDBNonce()":{"notice":"Get the nonce of the database."},"getEntry(uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingEntryValue\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDBNonce()\":{\"notice\":\"Get the nonce of the database.\"},\"getEntry(uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0xc20920e16f30c1f0b71115ed36050a73e7815e2b4626d34d641ec330bc4eff9f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://849d6e578031903b64b455e11ac821bd3ef81e19a32b9924363ffa02ccb2e74f\",\"dweb:/ipfs/QmWVtBXKJ96Y5FGLX3cfzGUehgHZTJHLxi8kHgmW2rTsUd\"]}},\"version\":1}"},"hashes":{"getDBNonce()":"f338140e","getEntry(uint256)":"bae78d7b","getInterchainFee(uint256,address[])":"fc7686ec","readEntry(address,(uint256,uint256,bytes32,bytes32))":"a9c9cff1","requestVerification(uint256,uint256,address[])":"81ab5b5a","verifyEntry((uint256,uint256,bytes32,bytes32))":"54941dfa","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainDB.sol:IInterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(uint256 destChainId, uint256 dbNonce, address[] srcModules);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    LocalEntry[] internal _entries;\n    mapping(address module =\u003e mapping(bytes32 entryKey =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(dbNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 dbNonce)\n    {\n        dbNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(dbNonce, msg.sender, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryKey = InterchainEntryLib.entryKey(entry);\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[msg.sender][entryKey];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[msg.sender][entryKey] = RemoteEntry({verifiedAt: block.timestamp, entryValue: entryValue});\n            emit InterchainEntryVerified(msg.sender, entry.srcChainId, entry.dbNonce, entry.srcWriter, entry.dataHash);\n        } else {\n            // If the module has already verified the entry, check that the entry value is the same\n            if (existingEntry.entryValue != entryValue) {\n                revert InterchainDB__ConflictingEntries(existingEntry.entryValue, entry);\n            }\n            // No-op if the entry value is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[dstModule][InterchainEntryLib.entryKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the one verified by the module\n        return remoteEntry.entryValue == entryValue ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(uint256 dbNonce) public view returns (InterchainEntry memory) {\n        if (getDBNonce() \u003c= dbNonce) {\n            revert InterchainDB__EntryDoesNotExist(dbNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(dbNonce, _entries[dbNonce].writer, _entries[dbNonce].dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entries.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 dbNonce) {\n        dbNonce = _entries.length;\n        _entries.push(LocalEntry(msg.sender, dataHash));\n        emit InterchainEntryWritten(block.chainid, dbNonce, TypeCasts.addressToBytes32(msg.sender), dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.dbNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256)":{"notice":"Get the Module fee for verifying an entry on the specified destination chain"},"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":{"notice":"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering."}},"notice":"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256)":{"params":{"destChainId":"The chain id of the destination chain"}},"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"destChainId":"The chain id of the destination chain","entry":"The entry to verify"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256)\":{\"params\":{\"destChainId\":\"The chain id of the destination chain\"}},\"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"entry\":\"The entry to verify\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256)\":{\"notice\":\"Get the Module fee for verifying an entry on the specified destination chain\"},\"requestVerification(uint256,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Request the verification of an entry in the Interchain DataBase by the module. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"IInterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0xc20920e16f30c1f0b71115ed36050a73e7815e2b4626d34d641ec330bc4eff9f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://849d6e578031903b64b455e11ac821bd3ef81e19a32b9924363ffa02ccb2e74f\",\"dweb:/ipfs/QmWVtBXKJ96Y5FGLX3cfzGUehgHZTJHLxi8kHgmW2rTsUd\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint256)":"dc8e4f89","requestVerification(uint256,(uint256,uint256,bytes32,bytes32))":"f6bc485f"}},"solidity/InterchainDB.sol:InterchainDB":{"code":"0x608060405234801561001057600080fd5b50610e5c806100206000396000f3fe60806040526004361061007b5760003560e01c8063a9c9cff11161004e578063a9c9cff1146100fb578063bae78d7b1461011b578063f338140e14610148578063fc7686ec1461015d57600080fd5b80632ad8c7061461008057806354941dfa146100b357806367c769af146100d557806381ab5b5a146100e8575b600080fd5b34801561008c57600080fd5b506100a061009b366004610a46565b61017d565b6040519081526020015b60405180910390f35b3480156100bf57600080fd5b506100d36100ce366004610b1b565b61018e565b005b6100a06100e3366004610b83565b610306565b6100d36100f6366004610b83565b610372565b34801561010757600080fd5b506100a0610116366004610bff565b6103cd565b34801561012757600080fd5b5061013b610136366004610a46565b610495565b6040516100aa9190610c33565b34801561015457600080fd5b506000546100a0565b34801561016957600080fd5b506100a0610178366004610c5e565b61055f565b600061018882610575565b92915050565b80514681036101c9576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006101d48361067b565b905060006101e1846106be565b3360009081526001602081815260408084208785528252808420815180830190925280548083529301549181019190915292935090036102b157604080518082018252428152602080820185815233600081815260018085528682208a83528552908690209451855591519390910192909255875188820151898501516060808c01518751968752948601939093528486019190915290830152608082015290517f4f9d94cde48123382edd2a9ec240776059a572966248417c46beda48e29430699181900360a00190a16102ff565b818160200151146102ff578060200151856040517fa02862df0000000000000000000000000000000000000000000000000000000081526004016102f6929190610caa565b60405180910390fd5b5050505050565b600084468103610342576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61034b85610575565b9150600061035a8333886106e4565b90506103688782878761074e565b5050949350505050565b834681036103ac576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006103b785610495565b90506103c58682868661074e565b505050505050565b805160009046810361040b576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff841660009081526001602052604081208161043a8661067b565b81526020019081526020016000206040518060400160405290816000820154815260200160018201548152505090506000610474856106be565b90508082602001511461048857600061048b565b81515b9695505050505050565b6040805160808101825260008082526020820181905291810182905260608101829052905482106104f5576040517f4efb6ab4000000000000000000000000000000000000000000000000000000008152600481018390526024016102f6565b610188826000848154811061050c5761050c610cdf565b60009182526020822060029091020154815473ffffffffffffffffffffffffffffffffffffffff90911691908690811061054857610548610cdf565b9060005260206000209060020201600101546106e4565b600061056c8484846108b7565b95945050505050565b600080546040805180820182523380825260208083018781526001860187559580529151600285027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5638101805473ffffffffffffffffffffffffffffffffffffffff9093167fffffffffffffffffffffffff00000000000000000000000000000000000000009093169290921790915594517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56490950194909455815146815290810183905280820193909352606083018490525190917f8adbf0953083a65c138963c649cd1eabd31fa900ecd1cd5d6b5b530fbfa41771919081900360800190a1919050565b6000816000015182602001516040516020016106a1929190918252602082015260400190565b604051602081830303815290604052805190602001209050919050565b6000816040015182606001516040516020016106a1929190918252602082015260400190565b604080516080810182526000808252602082018190529181018290526060810191909152604051806080016040528046815260200185815260200161073c8573ffffffffffffffffffffffffffffffffffffffff1690565b815260200183905290505b9392505050565b60008061075c8685856108b7565b915091508034146107a2576040517ffb7d6610000000000000000000000000000000000000000000000000000000008152346004820152602481018290526044016102f6565b8260005b8181101561086c578585828181106107c0576107c0610cdf565b90506020020160208101906107d59190610d0e565b73ffffffffffffffffffffffffffffffffffffffff1663f6bc485f85838151811061080257610802610cdf565b60200260200101518a8a6040518463ffffffff1660e01b8152600401610829929190610caa565b6000604051808303818588803b15801561084257600080fd5b505af1158015610856573d6000803e3d6000fd5b50505050508061086590610d58565b90506107a6565b507ff7a707ad4de78d7f649f2084d1f8bfbb2147be1a4b408c98bbb298fc3391242c87876020015187876040516108a69493929190610d90565b60405180910390a150505050505050565b60606000828082036108f5576040517f98ca492a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff81111561090e5761090e610a5f565b604051908082528060200260200182016040528015610937578160200160208202803683370190505b50925060005b81811015610a3c5785858281811061095757610957610cdf565b905060200201602081019061096c9190610d0e565b73ffffffffffffffffffffffffffffffffffffffff1663dc8e4f89886040518263ffffffff1660e01b81526004016109a691815260200190565b602060405180830381865afa1580156109c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e79190610dfa565b8482815181106109f9576109f9610cdf565b602002602001018181525050838181518110610a1757610a17610cdf565b602002602001015183610a2a9190610e13565b9250610a3581610d58565b905061093d565b5050935093915050565b600060208284031215610a5857600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060808284031215610aa057600080fd5b6040516080810181811067ffffffffffffffff82111715610aea577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b600060808284031215610b2d57600080fd5b6107478383610a8e565b60008083601f840112610b4957600080fd5b50813567ffffffffffffffff811115610b6157600080fd5b6020830191508360208260051b8501011115610b7c57600080fd5b9250929050565b60008060008060608587031215610b9957600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610bbe57600080fd5b610bca87828801610b37565b95989497509550505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610bfa57600080fd5b919050565b60008060a08385031215610c1257600080fd5b610c1b83610bd6565b9150610c2a8460208501610a8e565b90509250929050565b8151815260208083015190820152604080830151908201526060808301519082015260808101610188565b600080600060408486031215610c7357600080fd5b83359250602084013567ffffffffffffffff811115610c9157600080fd5b610c9d86828701610b37565b9497909650939450505050565b82815260a081016107476020830184805182526020810151602083015260408101516040830152606081015160608301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060208284031215610d2057600080fd5b61074782610bd6565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610d8957610d89610d29565b5060010190565b84815260208082018590526060604083018190528201839052600090849060808401835b86811015610ded5773ffffffffffffffffffffffffffffffffffffffff610dda85610bd6565b1682529282019290820190600101610db4565b5098975050505050505050565b600060208284031215610e0c57600080fd5b5051919050565b8082018082111561018857610188610d2956fea26469706673582212200820278f52e871107566f5c0d7afa858fa3692db5e6eb75a21b12270b34bd12d64736f6c63430008140033","runtime-code":"0x60806040526004361061007b5760003560e01c8063a9c9cff11161004e578063a9c9cff1146100fb578063bae78d7b1461011b578063f338140e14610148578063fc7686ec1461015d57600080fd5b80632ad8c7061461008057806354941dfa146100b357806367c769af146100d557806381ab5b5a146100e8575b600080fd5b34801561008c57600080fd5b506100a061009b366004610a46565b61017d565b6040519081526020015b60405180910390f35b3480156100bf57600080fd5b506100d36100ce366004610b1b565b61018e565b005b6100a06100e3366004610b83565b610306565b6100d36100f6366004610b83565b610372565b34801561010757600080fd5b506100a0610116366004610bff565b6103cd565b34801561012757600080fd5b5061013b610136366004610a46565b610495565b6040516100aa9190610c33565b34801561015457600080fd5b506000546100a0565b34801561016957600080fd5b506100a0610178366004610c5e565b61055f565b600061018882610575565b92915050565b80514681036101c9576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006101d48361067b565b905060006101e1846106be565b3360009081526001602081815260408084208785528252808420815180830190925280548083529301549181019190915292935090036102b157604080518082018252428152602080820185815233600081815260018085528682208a83528552908690209451855591519390910192909255875188820151898501516060808c01518751968752948601939093528486019190915290830152608082015290517f4f9d94cde48123382edd2a9ec240776059a572966248417c46beda48e29430699181900360a00190a16102ff565b818160200151146102ff578060200151856040517fa02862df0000000000000000000000000000000000000000000000000000000081526004016102f6929190610caa565b60405180910390fd5b5050505050565b600084468103610342576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61034b85610575565b9150600061035a8333886106e4565b90506103688782878761074e565b5050949350505050565b834681036103ac576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006103b785610495565b90506103c58682868661074e565b505050505050565b805160009046810361040b576040517f0e4de95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff841660009081526001602052604081208161043a8661067b565b81526020019081526020016000206040518060400160405290816000820154815260200160018201548152505090506000610474856106be565b90508082602001511461048857600061048b565b81515b9695505050505050565b6040805160808101825260008082526020820181905291810182905260608101829052905482106104f5576040517f4efb6ab4000000000000000000000000000000000000000000000000000000008152600481018390526024016102f6565b610188826000848154811061050c5761050c610cdf565b60009182526020822060029091020154815473ffffffffffffffffffffffffffffffffffffffff90911691908690811061054857610548610cdf565b9060005260206000209060020201600101546106e4565b600061056c8484846108b7565b95945050505050565b600080546040805180820182523380825260208083018781526001860187559580529151600285027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5638101805473ffffffffffffffffffffffffffffffffffffffff9093167fffffffffffffffffffffffff00000000000000000000000000000000000000009093169290921790915594517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56490950194909455815146815290810183905280820193909352606083018490525190917f8adbf0953083a65c138963c649cd1eabd31fa900ecd1cd5d6b5b530fbfa41771919081900360800190a1919050565b6000816000015182602001516040516020016106a1929190918252602082015260400190565b604051602081830303815290604052805190602001209050919050565b6000816040015182606001516040516020016106a1929190918252602082015260400190565b604080516080810182526000808252602082018190529181018290526060810191909152604051806080016040528046815260200185815260200161073c8573ffffffffffffffffffffffffffffffffffffffff1690565b815260200183905290505b9392505050565b60008061075c8685856108b7565b915091508034146107a2576040517ffb7d6610000000000000000000000000000000000000000000000000000000008152346004820152602481018290526044016102f6565b8260005b8181101561086c578585828181106107c0576107c0610cdf565b90506020020160208101906107d59190610d0e565b73ffffffffffffffffffffffffffffffffffffffff1663f6bc485f85838151811061080257610802610cdf565b60200260200101518a8a6040518463ffffffff1660e01b8152600401610829929190610caa565b6000604051808303818588803b15801561084257600080fd5b505af1158015610856573d6000803e3d6000fd5b50505050508061086590610d58565b90506107a6565b507ff7a707ad4de78d7f649f2084d1f8bfbb2147be1a4b408c98bbb298fc3391242c87876020015187876040516108a69493929190610d90565b60405180910390a150505050505050565b60606000828082036108f5576040517f98ca492a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8067ffffffffffffffff81111561090e5761090e610a5f565b604051908082528060200260200182016040528015610937578160200160208202803683370190505b50925060005b81811015610a3c5785858281811061095757610957610cdf565b905060200201602081019061096c9190610d0e565b73ffffffffffffffffffffffffffffffffffffffff1663dc8e4f89886040518263ffffffff1660e01b81526004016109a691815260200190565b602060405180830381865afa1580156109c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e79190610dfa565b8482815181106109f9576109f9610cdf565b602002602001018181525050838181518110610a1757610a17610cdf565b602002602001015183610a2a9190610e13565b9250610a3581610d58565b905061093d565b5050935093915050565b600060208284031215610a5857600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060808284031215610aa057600080fd5b6040516080810181811067ffffffffffffffff82111715610aea577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b600060808284031215610b2d57600080fd5b6107478383610a8e565b60008083601f840112610b4957600080fd5b50813567ffffffffffffffff811115610b6157600080fd5b6020830191508360208260051b8501011115610b7c57600080fd5b9250929050565b60008060008060608587031215610b9957600080fd5b8435935060208501359250604085013567ffffffffffffffff811115610bbe57600080fd5b610bca87828801610b37565b95989497509550505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610bfa57600080fd5b919050565b60008060a08385031215610c1257600080fd5b610c1b83610bd6565b9150610c2a8460208501610a8e565b90509250929050565b8151815260208083015190820152604080830151908201526060808301519082015260808101610188565b600080600060408486031215610c7357600080fd5b83359250602084013567ffffffffffffffff811115610c9157600080fd5b610c9d86828701610b37565b9497909650939450505050565b82815260a081016107476020830184805182526020810151602083015260408101516040830152606081015160608301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060208284031215610d2057600080fd5b61074782610bd6565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610d8957610d89610d29565b5060010190565b84815260208082018590526060604083018190528201839052600090849060808401835b86811015610ded5773ffffffffffffffffffffffffffffffffffffffff610dda85610bd6565b1682529282019290820190600101610db4565b5098975050505050505050565b600060208284031215610e0c57600080fd5b5051919050565b8082018082111561018857610188610d2956fea26469706673582212200820278f52e871107566f5c0d7afa858fa3692db5e6eb75a21b12270b34bd12d64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(uint256 destChainId, uint256 dbNonce, address[] srcModules);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    LocalEntry[] internal _entries;\n    mapping(address module =\u003e mapping(bytes32 entryKey =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(dbNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 dbNonce)\n    {\n        dbNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(dbNonce, msg.sender, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryKey = InterchainEntryLib.entryKey(entry);\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[msg.sender][entryKey];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[msg.sender][entryKey] = RemoteEntry({verifiedAt: block.timestamp, entryValue: entryValue});\n            emit InterchainEntryVerified(msg.sender, entry.srcChainId, entry.dbNonce, entry.srcWriter, entry.dataHash);\n        } else {\n            // If the module has already verified the entry, check that the entry value is the same\n            if (existingEntry.entryValue != entryValue) {\n                revert InterchainDB__ConflictingEntries(existingEntry.entryValue, entry);\n            }\n            // No-op if the entry value is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[dstModule][InterchainEntryLib.entryKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the one verified by the module\n        return remoteEntry.entryValue == entryValue ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(uint256 dbNonce) public view returns (InterchainEntry memory) {\n        if (getDBNonce() \u003c= dbNonce) {\n            revert InterchainDB__EntryDoesNotExist(dbNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(dbNonce, _entries[dbNonce].writer, _entries[dbNonce].dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entries.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 dbNonce) {\n        dbNonce = _entries.length;\n        _entries.push(LocalEntry(msg.sender, dataHash));\n        emit InterchainEntryWritten(block.chainid, dbNonce, TypeCasts.addressToBytes32(msg.sender), dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.dbNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9669:7153:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"9669:7153:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;10392:118;;;;;;;;;;-1:-1:-1;10392:118:0;;;;;:::i;:::-;;:::i;:::-;;;345:25:1;;;333:2;318:18;10392:118:0;;;;;;;;11745:1007;;;;;;;;;;-1:-1:-1;11745:1007:0;;;;;:::i;:::-;;:::i;:::-;;10921:466;;;;;;:::i;:::-;;:::i;10550:331::-;;;;;;:::i;:::-;;:::i;13126:539::-;;;;;;;;;;-1:-1:-1;13126:539:0;;;;;:::i;:::-;;:::i;13925:315::-;;;;;;;;;;-1:-1:-1;13925:315:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;14280:91::-;;;;;;;;;;-1:-1:-1;14323:7:0;14349:15;14280:91;;13705:180;;;;;;;;;;-1:-1:-1;13705:180:0;;;;;:::i;:::-;;:::i;10392:118::-;10448:15;10482:21;10494:8;10482:11;:21::i;:::-;10475:28;10392:118;-1:-1:-1;;10392:118:0:o;11745:1007::-;11823:16;;9943:13;9932:24;;9928:89;;9979:27;;;;;;;;;;;;;;9928:89;11851:16:::1;11870:34;11898:5;11870:27;:34::i;:::-;11851:53;;11914:18;11935:36;11965:5;11935:29;:36::i;:::-;12031:10;11981:32;12016:26:::0;;;:14:::1;:26;::::0;;;;;;;:36;;;;;;;;11981:71;;;;::::1;::::0;;;;;;;;;::::1;::::0;;;::::1;::::0;;;;11914:57;;-1:-1:-1;12134:29:0;;12130:616:::1;;12218:66;::::0;;;;::::1;::::0;;12243:15:::1;12218:66:::0;;::::1;::::0;;::::1;::::0;;;12194:10:::1;-1:-1:-1::0;12179:26:0;;;:14:::1;:26:::0;;;;;;:36;;;;;;;;;:105;;;;;;;;;::::1;::::0;;;;12339:16;;12357:13;;::::1;::::0;12372:15;;::::1;::::0;12389:14:::1;::::0;;::::1;::::0;12303:101;;5137:74:1;;;5227:18;;;5220:34;;;;5270:18;;;5263:34;;;;5313:18;;;5306:34;5371:3;5356:19;;5349:35;12303:101:0;;::::1;::::0;;;;5124:3:1;12303:101:0;;::::1;12130:616;;;12567:10;12539:13;:24;;;:38;12535:149;;12637:13;:24;;;12663:5;12604:65;;;;;;;;;;;;:::i;:::-;;;;;;;;12535:149;11841:911;;;11745:1007:::0;;:::o;10921:466::-;11146:15;11116:11;9943:13;9932:7;:24;9928:89;;9979:27;;;;;;;;;;;;;;9928:89;11187:21:::1;11199:8;11187:11;:21::i;:::-;11177:31;;11218:28;11249:69;11288:7;11297:10;11309:8;11249:38;:69::i;:::-;11218:100;;11328:52;11349:11;11362:5;11369:10;;11328:20;:52::i;:::-;11167:220;10921:466:::0;;;;;;;:::o;10550:331::-;10737:11;9943:13;9932:7;:24;9928:89;;9979:27;;;;;;;;;;;;;;9928:89;10764:28:::1;10795:17;10804:7;10795:8;:17::i;:::-;10764:48;;10822:52;10843:11;10856:5;10863:10;;10822:20;:52::i;:::-;10754:127;10550:331:::0;;;;;:::o;13126:539::-;13272:16;;13307:24;;9943:13;9932:24;;9928:89;;9979:27;;;;;;;;;;;;;;9928:89;13380:25:::1;::::0;::::1;13347:30;13380:25:::0;;;:14:::1;:25;::::0;;;;13347:30;13406:34:::1;13434:5:::0;13406:27:::1;:34::i;:::-;13380:61;;;;;;;;;;;13347:94;;;;;;;;;;;;;;;;;;;;;;;::::0;::::1;;;13451:18;13472:36;13502:5;13472:29;:36::i;:::-;13451:57;;13619:10;13593:11;:22;;;:36;:65;;13657:1;13593:65;;;13632:22:::0;;13593:65:::1;13586:72:::0;13126:539;-1:-1:-1;;;;;;13126:539:0:o;13925:315::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14349:15:0;;14035:7;-1:-1:-1;14015:101:0;;14065:40;;;;;;;;345:25:1;;;318:18;;14065:40:0;199:177:1;14015:101:0;14132;14171:7;14180:8;14189:7;14180:17;;;;;;;;:::i;:::-;;;;;;;;;;;;;:24;14206:17;;14180:24;;;;;:17;14215:7;;14206:17;;;;;;:::i;:::-;;;;;;;;;;;:26;;;14132:38;:101::i;13705:180::-;13806:11;13839:39;13854:11;13867:10;;13839:14;:39::i;:::-;13829:49;13705:180;-1:-1:-1;;;;;13705:180:0:o;14758:284::-;14815:15;14852;;14891:32;;;;;;;;14902:10;14891:32;;;;;;;;;;14877:47;;;;;;;;;;;;;;;;;;14891:32;14877:47;;;;;;;;;;;;;;;;;;;;;;;;14939:96;;14962:13;6158:25:1;;6199:18;;;6192:34;;;6242:18;;;6235:34;;;;6300:2;6285:18;;6278:34;;;14939:96:0;14852:15;;14939:96;;;;;;6145:3:1;14939:96:0;;;14758:284;;;:::o;2371:158::-;2442:7;2489:5;:16;;;2507:5;:13;;;2478:43;;;;;;;;6497:25:1;;;6553:2;6538:18;;6531:34;6485:2;6470:18;;6323:248;2478:43:0;;;;;;;;;;;;;2468:54;;;;;;2461:61;;2371:158;;;:::o;2617:160::-;2690:7;2737:5;:15;;;2754:5;:14;;;2726:43;;;;;;;;6497:25:1;;;6553:2;6538:18;;6531:34;6485:2;6470:18;;6323:248;1895:402:0;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2103:187:0;;;;;;;;2145:13;2103:187;;;;2181:7;2103:187;;;;2213:34;2240:6;689:22;;;592:127;2213:34;2103:187;;;;;;;2096:194;-1:-1:-1;1895:402:0;;;;;;:::o;15245:667::-;15419:21;15442:16;15462:39;15477:11;15490:10;;15462:14;:39::i;:::-;15418:83;;;;15528:8;15515:9;:21;15511:112;;15559:53;;;;;15592:9;15559:53;;;6497:25:1;6538:18;;;6531:34;;;6470:18;;15559:53:0;6323:248:1;15511:112:0;15646:10;15632:11;15673:147;15697:3;15693:1;:7;15673:147;;;15739:10;;15750:1;15739:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;15721:52;;;15781:4;15786:1;15781:7;;;;;;;;:::i;:::-;;;;;;;15790:11;15803:5;15721:88;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;15702:3;;;;:::i;:::-;;;15673:147;;;;15834:71;15866:11;15879:5;:13;;;15894:10;;15834:71;;;;;;;;;:::i;:::-;;;;;;;;15408:504;;;15245:667;;;;:::o;16289:531::-;16434:21;16457:16;16503:10;16534:8;;;16530:80;;16565:34;;;;;;;;;;;;;;16530:80;16640:3;16626:18;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;16626:18:0;;16619:25;;16659:9;16654:160;16678:3;16674:1;:7;16654:160;;;16730:10;;16741:1;16730:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;16712:45;;;16758:11;16712:58;;;;;;;;;;;;;345:25:1;;333:2;318:18;;199:177;16712:58:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;16702:4;16707:1;16702:7;;;;;;;;:::i;:::-;;;;;;:68;;;;;16796:4;16801:1;16796:7;;;;;;;;:::i;:::-;;;;;;;16784:19;;;;;:::i;:::-;;-1:-1:-1;16683:3:0;;;:::i;:::-;;;16654:160;;;;16479:341;16289:531;;;;;;:::o;14:180:1:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;-1:-1:-1;165:23:1;;14:180;-1:-1:-1;14:180:1:o;381:184::-;433:77;430:1;423:88;530:4;527:1;520:15;554:4;551:1;544:15;570:766;632:5;680:4;668:9;663:3;659:19;655:30;652:50;;;698:1;695;688:12;652:50;731:2;725:9;773:4;765:6;761:17;844:6;832:10;829:22;808:18;796:10;793:34;790:62;787:242;;;885:77;882:1;875:88;986:4;983:1;976:15;1014:4;1011:1;1004:15;787:242;1049:10;1045:2;1038:22;;1078:6;1069:15;;1121:9;1108:23;1100:6;1093:39;1193:2;1182:9;1178:18;1165:32;1160:2;1152:6;1148:15;1141:57;1259:2;1248:9;1244:18;1231:32;1226:2;1218:6;1214:15;1207:57;1325:2;1314:9;1310:18;1297:32;1292:2;1284:6;1280:15;1273:57;;570:766;;;;:::o;1341:242::-;1431:6;1484:3;1472:9;1463:7;1459:23;1455:33;1452:53;;;1501:1;1498;1491:12;1452:53;1524;1569:7;1558:9;1524:53;:::i;1588:367::-;1651:8;1661:6;1715:3;1708:4;1700:6;1696:17;1692:27;1682:55;;1733:1;1730;1723:12;1682:55;-1:-1:-1;1756:20:1;;1799:18;1788:30;;1785:50;;;1831:1;1828;1821:12;1785:50;1868:4;1860:6;1856:17;1844:29;;1928:3;1921:4;1911:6;1908:1;1904:14;1896:6;1892:27;1888:38;1885:47;1882:67;;;1945:1;1942;1935:12;1882:67;1588:367;;;;;:::o;1960:573::-;2064:6;2072;2080;2088;2141:2;2129:9;2120:7;2116:23;2112:32;2109:52;;;2157:1;2154;2147:12;2109:52;2193:9;2180:23;2170:33;;2250:2;2239:9;2235:18;2222:32;2212:42;;2305:2;2294:9;2290:18;2277:32;2332:18;2324:6;2321:30;2318:50;;;2364:1;2361;2354:12;2318:50;2403:70;2465:7;2456:6;2445:9;2441:22;2403:70;:::i;:::-;1960:573;;;;-1:-1:-1;2492:8:1;-1:-1:-1;;;;1960:573:1:o;3116:196::-;3184:20;;3244:42;3233:54;;3223:65;;3213:93;;3302:1;3299;3292:12;3213:93;3116:196;;;:::o;3317:316::-;3416:6;3424;3477:3;3465:9;3456:7;3452:23;3448:33;3445:53;;;3494:1;3491;3484:12;3445:53;3517:29;3536:9;3517:29;:::i;:::-;3507:39;;3565:62;3619:7;3614:2;3603:9;3599:18;3565:62;:::i;:::-;3555:72;;3317:316;;;;;:::o;4096:267::-;3904:12;;3892:25;;3966:4;3955:16;;;3949:23;3933:14;;;3926:47;4022:4;4011:16;;;4005:23;3989:14;;;3982:47;4078:4;4067:16;;;4061:23;4045:14;;;4038:47;4292:3;4277:19;;4305:52;3823:268;4368:505;4463:6;4471;4479;4532:2;4520:9;4511:7;4507:23;4503:32;4500:52;;;4548:1;4545;4538:12;4500:52;4584:9;4571:23;4561:33;;4645:2;4634:9;4630:18;4617:32;4672:18;4664:6;4661:30;4658:50;;;4704:1;4701;4694:12;4658:50;4743:70;4805:7;4796:6;4785:9;4781:22;4743:70;:::i;:::-;4368:505;;4832:8;;-1:-1:-1;4717:96:1;;-1:-1:-1;;;;4368:505:1:o;5395:338::-;5632:25;;;5619:3;5604:19;;5666:61;5723:2;5708:18;;5700:6;3910:5;3904:12;3899:3;3892:25;3966:4;3959:5;3955:16;3949:23;3942:4;3937:3;3933:14;3926:47;4022:4;4015:5;4011:16;4005:23;3998:4;3993:3;3989:14;3982:47;4078:4;4071:5;4067:16;4061:23;4054:4;4049:3;4045:14;4038:47;;;3823:268;5738:184;5790:77;5787:1;5780:88;5887:4;5884:1;5877:15;5911:4;5908:1;5901:15;6829:186;6888:6;6941:2;6929:9;6920:7;6916:23;6912:32;6909:52;;;6957:1;6954;6947:12;6909:52;6980:29;6999:9;6980:29;:::i;7363:184::-;7415:77;7412:1;7405:88;7512:4;7509:1;7502:15;7536:4;7533:1;7526:15;7552:195;7591:3;7622:66;7615:5;7612:77;7609:103;;7692:18;;:::i;:::-;-1:-1:-1;7739:1:1;7728:13;;7552:195::o;7752:802::-;8020:25;;;8064:2;8082:18;;;8075:34;;;8008:2;8140;8125:18;;8118:30;;;7993:18;;8183:22;;;7960:4;;8263:6;;8236:3;8221:19;;7960:4;8297:231;8311:6;8308:1;8305:13;8297:231;;;8404:42;8376:26;8395:6;8376:26;:::i;:::-;8372:75;8360:88;;8503:15;;;;8468:12;;;;8333:1;8326:9;8297:231;;;-1:-1:-1;8545:3:1;7752:802;-1:-1:-1;;;;;;;;7752:802:1:o;8559:184::-;8629:6;8682:2;8670:9;8661:7;8657:23;8653:32;8650:52;;;8698:1;8695;8688:12;8650:52;-1:-1:-1;8721:16:1;;8559:184;-1:-1:-1;8559:184:1:o;8748:125::-;8813:9;;;8834:10;;;8831:36;;;8847:18;;:::i","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"existingEntryValue","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"newEntry","type":"tuple"}],"name":"InterchainDB__ConflictingEntries","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__EntryDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[],"name":"InterchainDB__SameChainId","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"destChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainVerificationRequested","type":"event"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getEntry","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"readEntry","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"}],"name":"verifyEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"destChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getDBNonce()":{"notice":"Get the nonce of the database."},"getEntry(uint256)":{"notice":"Get the Interchain Entry by the writer and the writer nonce."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"requestVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry."},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"notice":"Allows the Interchain Module to verify the entry coming from a remote source chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`."}},"version":1},"developerDoc":{"kind":"dev","methods":{"getEntry(uint256)":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"readEntry(address,(uint256,uint256,bytes32,bytes32))":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry."}},"requestVerification(uint256,uint256,address[])":{"details":"Will revert if the entry with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the written entry on this chain","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyEntry((uint256,uint256,bytes32,bytes32))":{"params":{"entry":"The Interchain Entry to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","destChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the written entry on this chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"existingEntryValue\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"newEntry\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingEntries\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__EntryDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainVerificationRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getEntry\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"readEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"}],\"name\":\"verifyEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getEntry(uint256)\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or zero if the module has not verified the entry.\"}},\"requestVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the entry with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the written entry on this chain\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"params\":{\"entry\":\"The Interchain Entry to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"destChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the written entry on this chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDBNonce()\":{\"notice\":\"Get the nonce of the database.\"},\"getEntry(uint256)\":{\"notice\":\"Get the Interchain Entry by the writer and the writer nonce.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"readEntry(address,(uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"requestVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify the already written entry on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any entry.\"},\"verifyEntry((uint256,uint256,bytes32,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the entry coming from a remote source chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase, and request the given Interchain Modules to verify it on the destination chain. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: additional verification for the same entry could be later done using `requestVerification` by providing the returned `dbNonce`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0xc20920e16f30c1f0b71115ed36050a73e7815e2b4626d34d641ec330bc4eff9f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://849d6e578031903b64b455e11ac821bd3ef81e19a32b9924363ffa02ccb2e74f\",\"dweb:/ipfs/QmWVtBXKJ96Y5FGLX3cfzGUehgHZTJHLxi8kHgmW2rTsUd\"]}},\"version\":1}"},"hashes":{"getDBNonce()":"f338140e","getEntry(uint256)":"bae78d7b","getInterchainFee(uint256,address[])":"fc7686ec","readEntry(address,(uint256,uint256,bytes32,bytes32))":"a9c9cff1","requestVerification(uint256,uint256,address[])":"81ab5b5a","verifyEntry((uint256,uint256,bytes32,bytes32))":"54941dfa","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/InterchainDB.sol:InterchainDBEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(uint256 destChainId, uint256 dbNonce, address[] srcModules);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    LocalEntry[] internal _entries;\n    mapping(address module =\u003e mapping(bytes32 entryKey =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(dbNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 dbNonce)\n    {\n        dbNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(dbNonce, msg.sender, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryKey = InterchainEntryLib.entryKey(entry);\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[msg.sender][entryKey];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[msg.sender][entryKey] = RemoteEntry({verifiedAt: block.timestamp, entryValue: entryValue});\n            emit InterchainEntryVerified(msg.sender, entry.srcChainId, entry.dbNonce, entry.srcWriter, entry.dataHash);\n        } else {\n            // If the module has already verified the entry, check that the entry value is the same\n            if (existingEntry.entryValue != entryValue) {\n                revert InterchainDB__ConflictingEntries(existingEntry.entryValue, entry);\n            }\n            // No-op if the entry value is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[dstModule][InterchainEntryLib.entryKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the one verified by the module\n        return remoteEntry.entryValue == entryValue ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(uint256 dbNonce) public view returns (InterchainEntry memory) {\n        if (getDBNonce() \u003c= dbNonce) {\n            revert InterchainDB__EntryDoesNotExist(dbNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(dbNonce, _entries[dbNonce].writer, _entries[dbNonce].dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entries.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 dbNonce) {\n        dbNonce = _entries.length;\n        _entries.push(LocalEntry(msg.sender, dataHash));\n        emit InterchainEntryWritten(block.chainid, dbNonce, TypeCasts.addressToBytes32(msg.sender), dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.dbNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"module","type":"address"},{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"InterchainEntryWritten","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"destChainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"dbNonce","type":"uint256"},{"indexed":false,"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"InterchainVerificationRequested","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"InterchainEntryWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"InterchainVerificationRequested\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainDBEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0xc20920e16f30c1f0b71115ed36050a73e7815e2b4626d34d641ec330bc4eff9f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://849d6e578031903b64b455e11ac821bd3ef81e19a32b9924363ffa02ccb2e74f\",\"dweb:/ipfs/QmWVtBXKJ96Y5FGLX3cfzGUehgHZTJHLxi8kHgmW2rTsUd\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d8437e77d66966c72e5993ed441b30e6da76bb277b206cc421fe55126c3a9c6a64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d8437e77d66966c72e5993ed441b30e6da76bb277b206cc421fe55126c3a9c6a64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(uint256 destChainId, uint256 dbNonce, address[] srcModules);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    LocalEntry[] internal _entries;\n    mapping(address module =\u003e mapping(bytes32 entryKey =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(dbNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 dbNonce)\n    {\n        dbNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(dbNonce, msg.sender, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryKey = InterchainEntryLib.entryKey(entry);\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[msg.sender][entryKey];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[msg.sender][entryKey] = RemoteEntry({verifiedAt: block.timestamp, entryValue: entryValue});\n            emit InterchainEntryVerified(msg.sender, entry.srcChainId, entry.dbNonce, entry.srcWriter, entry.dataHash);\n        } else {\n            // If the module has already verified the entry, check that the entry value is the same\n            if (existingEntry.entryValue != entryValue) {\n                revert InterchainDB__ConflictingEntries(existingEntry.entryValue, entry);\n            }\n            // No-op if the entry value is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[dstModule][InterchainEntryLib.entryKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the one verified by the module\n        return remoteEntry.entryValue == entryValue ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(uint256 dbNonce) public view returns (InterchainEntry memory) {\n        if (getDBNonce() \u003c= dbNonce) {\n            revert InterchainDB__EntryDoesNotExist(dbNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(dbNonce, _entries[dbNonce].writer, _entries[dbNonce].dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entries.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 dbNonce) {\n        dbNonce = _entries.length;\n        _entries.push(LocalEntry(msg.sender, dataHash));\n        emit InterchainEntryWritten(block.chainid, dbNonce, TypeCasts.addressToBytes32(msg.sender), dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.dbNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"1480:1299:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1480:1299:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"1480:1299:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0xc20920e16f30c1f0b71115ed36050a73e7815e2b4626d34d641ec330bc4eff9f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://849d6e578031903b64b455e11ac821bd3ef81e19a32b9924363ffa02ccb2e74f\",\"dweb:/ipfs/QmWVtBXKJ96Y5FGLX3cfzGUehgHZTJHLxi8kHgmW2rTsUd\"]}},\"version\":1}"},"hashes":{}},"solidity/InterchainDB.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209d867f52ca3ed66217b0052f2e9c670bbf84495f2945dbba44dd39b49cdd7e4464736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209d867f52ca3ed66217b0052f2e9c670bbf84495f2945dbba44dd39b49cdd7e4464736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0;\n\n// contracts/events/InterchainDBEvents.sol\n\nabstract contract InterchainDBEvents {\n    // TODO: figure out indexing\n    event InterchainEntryWritten(uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash);\n    event InterchainEntryVerified(\n        address module, uint256 srcChainId, uint256 dbNonce, bytes32 srcWriter, bytes32 dataHash\n    );\n\n    event InterchainVerificationRequested(uint256 destChainId, uint256 dbNonce, address[] srcModules);\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the entry on the source chain\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing an entry from the local Interchain DataBase.\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    struct LocalEntry {\n        address writer;\n        bytes32 dataHash;\n    }\n\n    /// @notice Struct representing an entry from the remote Interchain DataBase verified by the Interchain Module\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param entryValue   The value of the entry: writer + dataHash hashed together\n    struct RemoteEntry {\n        uint256 verifiedAt;\n        bytes32 entryValue;\n    }\n\n    error InterchainDB__ConflictingEntries(bytes32 existingEntryValue, InterchainEntry newEntry);\n    error InterchainDB__EntryDoesNotExist(uint256 dbNonce);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId();\n\n    /// @notice Write data to the Interchain DataBase as a new entry.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `verifyEntry` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce);\n\n    /// @notice Request the given Interchain Modules to verify the already written entry on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any entry.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param destChainId   The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the written entry on this chain\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestVerification(uint256 destChainId, uint256 dbNonce, address[] memory srcModules) external payable;\n\n    /// @notice Write data to the Interchain DataBase,\n    /// and request the given Interchain Modules to verify it on the destination chain.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: additional verification for the same entry could be later done using `requestVerification`\n    /// by providing the returned `dbNonce`.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the written entry on this chain\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce);\n\n    /// @notice Allows the Interchain Module to verify the entry coming from a remote source chain.\n    /// @param entry        The Interchain Entry to confirm\n    function verifyEntry(InterchainEntry memory entry) external;\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 destChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Get the Interchain Entry by the writer and the writer nonce.\n    /// @dev Will revert if the entry with the given nonce does not exist.\n    /// @param dbNonce      The database nonce of the written entry on this chain\n    function getEntry(uint256 dbNonce) external view returns (InterchainEntry memory);\n\n    /// @notice Get the nonce of the database.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or zero if the module has not verified the entry.\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB();\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId();\n\n    /// @notice Request the verification of an entry in the Interchain DataBase by the module.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyEntry(entry)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param destChainId  The chain id of the destination chain\n    /// @param entry        The entry to verify\n    function requestVerification(uint256 destChainId, InterchainEntry memory entry) external payable;\n\n    /// @notice Get the Module fee for verifying an entry on the specified destination chain\n    /// @param destChainId  The chain id of the destination chain\n    function getModuleFee(uint256 destChainId) external view returns (uint256);\n}\n\n// contracts/InterchainDB.sol\n\ncontract InterchainDB is InterchainDBEvents, IInterchainDB {\n    LocalEntry[] internal _entries;\n    mapping(address module =\u003e mapping(bytes32 entryKey =\u003e RemoteEntry entry)) internal _remoteEntries;\n\n    modifier onlyRemoteChainId(uint256 chainId) {\n        if (chainId == block.chainid) {\n            revert InterchainDB__SameChainId();\n        }\n        _;\n    }\n\n    // ═══════════════════════════════════════════════ WRITER-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce) {\n        return _writeEntry(dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function requestVerification(\n        uint256 destChainId,\n        uint256 dbNonce,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n    {\n        InterchainEntry memory entry = getEntry(dbNonce);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function writeEntryWithVerification(\n        uint256 destChainId,\n        bytes32 dataHash,\n        address[] calldata srcModules\n    )\n        external\n        payable\n        onlyRemoteChainId(destChainId)\n        returns (uint256 dbNonce)\n    {\n        dbNonce = _writeEntry(dataHash);\n        InterchainEntry memory entry = InterchainEntryLib.constructLocalEntry(dbNonce, msg.sender, dataHash);\n        _requestVerification(destChainId, entry, srcModules);\n    }\n\n    // ═══════════════════════════════════════════════ MODULE-FACING ═══════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function verifyEntry(InterchainEntry memory entry) external onlyRemoteChainId(entry.srcChainId) {\n        bytes32 entryKey = InterchainEntryLib.entryKey(entry);\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        RemoteEntry memory existingEntry = _remoteEntries[msg.sender][entryKey];\n        // Check if that's the first time module verifies the entry\n        if (existingEntry.verifiedAt == 0) {\n            _remoteEntries[msg.sender][entryKey] = RemoteEntry({verifiedAt: block.timestamp, entryValue: entryValue});\n            emit InterchainEntryVerified(msg.sender, entry.srcChainId, entry.dbNonce, entry.srcWriter, entry.dataHash);\n        } else {\n            // If the module has already verified the entry, check that the entry value is the same\n            if (existingEntry.entryValue != entryValue) {\n                revert InterchainDB__ConflictingEntries(existingEntry.entryValue, entry);\n            }\n            // No-op if the entry value is the same\n        }\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc IInterchainDB\n    function readEntry(\n        address dstModule,\n        InterchainEntry memory entry\n    )\n        external\n        view\n        onlyRemoteChainId(entry.srcChainId)\n        returns (uint256 moduleVerifiedAt)\n    {\n        RemoteEntry memory remoteEntry = _remoteEntries[dstModule][InterchainEntryLib.entryKey(entry)];\n        bytes32 entryValue = InterchainEntryLib.entryValue(entry);\n        // Check entry value against the one verified by the module\n        return remoteEntry.entryValue == entryValue ? remoteEntry.verifiedAt : 0;\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getInterchainFee(uint256 destChainId, address[] calldata srcModules) external view returns (uint256 fee) {\n        (, fee) = _getModuleFees(destChainId, srcModules);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getEntry(uint256 dbNonce) public view returns (InterchainEntry memory) {\n        if (getDBNonce() \u003c= dbNonce) {\n            revert InterchainDB__EntryDoesNotExist(dbNonce);\n        }\n        return InterchainEntryLib.constructLocalEntry(dbNonce, _entries[dbNonce].writer, _entries[dbNonce].dataHash);\n    }\n\n    /// @inheritdoc IInterchainDB\n    function getDBNonce() public view returns (uint256) {\n        return _entries.length;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Write the entry to the database and emit the event.\n    function _writeEntry(bytes32 dataHash) internal returns (uint256 dbNonce) {\n        dbNonce = _entries.length;\n        _entries.push(LocalEntry(msg.sender, dataHash));\n        emit InterchainEntryWritten(block.chainid, dbNonce, TypeCasts.addressToBytes32(msg.sender), dataHash);\n    }\n\n    /// @dev Request the verification of the entry by the modules, and emit the event.\n    /// Note: the validity of the passed entry and chain id being remote is enforced in the calling function.\n    function _requestVerification(\n        uint256 destChainId,\n        InterchainEntry memory entry,\n        address[] calldata srcModules\n    )\n        internal\n    {\n        (uint256[] memory fees, uint256 totalFee) = _getModuleFees(destChainId, srcModules);\n        if (msg.value != totalFee) {\n            revert InterchainDB__IncorrectFeeAmount(msg.value, totalFee);\n        }\n        uint256 len = srcModules.length;\n        for (uint256 i = 0; i \u003c len; ++i) {\n            IInterchainModule(srcModules[i]).requestVerification{value: fees[i]}(destChainId, entry);\n        }\n        emit InterchainVerificationRequested(destChainId, entry.dbNonce, srcModules);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Get the verification fees for the modules\n    function _getModuleFees(\n        uint256 destChainId,\n        address[] calldata srcModules\n    )\n        internal\n        view\n        returns (uint256[] memory fees, uint256 totalFee)\n    {\n        uint256 len = srcModules.length;\n        if (len == 0) {\n            revert InterchainDB__NoModulesSpecified();\n        }\n        fees = new uint256[](len);\n        for (uint256 i = 0; i \u003c len; ++i) {\n            fees[i] = IInterchainModule(srcModules[i]).getModuleFee(destChainId);\n            totalFee += fees[i];\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"568:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;568:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"568:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/InterchainDB.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/InterchainDB.sol\":{\"keccak256\":\"0xc20920e16f30c1f0b71115ed36050a73e7815e2b4626d34d641ec330bc4eff9f\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://849d6e578031903b64b455e11ac821bd3ef81e19a32b9924363ffa02ccb2e74f\",\"dweb:/ipfs/QmWVtBXKJ96Y5FGLX3cfzGUehgHZTJHLxi8kHgmW2rTsUd\"]}},\"version\":1}"},"hashes":{}}}